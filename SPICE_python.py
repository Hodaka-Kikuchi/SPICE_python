# Automation System for Utility in Research Analysis
# ASYURA
# UB matrixによるoffsetの自動入力
# 右上にバージョン情報を表示
__version__ = '3.3.9'
"""
セマンティック バージョニング (Semantic Versioning)
セマンティック バージョニング（セムバ―、SemVer）は、バージョン番号を「MAJOR.MINOR.PATCH」の形式で表します。それぞれの部分には以下のような意味があります：

MAJOR（メジャー）バージョン:

後方互換性のない変更が導入された場合に増加します。
例：既存のAPIの変更、破壊的な変更。
MINOR（マイナー）バージョン

後方互換性のある新機能が追加された場合に増加します。
例：新しい機能の追加、既存機能の改良（後方互換性がある場合）。
PATCH（パッチ）バージョン:

後方互換性のあるバグ修正が行われた場合に増加します。
例：バグの修正、セキュリティ修正。

バージョン番号の例
1.0.0: 最初の安定版リリース。
1.1.0: 後方互換性のある新機能が追加されたリリース。
1.1.1: バグ修正やマイナーな改良が行われたリリース。
2.0.0: 後方互換性のない変更が導入されたリリース。

新機能付与とバグ修正を行った場合、patchバージョンを+、ラストの数値は0に戻す(更新の必要はない。)。
常に左側の数値の更新が優先。
"""

# tlinterのインポート
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog

# 確定的progressbarの設置
from tkinter import messagebox
from tkinter import simpledialog
import pyperclip

# osのインポート
import os

# ギリシャ文字の定義
import sympy as sm
sm.init_printing()

mu    = sm.Symbol("μ")
theta = sm.Symbol("θ")# "\theta"から変更
alpha    = sm.Symbol("α")
beta    = sm.Symbol("β")
gamma    = sm.Symbol("γ")
AA    = sm.Symbol("Å")

# 数値計算を行うためのパッケージのインポート
from scipy.interpolate import interp1d

# smoothing処理のパッケージ
from scipy.ndimage import gaussian_filter

import numpy as np
import math
import matplotlib
matplotlib.use('TkAgg')#よくわかんないけどこれないとexe化したときにグラフが表示されない。超重要
import matplotlib.pyplot as plt
import matplotlib.widgets as wg #from  matplotlib.widgets import Slider
from mpl_toolkits.mplot3d import Axes3D

from itertools import product

import matplotlib.ticker as mticker

from matplotlib.backend_tools import ToolBase, ToolToggleBase

from matplotlib.colors import LogNorm

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

from matplotlib.widgets import TextBox

import statistics as stat
from scipy import stats
from scipy.stats import norm
from scipy.optimize import curve_fit

# ファイル読み込みのためのやつ
import re

# webに飛ぶやつ
import webbrowser

#windowの作成
root=tk.Tk()
#windowのタイトル変更
root.title(f"ASYURA    ver: {__version__}")
#windowのサイズ指定
root.geometry("550x840")#550*840

# フォント設定
default_font_size = 10
entry_font = ('Helvetica', default_font_size)
#ttk.entry(フレーム名,text=*****,, font=entry_font)で統一可能。ラベルも同様。

# ×ボタンを押すと作成したグラフ全てがクリアされる。
# ウィンドウが閉じられたときの処理
def on_closing():
    # すべてのグラフウィンドウを閉じる
    plt.close('all')
    root.destroy()

root.protocol("WM_DELETE_WINDOW", on_closing)  # ウィンドウが閉じられるときの振る舞いを指定

# gif画像を次のコマンドで文字列に変換(gifじゃないとダメ)
# certutil -encode asyura_logo_w_trans.gif text3.txt

data='''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
OjE5OjU5KzA5OjAweOpGuwAAAABJRU5ErkJggg==
'''

# 選んだ画像を画面左上に埋め込み表示
root.tk.call('wm', 'iconphoto', root._w, tk.PhotoImage(data=data)) 

root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)
root.rowconfigure(1, weight=1)
root.rowconfigure(2, weight=1)

# ファイル選択のフレームの作成と設置
frame2 = ttk.Labelframe(root,text= "dataset information")
frame2.grid(row=0,column=0,padx=5,sticky="NSEW")
#frame2.grid_propagate(True)

frame2.columnconfigure(0, weight=1)
frame2.rowconfigure(0, weight=1)

# テーマ
style = ttk.Style()

# タブの文字色を変えて見やすくする
# Style.map (TNotebook.Tab)
style.map(
    "example.TNotebook.Tab",
    foreground=[
        ('active', 'red'),
        ('disabled', 'black'),
        ('selected', 'blue'),
    ],
    background=[
        ('active', 'orange'),
        ('disabled', 'black'),
        ('selected', 'lightgreen'),
    ],
)

# Notebookウィジェットの作成
notebook00 = ttk.Notebook(frame2,style="example.TNotebook")

# タブの作成
tab_001 = tk.Frame(notebook00)# データファイル選択
tab_002 = tk.Frame(notebook00)# 検出器マスク
# notebookにタブを追加
notebook00.add(tab_001, text="data file(s)")# データファイル選択
notebook00.add(tab_002, text="detector mask")# 検出器マスク

# FGデータ処理フレーム
frame2fg = ttk.Labelframe(tab_001,text= "foreground data file(s)")
frame2fg.grid(row=0, column=0,rowspan=3,sticky="NSEW")
#frame2fg.grid_propagate(True)

# グリッドの重みを設定
tab_001.columnconfigure(0, weight=1)
tab_001.columnconfigure(1, weight=1)
tab_001.columnconfigure(2, weight=1)
tab_001.rowconfigure(0, weight=1)
tab_001.rowconfigure(1, weight=1)
tab_001.rowconfigure(2, weight=1)
tab_001.rowconfigure(3, weight=1)

tab_002.columnconfigure(0, weight=1)
tab_002.columnconfigure(1, weight=1)
tab_002.columnconfigure(2, weight=1)
tab_002.columnconfigure(3, weight=1)
tab_002.columnconfigure(4, weight=1)
tab_002.columnconfigure(5, weight=1)
tab_002.columnconfigure(6, weight=1)
tab_002.columnconfigure(7, weight=1)
tab_002.columnconfigure(8, weight=1)
tab_002.columnconfigure(9, weight=1)
tab_002.rowconfigure(0, weight=1)
tab_002.rowconfigure(1, weight=1)
tab_002.rowconfigure(2, weight=1)
tab_002.rowconfigure(3, weight=1)

frame2fg.columnconfigure(0, weight=1)
frame2fg.columnconfigure(1, weight=1)
frame2fg.columnconfigure(2, weight=1)
frame2fg.rowconfigure(0, weight=1)
frame2fg.rowconfigure(1, weight=1)
frame2fg.rowconfigure(2, weight=1)
#frame2fg.rowconfigure(3, weight=1)

# ウィジェットの配置
notebook00.pack(expand=True, fill='both')

# ダミーのリストボックス
fglist=[]
# 各種ウィジェットの作成
Listbox = tk.Listbox(frame2fg,listvariable=fglist,width=35, height=9)
Listbox.grid(row=1, column=0,columnspan=3,sticky="NSEW")
# スクロールバーの作成
scrollbar = ttk.Scrollbar(frame2fg, orient=tk.VERTICAL, command=Listbox.yview)
scrollbar.grid(row=1, column=3, sticky=(tk.N, tk.S))
# スクロールバーをListboxに反映
Listbox["yscrollcommand"] = scrollbar.set

sbxscrollbar = ttk.Scrollbar(frame2fg, orient=tk.HORIZONTAL, command=Listbox.xview)
sbxscrollbar.grid(row=2, column=0,columnspan=3, sticky=(tk.W, tk.E))
Listbox["xscrollcommand"] = sbxscrollbar.set

file_paths=[]

#ファイル選択処理の定義。ファイル名のみを表示。
def file_select():
    #idir = 'C:\\python_test'
    filetypes = [("dat file","*.dat")]
    global file_paths
    file_paths += tk.filedialog.askopenfilenames(filetypes=filetypes, multiple=True)
    flnmlst = [os.path.basename(item) for item in file_paths]
    global flist
    # filstを重複を許す場合
    #flist = list(flnmlst)
    # flistを重複を許さずかつ順番を保持する場合。setコマンドでは順序が無茶苦茶になる。
    flist = list(dict.fromkeys(flnmlst))
    Listbox.delete(0, tk.END)  # リストボックスの内容をクリア
    for item in flist:
        Listbox.insert(tk.END, item)  # リストボックスにファイル名を追加

#ボックス内をクリアしてリセットして再度検索可能にする
def clear():
    Listbox.delete(0,tk.END)
    file_paths.clear()

#ファイルの入力欄のボタンの作成
button2 = ttk.Button(frame2fg,text="select",command=file_select,width=6)
button2.grid(row=0, column=0,sticky="NSEW")

#ファイルのクリアのボタンの作成
button3 = ttk.Button(frame2fg,text="clear",command=clear,width=6)
button3.grid(row=0, column=2,sticky="NSEW")

# ファイルのマージ
def mergefile():
    # 試しにファイルをマージする機能を作成してみたがいまいち。まぁファイル整理はしやすいかな  
    mf_path = tk.filedialog.asksaveasfilename(
    title = "save as foreground merge data",
    initialdir = "./", # 自分自身のディレクトリ
    defaultextension=".dat", filetypes=[("DAT files", "*.dat")])

    for i in range(len(file_paths)):
        #リストにあるファイルを順に読み込んでいく
        with open(file_paths[i],"r", encoding="utf-8") as f:
            # ファイルの特定の行を読み込み、どのパラメータがどの列かを調べる。
            line = f.readlines()
            data = line[31]
            data2 = data.split()
                        
            if "Pt." in data2:
                pass
            else:
                data = line[32]
                data2 = data.split()
            
            #パラメータは何番目ですか？
            No_Pt=data2.index('Pt.')
            No_c2=data2.index('c2')
            No_a2=data2.index('a2')
            No_timeact=data2.index('time-act')
            #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
            if data.find('mcu')!=-1:
                No_mcu=data2.index('mcu')
            else :
                pass
            No_q=data2.index('q')
            No_h=data2.index('h')
            No_k=data2.index('k')
            No_l=data2.index('l')
            No_T=data2.index('tsample')
            No_e=data2.index('e')
            No_ei=data2.index('ei')
            No_D01=data2.index('D01')
            No_D24=data2.index('D24')
            #選択ファイルの数値を全て読み込む
            rdb = np.loadtxt(file_paths[i], comments='#')
            # データが１次元配列の際に２次元配列に格納
            if len(rdb.shape) == 1:
                rdb = np.expand_dims(rdb, axis=0)
            # 最終的に読み込むのはtime-act,mcu,c2,a2,e,ei,detectorだけだから
            t_a = rdb[:,No_timeact-1].reshape(-1, 1)
            # time-actが0のデータを検索
            Ind_t0 = np.where(t_a == 0)
            # time-actが0のデータを削除
            rdb = np.delete(rdb, Ind_t0, axis=0)
            
            pt = rdb[:,No_Pt-1].reshape(-1, 1)
            c2 = rdb[:,No_c2-1].reshape(-1, 1)
            a2 = rdb[:,No_a2-1].reshape(-1, 1)
            q = rdb[:,No_q-1].reshape(-1, 1)
            h = rdb[:,No_h-1].reshape(-1, 1)
            k = rdb[:,No_k-1].reshape(-1, 1)
            l = rdb[:,No_l-1].reshape(-1, 1)
            T = rdb[:,No_T-1].reshape(-1, 1)
            #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
            if data.find('mcu')!=-1:
                mcu = rdb[:,No_mcu-1].reshape(-1, 1)
            else :
                mcu = np.zeros((len(pt))).reshape(-1, 1)
            e = rdb[:,No_e-1].reshape(-1, 1)
            ei = rdb[:,No_ei-1].reshape(-1, 1)
            D = rdb[:,No_D01-1:No_D24]
            
            new_rdb = np.hstack((pt,t_a,mcu,D,a2,c2,ei,e,q,h,k,l,T))
            
            if i == 0:
                NEW_rdb=new_rdb
            #databox.extend(Qvector)
            if i > 0:
                NEW_rdb=(np.vstack([NEW_rdb, new_rdb]))
                
    # 最初のinformationの情報を付け足す。
    with open(file_paths[0],"r", encoding="utf-8") as f:
        # ファイルの特定の行を読み込み、どのパラメータがどの列かを調べる。
        line = f.readlines()
        data = line[31]
        data2 = data.split()            
        if "Pt." in data2:
            lines = line[0:31]
        else:
            lines = line[0:32]
        # headerの作成 
        header = ["Pt. time-act mcu D01 D02 D03 D04 D05 D06 D07 D08 D09 D10 D11 D12 D13 D14 D15 D16 D17 D18 D19 D20 D21 D22 D23 D24 a2 c2 ei e q h k l tsample"]
        with open(mf_path, "w") as f1:
            f1.writelines(lines)
            f1.write(f"# {', '.join(header)}\n")
            # データを文字列に変換して書き込む
            for row in NEW_rdb:
                row_str = ' '.join(map(str, row))
                f1.write(row_str + '\n')            
               
#マージファイルのクリアのボタンの作成
button3_3 = ttk.Button(frame2fg,text="merge",command=mergefile,width=6)
button3_3.grid(row=0, column=1,sticky="NSEW")

########
# toleranceの自動設定
def update_labels():
    if hw_nan.get():
        fgt_lbl1.config(text="δℏω")
        bgt_lbl1.config(text="δℏω")
    else:
        fgt_lbl1.config(text="±δℏω")
        bgt_lbl1.config(text="±Δℏω")

# チェックボタンの状態を保持する変数
hw_nan = tk.BooleanVar()

# UVラベルの自動設定
def update_UVlabel1(*args):
    u_text = entry_u_var.get()
    v_text = entry_v_var.get()
    
    # 3d view, 2d viewボタン
    constE_buttom.set(f"{u_text} vs {v_text}")
    constV_buttom.set(f"ℏω vs {v_text}")
    constU_buttom.set(f"ℏω vs {u_text}")
    # 3d viewのラベル
    initialV_label.set(f"initial {v_text}")
    initialU_label.set(f"initial {u_text}")
    # 1d viewのボタン
    IvsU_buttom.set(f"I vs {u_text}")
    addIvsU_buttom.set(f"add I vs {u_text}")
    IvsV_buttom.set(f"I vs {v_text}")
    addIvsV_buttom.set(f"add I vs {v_text}")
    # data constructionのラベル
    minU_label.set(f"min {u_text}")
    maxU_label.set(f"max {u_text}")
    binU_label.set(f"bin {u_text}")
    minV_label.set(f"min {v_text}")
    maxV_label.set(f"max {v_text}")
    binV_label.set(f"bin {v_text}")
    # 2d view,1d viewのラベル
    U_lavel.set(f"{u_text}")
    V_lavel.set(f"{v_text}")
    pmU_lavel.set(f"±{u_text}")
    pmV_lavel.set(f"±{v_text}")
    # calculationのラベル
    calc_constU_buttom.set(f"const {u_text}")
    calc_constV_buttom.set(f"const {v_text}")
    # smoothingのラベル
    deltaU.set(f"δ{u_text}")
    deltaV.set(f"δ{v_text}")

    # saveのラベル
    # メニューのラベルを更新
    filemenu.entryconfig(save_menu_index1, label=f"save 2D_{u_text}-{v_text}")
    filemenu.entryconfig(save_menu_index2, label=f"save 2D_ℏω-{v_text}")
    filemenu.entryconfig(save_menu_index3, label=f"save 2D_ℏω-{u_text}")
    filemenu.entryconfig(save_menu_index4, label=f"save 1D_I-{u_text}")
    filemenu.entryconfig(save_menu_index5, label=f"save 1D_I-{v_text}")
    
# StringVarを作成
entry_u_var = tk.StringVar()
entry_v_var = tk.StringVar()

minU_label = tk.StringVar()
maxU_label = tk.StringVar()
binU_label = tk.StringVar()
minV_label = tk.StringVar()
maxV_label = tk.StringVar()
binV_label = tk.StringVar()

constE_buttom = tk.StringVar()
constV_buttom = tk.StringVar()
constU_buttom = tk.StringVar()

initialU_label = tk.StringVar()
initialV_label = tk.StringVar()

IvsU_buttom = tk.StringVar()
addIvsU_buttom = tk.StringVar()
IvsV_buttom = tk.StringVar()
addIvsV_buttom = tk.StringVar()

U_lavel = tk.StringVar()
V_lavel = tk.StringVar()
pmU_lavel = tk.StringVar()
pmV_lavel = tk.StringVar()

calc_constU_buttom = tk.StringVar()
calc_constV_buttom = tk.StringVar()

deltaU = tk.StringVar()
deltaV = tk.StringVar()

# 変更例
# label = tk.Label(root, textvariable=constE_buttom)

########
# Calibrationデータ処理フレーム
frame2cb = ttk.Labelframe(tab_001,text= "calibration data file")
frame2cb.grid(row=0, column=2,sticky="NSEW")
#frame2cb.grid_propagate(True)

frame2cb.columnconfigure(0, weight=1)
frame2cb.columnconfigure(1, weight=1)
frame2cb.columnconfigure(2, weight=1)
frame2cb.rowconfigure(0, weight=1)
frame2cb.rowconfigure(1, weight=1)

#ダミーのリストボックスを表示
vlist=[]
# 各種ウィジェットの作成
vListbox = tk.Listbox(frame2cb,listvariable=vlist,width=35, height=1)

# 各種ウィジェットの設置
vListbox.grid(row=1, column=0,sticky="NSEW", columnspan=3)
    
#バナジウムコレクション。ファイル名のみを表示。
def vfile_select():
    vListbox.delete(0, tk.END)
    #idir = 'C:\\python_test'
    filetypes=[("dat file", "*.dat")]
    global vfile_path
    vfile_path = tk.filedialog.askopenfilenames(filetypes = filetypes,multiple = False)
    vflnmlst = [os.path.basename(item) for item in vfile_path]
    #basename = os.path.basename(file_list)
    #input_box.insert(tk.END, flnmlst)
    #ファイル名をリスト化
    # listbox = tk.Listbox(root, flnmlst)
    vflist=list(vflnmlst)
    # Listboxの選択肢
    vListbox.insert(tk.END, vflist)

#ボックス内をクリアしてリセットして再度検索可能にする
def vclear():
    vListbox.delete(0,tk.END)
    vfile_path=[]

#ファイルの入力欄のボタンの作成
button2_2 = ttk.Button(frame2cb,text="select",command=vfile_select)
button2_2.grid(row=0, column=0,sticky="NSEW")

#ファイルのクリアのボタンの作成
button3_2 = ttk.Button(frame2cb,text="clear",command=vclear)
button3_2.grid(row=0, column=2,sticky="NSEW")

#キャリブレーションの定義。ファイルはenergyscan。ピークセンターとピーク強度のみが必要
def calibration():
    with open(vfile_path[0],"r", encoding="utf-8") as f:
        line = f.readlines()
        head = line[31]
        head2 = head.split()
        if "Pt." in head2:
            pass
        else:
            head = line[32]
            head2 = head.split()
    
        #パラメータは何番目ですか？
        #global No_Pt,No_c2,No_a2,No_mcu,No_e,No_ei,No_D01,No_D02,No_D03,No_D04,No_D05,No_D06,No_D07,No_D08,No_D09,No_D10,No_D11,No_D12,No_D13,No_D14,No_D15,No_D16,No_D17,No_D18,No_D19,No_D20,No_D21,No_D22,No_D23,No_D24
        No_Pt=head2.index('Pt.')
        No_c2=head2.index('c2')
        No_a2=head2.index('a2')
        No_timeact=head2.index('time-act')
        #mcuは最初から読み込まない
        No_e=head2.index('e')
        No_ei=head2.index('ei')
        No_D01=head2.index('D01')
        No_D24=head2.index('D24')
    
    #リストにあるファイルを順に読み込んでいく
    with open(vfile_path[0],"r", encoding="utf-8") as f:
        #選択ファイルの数値を全て読み込む
        vrdb = np.loadtxt(vfile_path[0], comments='#')
        
    t_a = vrdb[:,No_timeact-1]
    # time-actが0のデータを検索
    Ind_t0 = np.where(t_a == 0)
    # time-actが0のデータを削除
    vrdb = np.delete(vrdb, Ind_t0, axis=0)
    
    pt = vrdb[:,No_Pt-1]
    c2 = vrdb[:,No_c2-1]
    a2 = vrdb[:,No_a2-1]
    
    e = vrdb[:,No_e-1]
    ei = vrdb[:,No_ei-1]
    D_I = vrdb[:,No_D01-1:No_D24]
    
    #ガウス関数fitting
    def func(x, a, mu, sigma, bg):
        return a*np.exp(-(x-mu)**2/(2*sigma**2))+bg
    #初期値
    param_ini = [200,0,0.1,0]
    # 1つの図を作成
    fig, ax = plt.subplots(6, 4, sharex=True, sharey=True)
    #fig=plt.figure()
    fit_param = np.zeros((24,4))
    fit_result=np.zeros((3,24))
    for i in range(6):
        for j in range(4):
            index = i * 4 + j
            popt, pcov = curve_fit(func, e, D_I[:,index], p0=param_ini, maxfev=1000)
            fitting = func(e, popt[0],popt[1],popt[2],popt[3])
            fit_param[i * 4 + j,:]=[popt[0],popt[1],popt[2],popt[3]]
            #高さ popt[0]
            #中心 popt[1]
            #幅　popt[2]
            #background popt[3]
            fit_result[0,i]=popt[0]#intensity
            #積分強度
            #fit_result[0,i]=popt[0]*2*(2*math.log(2))**(1/2)*abs(popt[2])*(3.1415926535/(4*math.log(2)))**(1/2)#intensity
            fit_result[1,index]=popt[1]#energy transter center
            fit_result[2,index]=2*(2*math.log(2))**(1/2)*abs(popt[2])#FWHM

            ax[i, j].errorbar(e,D_I[:,index],yerr=D_I[:,index]**(1/2), capsize=10, zorder=1,color='k',label='D'+str(index+1))
            ax[i, j].text(0.05,1.05,'I='+str(format(popt[0]*2*(2*math.log(2))**(1/2)*abs(popt[2])*(3.1415926535/(4*math.log(2)))**(1/2), '.1f'))+',Ec='+str(format(popt[1], '.4f'))+',FWHM='+str(format(2*(2*math.log(2))**(1/2)*abs(popt[2]), '.4f')), transform=ax[i, j].transAxes)
            ax[i, j].plot(e,fitting,'r', zorder=2)
            #ax.set_xlabel('e (meV)')
            #ax.set_ylabel('Intensity (a.u.)')
            ax[i, j].legend()
    
    fig.supxlabel('ℏω (meV)')
    fig.supylabel('Intensity (a.u.)')
    plt.tight_layout()
    plt.show()
    
#キャリブレーションのボタンの作成
button3_4 = ttk.Button(frame2cb,text="fit",command=calibration)
button3_4.grid(row=0, column=1,sticky="NSEW")

# 表示するデータの形式を選択
frame2a = ttk.Labelframe(tab_001,text= "intensity type")
frame2a.grid(row=1, column=2,sticky="NSEW")
#frame2a.grid_propagate(True)

frame2a.columnconfigure(0, weight=1)
frame2a.columnconfigure(1, weight=1)
frame2a.columnconfigure(2, weight=1)
frame2a.columnconfigure(3, weight=1)
frame2a.rowconfigure(0, weight=1)
frame2a.rowconfigure(1, weight=1)
frame2a.rowconfigure(2, weight=1)

# チェック有無変数
CSX = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
CSX.set(1)

# ラジオボタン作成
# TASの場合、出てくるデータはS(q,w)であるのでクロスセクションはいらない
#rdo_csx1 = tk.Radiobutton(frame2a, value=0, variable=CSX, text='σ')
#rdo_csx1.grid(row=0,column=0, sticky="w")

rdo_csx2 = tk.Radiobutton(frame2a, value=1, variable=CSX, text='S(q,ω)')
rdo_csx2.grid(row=0,column=0,sticky="NSEW")

# 係数を入力する欄
sb_lbl1 = tk.Label(frame2a,text='factor =')
sb_lbl1.grid(row=0, column=1,sticky="NSEW")
sb_txt1 = ttk.Entry(frame2a,width=5)
sb_txt1.grid(row=0, column=2,sticky="NSEW")
sb_txt1.insert(0,'1')

rdo_csx3 = tk.Radiobutton(frame2a, value=2, variable=CSX, text='χ(q,ω)')
rdo_csx3.grid(row=1,column=0,sticky="NSEW", rowspan=2)

# 係数を入力する欄
sb_lbl2_1 = tk.Label(frame2a,text='T_fg =')
sb_lbl2_1.grid(row=1, column=1,sticky="NSEW")
sb_txt2 = ttk.Entry(frame2a,width=5)
sb_txt2.grid(row=1, column=2,sticky="NSEW")
sb_txt2.insert(0,'1')
sb_lbl2_2 = tk.Label(frame2a,text='K')
sb_lbl2_2.grid(row=1, column=3,sticky="NSEW")

sb_lbl3 = tk.Label(frame2a,text='T_bg =')
sb_lbl3.grid(row=2, column=1,sticky="NSEW")
sb_txt3 = ttk.Entry(frame2a,width=5)
sb_txt3.grid(row=2, column=2,sticky="NSEW")
sb_txt3.insert(0,'300')
sb_lbl3_2 = tk.Label(frame2a,text='K')
sb_lbl3_2.grid(row=2, column=3,sticky="NSEW")

def factor_toggle_entries_state():
    if CSX.get() == 1:  # S(q,w)が選択されている場合
        sb_txt1.config(state=tk.NORMAL)  # sb_txt1を有効にする
        sb_txt2.config(state=tk.DISABLED)  # sb_txt2を無効にする
        sb_txt3.config(state=tk.DISABLED)  # sb_txt3を無効にする
    elif CSX.get() == 2:  # X(q,w)が選択されている場合
        sb_txt1.config(state=tk.DISABLED)  # sb_txt1を有効にする
        sb_txt2.config(state=tk.NORMAL)  # sb_txt2を有効にする
        sb_txt3.config(state=tk.NORMAL)  # sb_txt3を有効にする

# プログラム開始時に一度だけtoggle_entries_stateを呼び出す
factor_toggle_entries_state()

# Radiobutton選択状態の変更時にtoggle_entries_state関数を呼び出す
CSX.trace('w', lambda *args: factor_toggle_entries_state())

###############################

# backgroundデータを選択する。
# FGデータ処理フレーム
frame2bg = ttk.Labelframe(tab_001,text= "background data file(s)")
frame2bg.grid(row=0, column=1,rowspan=3,sticky="NSEW")
#frame2bg.grid_propagate(True)

frame2bg.columnconfigure(0, weight=1)
frame2bg.columnconfigure(1, weight=1)
frame2bg.columnconfigure(2, weight=1)
frame2bg.rowconfigure(0, weight=1)
frame2bg.rowconfigure(1, weight=1)
frame2bg.rowconfigure(2, weight=1)
#frame2bg.rowconfigure(3, weight=1)

#ダミーのリストボックス
sblist=[]
# 各種ウィジェットの作成
sbListbox = tk.Listbox(frame2bg,listvariable=sblist,width=35,height=9)
sbListbox.grid(row=1, column=0,columnspan=3,sticky="NSEW")
# スクロールバーの作成
scrollbar = ttk.Scrollbar(frame2bg, orient=tk.VERTICAL, command=sbListbox.yview)
scrollbar.grid(row=1, column=3, sticky=(tk.N, tk.S))
# スクロールバーをListboxに反映
sbListbox["yscrollcommand"] = scrollbar.set

sbxscrollbar = ttk.Scrollbar(frame2bg, orient=tk.HORIZONTAL, command=sbListbox.xview)
sbxscrollbar.grid(row=2, column=0,columnspan=3, sticky=(tk.W, tk.E))
sbListbox["xscrollcommand"] = sbxscrollbar.set

sbfile_paths=[]
#ファイル選択処理の定義。ファイル名のみを表示。
def sbfile_select():
    #idir = 'C:\\python_test'
    filetypes = [("dat file","*.dat")]
    global sbfile_paths
    sbfile_paths += tk.filedialog.askopenfilenames(filetypes=filetypes, multiple=True)
    sbflnmlst = [os.path.basename(item) for item in sbfile_paths]
    global sblists
    # sbfilstを重複を許す場合
    #sblists = list(sbflnmlst)
    # sbflistを重複を許さずかつ順番を保持する場合。setコマンドでは順序が無茶苦茶になる。
    sblists = list(dict.fromkeys(sbflnmlst))
    sbListbox.delete(0, tk.END)  # リストボックスの内容をクリア
    for item in sblists:
        sbListbox.insert(tk.END, item)  # リストボックスにファイル名を追加
  
#ボックス内をクリアしてリセットして再度検索可能にする
def sbclear():
    sbListbox.delete(0,tk.END)
    sbfile_paths.clear()

#ファイルの入力欄のボタンの作成
button1_sb = ttk.Button(frame2bg,text="select",command=sbfile_select,width=6)
button1_sb.grid(row=0, column=0,sticky="NSEW")

#ファイルのクリアのボタンの作成
button2_sb = ttk.Button(frame2bg,text="clear",command=sbclear,width=6)
button2_sb.grid(row=0, column=2,sticky="NSEW")

# ファイルのマージ
def  mergefile_sb():
    # 試しにファイルをマージする機能を作成してみたがいまいち。まぁファイル整理はしやすいかな  
    mf_path = tk.filedialog.asksaveasfilename(
    title = "save as ground merge data",
    initialdir = "./", # 自分自身のディレクトリ
    defaultextension=".dat", filetypes=[("DAT files", "*.dat")])

    for i in range(len(sbfile_paths)):
        #リストにあるファイルを順に読み込んでいく
        with open(sbfile_paths[i],"r", encoding="utf-8") as f:
            # ファイルの特定の行を読み込み、どのパラメータがどの列かを調べる。
            line = f.readlines()
            data = line[31]
            data2 = data.split()
                        
            if "Pt." in data2:
                pass
            else:
                data = line[32]
                data2 = data.split()
            
            #パラメータは何番目ですか？
            sbNo_Pt=data2.index('Pt.')
            sbNo_c2=data2.index('c2')
            sbNo_a2=data2.index('a2')
            sbNo_q=data2.index('q')
            sbNo_h=data2.index('h')
            sbNo_k=data2.index('k')
            sbNo_l=data2.index('l')
            sbNo_T=data2.index('tsample')
            sbNo_timeact=data2.index('time-act')
            #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
            if data.find('mcu')!=-1:
                sbNo_mcu=data2.index('mcu')
            else :
                pass
            sbNo_e=data2.index('e')
            sbNo_ei=data2.index('ei')
            sbNo_D01=data2.index('D01')
            sbNo_D24=data2.index('D24')
            
            #選択ファイルの数値を全て読み込む
            sbrdb = np.loadtxt(sbfile_paths[i], comments='#')
            # データが１次元配列の際に２次元配列に格納
            if len(sbrdb.shape) == 1:
                sbrdb = np.expand_dims(sbrdb, axis=0)
            # 最終的に読み込むのはtime-act,mcu,c2,a2,e,ei,detectorだけだから
            t_a = sbrdb[:,sbNo_timeact-1].reshape(-1, 1)
            # time-actが0のデータを検索
            Ind_t0 = np.where(t_a == 0)
            # time-actが0のデータを削除
            sbrdb = np.delete(sbrdb, Ind_t0, axis=0)
            
            pt = sbrdb[:,sbNo_Pt-1].reshape(-1, 1)
            c2 = sbrdb[:,sbNo_c2-1].reshape(-1, 1)
            a2 = sbrdb[:,sbNo_a2-1].reshape(-1, 1)
            q = sbrdb[:,sbNo_q-1].reshape(-1, 1)
            h = sbrdb[:,sbNo_h-1].reshape(-1, 1)
            k = sbrdb[:,sbNo_k-1].reshape(-1, 1)
            l = sbrdb[:,sbNo_l-1].reshape(-1, 1)
            T = sbrdb[:,sbNo_T-1].reshape(-1, 1)
            #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
            if data.find('mcu')!=-1:
                mcu = sbrdb[:,sbNo_mcu-1].reshape(-1, 1)
            else :
                mcu = np.zeros((len(pt))).reshape(-1, 1)
            e = sbrdb[:,sbNo_e-1].reshape(-1, 1)
            ei = sbrdb[:,sbNo_ei-1].reshape(-1, 1)
            D = sbrdb[:,sbNo_D01-1:sbNo_D24]
            
            new_sbrdb = np.hstack((pt,t_a,mcu,D,a2,c2,ei,e,q,h,k,l,T))
            
            if i == 0:
                NEW_sbrdb=new_sbrdb
            #databox.extend(Qvector)
            if i > 0:
                NEW_sbrdb=(np.vstack([NEW_sbrdb, new_sbrdb]))
                
    # 最初のinformationの情報を付け足す。
    with open(sbfile_paths[0],"r", encoding="utf-8") as f:
        # ファイルの特定の行を読み込み、どのパラメータがどの列かを調べる。
        line = f.readlines()
        data = line[31]
        data2 = data.split()            
        if "Pt." in data2:
            lines = line[0:31]
        else:
            lines = line[0:32]
        # headerの作成 
        header = ["Pt. time-act mcu D01 D02 D03 D04 D05 D06 D07 D08 D09 D10 D11 D12 D13 D14 D15 D16 D17 D18 D19 D20 D21 D22 D23 D24 a2 c2 ei e q h k l tsample"]
        with open(mf_path, "w") as f1:
            f1.writelines(lines)
            f1.write(f"# {', '.join(header)}\n")
            # データを文字列に変換して書き込む
            for row in NEW_sbrdb:
                row_str = ' '.join(map(str, row))
                f1.write(row_str + '\n')    
               
#マージファイルのクリアのボタンの作成
button3_sb = ttk.Button(frame2bg,text="merge",command=mergefile_sb,width=6)
button3_sb.grid(row=0, column=1,sticky="NSEW")
###############################

# data toleranceフレーム
frame2fg0 = ttk.Labelframe(tab_001,text= "tolerance")
frame2fg0.grid(row=3, column=0,columnspan=3,sticky="NSEW")
#frame2fg0.grid_propagate(True)

frame2fg0.columnconfigure(0, weight=1)
frame2fg0.columnconfigure(1, weight=1)
frame2fg0.columnconfigure(2, weight=1)
frame2fg0.columnconfigure(3, weight=1)
frame2fg0.columnconfigure(4, weight=1)
frame2fg0.columnconfigure(5, weight=1)
frame2fg0.columnconfigure(6, weight=1)
frame2fg0.columnconfigure(7, weight=1)
frame2fg0.columnconfigure(8, weight=1)
frame2fg0.columnconfigure(9, weight=1)
frame2fg0.columnconfigure(10, weight=1)
frame2fg0.columnconfigure(11, weight=1)
frame2fg0.columnconfigure(12, weight=1)
frame2fg0.rowconfigure(0, weight=1)
frame2fg0.rowconfigure(1, weight=1)

fgt_lbl0 = tk.Label(frame2fg0,text='fg : ')
fgt_lbl0.grid(row=0, column=0,sticky="NSEW")

fgt_lbl1 = tk.Label(frame2fg0,text='±δℏω',width=5)
fgt_lbl1.grid(row=0, column=1,sticky="NSEW")
fgt_txt1 = ttk.Entry(frame2fg0,width=6)
fgt_txt1.grid(row=0, column=2,sticky="NSEW")

fgt_lbl2 = tk.Label(frame2fg0,width=3,textvariable=deltaU)
fgt_lbl2.grid(row=0, column=7,sticky="NSEW")
fgt_txt2 = ttk.Entry(frame2fg0,width=6)
fgt_txt2.grid(row=0, column=8,sticky="NSEW")

fgt_lbl3 = tk.Label(frame2fg0,width=3,textvariable=deltaV)
fgt_lbl3.grid(row=0, column=9,sticky="NSEW")
fgt_txt3 = ttk.Entry(frame2fg0,width=6)
fgt_txt3.grid(row=0, column=10,sticky="NSEW")

# powder
fgt_lbl4 = tk.Label(frame2fg0,text='δQ',width=3)
fgt_lbl4.grid(row=0, column=11,sticky="NSEW")
fgt_txt4 = ttk.Entry(frame2fg0,width=6)
fgt_txt4.grid(row=0, column=12,sticky="NSEW")

# background
bgt_lbl0 = tk.Label(frame2fg0,text='bg : ')
bgt_lbl0.grid(row=1, column=0,sticky="NSEW")

bgt_lbl1 = tk.Label(frame2fg0,text='±Δℏω',width=5)
bgt_lbl1.grid(row=1, column=1,sticky="NSEW")
bgt_txt1 = ttk.Entry(frame2fg0,width=6)
bgt_txt1.grid(row=1, column=2,sticky="NSEW")

bgt_lbl4 = tk.Label(frame2fg0,text='±δA2',width=4)
bgt_lbl4.grid(row=1, column=3,sticky="NSEW")
bgt_txt4 = ttk.Entry(frame2fg0,width=6)
bgt_txt4.grid(row=1, column=4,sticky="NSEW")

bgt_lbl5 = tk.Label(frame2fg0,text='±δC2',width=4)
bgt_lbl5.grid(row=1, column=5,sticky="NSEW")
bgt_txt5 = ttk.Entry(frame2fg0,width=6)
bgt_txt5.grid(row=1, column=6,sticky="NSEW")

bgt_lbl2 = tk.Label(frame2fg0,width=3,textvariable=deltaU)
bgt_lbl2.grid(row=1, column=7,sticky="NSEW")
bgt_txt2 = ttk.Entry(frame2fg0,width=6)
bgt_txt2.grid(row=1, column=8,sticky="NSEW")

bgt_lbl3 = tk.Label(frame2fg0,width=3,textvariable=deltaV)
bgt_lbl3.grid(row=1, column=9,sticky="NSEW")
bgt_txt3 = ttk.Entry(frame2fg0,width=6)
bgt_txt3.grid(row=1, column=10,sticky="NSEW")

# powder
bgt_lbl6 = tk.Label(frame2fg0,text='δQ',width=3)
bgt_lbl6.grid(row=1, column=11,sticky="NSEW")
bgt_txt6 = ttk.Entry(frame2fg0,width=6)
bgt_txt6.grid(row=1, column=12,sticky="NSEW")

# BGデータ処理方法フレーム
frame2bgm = ttk.Labelframe(tab_001,text= "subtraction method")
frame2bgm.grid(row=2, column=2,sticky="NSEW")
#frame2fg.grid_propagate(True)

frame2bgm.columnconfigure(0, weight=1)
frame2bgm.columnconfigure(1, weight=1)
frame2bgm.rowconfigure(0, weight=1)
frame2bgm.rowconfigure(1, weight=1)

# チェック有無変数
bg_type = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
bg_type.set(0)

# bgm=bg_type.get()でdetector by detector=0 もしくは pixel by pixel=1を選択
rdo_bg1 = tk.Radiobutton(frame2bgm, value=0, variable=bg_type, text='detector')#もともとframeGL
rdo_bg1.grid(row=0,column=0,sticky="NSEW")

rdo_bg2 = tk.Radiobutton(frame2bgm, value=1, variable=bg_type, text='pixel')#もともとframeGL
rdo_bg2.grid(row=1,column=0,sticky="NSEW")

# チェック有無変数
sbtype1 = tk.IntVar()
# value=0にチェックを入れる
sbtype1.set(1)

sb_nearest = tk.Checkbutton(frame2bgm, variable=sbtype1, text='nearest')
sb_nearest.grid(row=0, column=1,sticky="NSEW")

def toggle_entry():
    if sbtype1.get()==1:
        bgt_txt4.config(state=tk.DISABLED) # dlta A2
        bgt_txt5.config(state=tk.DISABLED) # dlta C2
    elif  sbtype1.get()==0:
        bgt_txt4.config(state=tk.NORMAL) # dlta A2
        bgt_txt5.config(state=tk.NORMAL) # dlta C2

# プログラム開始時に一度だけtoggle_entryを呼び出す
toggle_entry()

# Radiobutton選択状態の変更時にtoggle_entry関数を呼び出す
sbtype1.trace('w', lambda *args: toggle_entry())

# チェック有無変数
sbtype2 = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
sbtype2.set(1)

sb_nan = tk.Checkbutton(frame2bgm, variable=sbtype2, text='trans NaN')
sb_nan.grid(row=1, column=1,sticky="NSEW")

def toggle_checkbox():
    if bg_type.get() == 0:# detector
        sb_nearest.config(state=tk.NORMAL)
        sb_nan.config(state=tk.NORMAL)
    elif bg_type.get() == 1: # pixel
        sb_nearest.config(state=tk.DISABLED)
        sb_nan.config(state=tk.NORMAL)  
        
# プログラム開始時に一度だけtoggle_entries_stateを呼び出す
toggle_checkbox()

# Radiobutton選択状態の変更時にtoggle_entries_state関数を呼び出す
bg_type.trace('w', lambda *args: toggle_checkbox())

def toggle_entries_state():
    if bg_type.get() == 0:  # rdo_bg1が選択(detector-detector)されている場合
        #bgt_txt1.config(state=tk.NORMAL)  # dE # 有効にする
        #bgt_txt2.config(state=tk.DISABLED) # dU # 有効にする
        #bgt_txt3.config(state=tk.DISABLED) # dV
        #bgt_txt4.config(state=tk.NORMAL) # dlta A2
        #bgt_txt5.config(state=tk.NORMAL) # dlta C2
        #bgt_txt6.config(state=tk.DISABLED) # dQ
        #checkbox.config(state="disabled")
        if sbtype1.get()==1:
            bgt_txt4.config(state=tk.DISABLED) # dlta A2
            bgt_txt5.config(state=tk.DISABLED) # dlta C2
        elif  sbtype1.get()==0:
            bgt_txt4.config(state=tk.NORMAL) # dlta A2
            bgt_txt5.config(state=tk.NORMAL) # dlta C2
    else:# rdo_bg2が選択(pixel-pixel)されている場合
        #bgt_txt1.config(state=tk.DISABLED)
        #bgt_txt2.config(state=tk.NORMAL)
        #bgt_txt3.config(state=tk.NORMAL)
        bgt_txt4.config(state=tk.DISABLED)
        bgt_txt5.config(state=tk.DISABLED)
        #bgt_txt6.config(state=tk.NORMAL)
        #checkbox.config(state="normal")

# プログラム開始時に一度だけtoggle_entries_stateを呼び出す
toggle_entries_state()

# Radiobutton選択状態の変更時にtoggle_entries_state関数を呼び出す
bg_type.trace('w', lambda *args: toggle_entries_state())

#################################################################################
# 検出器マスク機能

# clearボタンの定義
def maskclear():
    for var in check_vars:
        var.set(0)
        
# allボタンの定義
def maskall():
    for var in check_vars:
        var.set(1)

# 選択オプション
options = ["D {}".format(i+1) for i in range(24)]

# チェックボタンの変数を管理するリスト
check_vars = []

# チェックボタンを作成し、変数をリストに追加
check_buttons = []
for i, option in enumerate(options):
    var = tk.IntVar()
    check_vars.append(var)
    check_button = tk.Checkbutton(tab_002, text=option, variable=var)
    check_buttons.append(check_button)
    row_num, col_num = divmod(i, 10)
    check_button.grid(row=row_num, column=col_num, sticky="w")

# allボタンを設置
mask_all = ttk.Button(tab_002,text="select all",command=maskall)
mask_all.grid(row=3, column=3, columnspan=2, sticky="NSEW")

# clearボタンを設置
mask_cle = ttk.Button(tab_002,text="clear all",command=maskclear)
mask_cle.grid(row=3, column=5, columnspan=2, sticky="NSEW")

#################################################################################

# 格子定数と初期位置の入力フレーム
frame3 = ttk.Labelframe(root, text= "sample information")
frame3.grid(row=1,column=0,padx=5,sticky="NSEW")
#frame3.grid_propagate(True)

# グリッドの重みを設定
#tab_001.columnconfigure(0, weight=1)
#tab_001.rowconfigure(0, weight=1)
frame3.columnconfigure(0, weight=1)
frame3.columnconfigure(1, weight=1)
frame3.columnconfigure(2, weight=1)
frame3.columnconfigure(3, weight=1)
frame3.columnconfigure(4, weight=1)
frame3.columnconfigure(5, weight=1)
frame3.columnconfigure(6, weight=1)
frame3.columnconfigure(7, weight=1)
frame3.rowconfigure(0, weight=1)
frame3.rowconfigure(1, weight=1)
frame3.rowconfigure(2, weight=1)
frame3.rowconfigure(3, weight=1)
frame3.rowconfigure(4, weight=1)
frame3.rowconfigure(5, weight=1)
frame3.rowconfigure(6, weight=1)

# 格子定数を入力欄ラベル
lbl1 = tk.Label(frame3,text='a',width=6)
lbl1.grid(row=0, column=0, sticky="NSEW")
lbl2 = tk.Label(frame3,text='b',width=6)
lbl2.grid(row=0, column=1, sticky="NSEW")
lbl3 = tk.Label(frame3,text='c',width=6)
lbl3.grid(row=0, column=2, sticky="NSEW")

# 格子定数の入力欄
txt1 = ttk.Entry(frame3,width=6)
txt1.grid(row=1, column=0, sticky="NSEW")
txt2 = ttk.Entry(frame3,width=6)
txt2.grid(row=1, column=1, sticky="NSEW")
txt3 = ttk.Entry(frame3,width=6)
txt3.grid(row=1, column=2, sticky="NSEW")

# alpha,beta,gammaの入力欄ラベル
lbl4 = tk.Label(frame3,text=alpha,width=6)
lbl4.grid(row=2, column=0, sticky="NSEW")
lbl5 = tk.Label(frame3,text=beta,width=6)
lbl5.grid(row=2, column=1, sticky="NSEW")
lbl6 = tk.Label(frame3,text=gamma,width=6)
lbl6.grid(row=2, column=2, sticky="NSEW")

# alpha,beta,gammaの入力欄
txt4 = ttk.Entry(frame3,width=6)
txt4.grid(row=3, column=0, sticky="NSEW")
txt5 = ttk.Entry(frame3,width=6)
txt5.grid(row=3, column=1, sticky="NSEW")
txt6 = ttk.Entry(frame3,width=6)
txt6.grid(row=3, column=2, sticky="NSEW")

# c2とa2のオフセット入力欄ラベル
lbl7 = tk.Label(frame3,text='c2@V',width=6)
lbl7.grid(row=4, column=0, sticky="NSEW")
lbl8 = tk.Label(frame3,text='×V@3.635meV',width=6)
lbl8.grid(row=4, column=1, sticky="NSEW")
# c2オフセット入力欄とEf=3.635meVの条件で軸立てしたときのVを入力する欄
txt7 = ttk.Entry(frame3,width=6)
txt7.grid(row=5, column=0, sticky="NSEW")
txt8 = ttk.Entry(frame3,width=6)
txt8.grid(row=5, column=1, sticky="NSEW")
txt8.insert(0,'1')

# mcu規格化の入力欄ラベルと入力欄
txt15 = tk.Label(frame3,text='N_mcu',width=6)
txt15.grid(row=4, column=2, sticky="NSEW")
txt15 = ttk.Entry(frame3,width=6)
txt15.grid(row=5, column=2, sticky="NSEW")

# ダミーのラベル欄
#lbl_sp = tk.Label(frame3,text='',width=1)
#lbl_sp.grid(row=3, column=3, sticky="NSEW")

# UVベクトルの入力欄ラベル
lbl9 = tk.Label(frame3,text='U1',width=6)
lbl9.grid(row=0, column=4, sticky="NSEW")
lbl10 = tk.Label(frame3,text='U2',width=6)
lbl10.grid(row=0, column=5, sticky="NSEW")
lbl11 = tk.Label(frame3,text='U3',width=6)
lbl11.grid(row=0, column=6, sticky="NSEW")
lbl12 = tk.Label(frame3,text='V1',width=6)
lbl12.grid(row=2, column=4, sticky="NSEW")
lbl13 = tk.Label(frame3,text='V2',width=6)
lbl13.grid(row=2, column=5, sticky="NSEW")
lbl14 = tk.Label(frame3,text='V3',width=6)
lbl14.grid(row=2, column=6, sticky="NSEW")

# Uベクトルの入力欄
txt9 = ttk.Entry(frame3,width=6)
txt9.grid(row=1, column=4, sticky="NSEW")
txt10 = ttk.Entry(frame3,width=6)
txt10.grid(row=1, column=5, sticky="NSEW")
txt11 = ttk.Entry(frame3,width=6)
txt11.grid(row=1, column=6, sticky="NSEW")

# Uベクトルの名前入力欄
lbl_ul = tk.Label(frame3,text='U label',width=6)
lbl_ul.grid(row=0, column=7, sticky="NSEW")
txt_ul = ttk.Entry(frame3, textvariable=entry_u_var,width=6)
txt_ul.grid(row=1, column=7, sticky="NSEW")

# Vベクトルの入力欄
txt12 = ttk.Entry(frame3,width=6)
txt12.grid(row=3, column=4, sticky="NSEW")
txt13 = ttk.Entry(frame3,width=6)
txt13.grid(row=3, column=5, sticky="NSEW")
txt14 = ttk.Entry(frame3,width=6)
txt14.grid(row=3, column=6, sticky="NSEW")

# Vベクトルの名前入力欄
lbl_vl = tk.Label(frame3,text='V label',width=6)
lbl_vl.grid(row=2, column=7, sticky="NSEW")
txt_vl = ttk.Entry(frame3, textvariable=entry_v_var,width=6)
txt_vl.grid(row=3, column=7, sticky="NSEW")

##############################################################
# これまでに打ち込んだ数値群を保存する。
def write_param():
    #テキストバックス内の内容を取得
    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    c2_off=float(txt7.get())
    Vt=float(txt8.get())
    N_mcu=float(txt15.get())
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    u_l=txt_ul.get()
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())
    v_l=txt_vl.get()
    
    #変数をまとめる
    param=[la,lb,lc,lal,lbe,lga,c2_off,Vt,N_mcu,u1,u2,u3,u_l,v1,v2,v3,v_l]
    #ファイルへの書き込み(小数点5桁で保存)
    filename = tk.filedialog.asksaveasfilename(
        title = "save as parameter file",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(param)
##################################################################

#ファイルの読み込みのボタンの作成
button4 = ttk.Button(frame3,text="save param",command=write_param)
button4.grid(row=6, column=0, sticky="NSEW")

# SPICEのファイルからパラメータを読みだす。
def initialize_param():
    #散乱面１の読み込み
    with open(file_paths[0],"r", encoding="utf-8") as f:
        sv1 = f.readlines()[15]
        SV1 = sv1.split()

    #散乱面２の読み込み
    with open(file_paths[0],"r", encoding="utf-8") as f:
        sv2 = f.readlines()[16]
        SV2 = sv2.split()

    # 格子定数のパラメータの読み込み
    with open(file_paths[0],"r", encoding="utf-8") as f:
        lc = f.readlines()[20].strip()
        LC = lc.split(',')
        LC2 = re.sub(r"[^\d.-]", '',LC[0])
        #LC2 = LC.strip()
        
    # mcuを読み込む
    with open(file_paths[0],"r", encoding="utf-8") as f:
        head = f.readlines()[32]
        head2 = head.split()
        #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
        if head.find('mcu')!=-1:
            global No_mcu
            No_mcu=head2.index('mcu')
            with open(file_paths[0],"r", encoding="utf-8") as f:
                default = f.readlines()[33]
                N_mcu = default.split()[No_mcu-1]
        else :
            N_mcu=0

    txt1.delete(0,tk.END)
    txt1.insert(0,LC2)
    txt2.delete(0,tk.END)
    txt2.insert(0,LC[1])
    txt3.delete(0,tk.END)
    txt3.insert(0,LC[2])
    txt4.delete(0,tk.END)
    txt4.insert(0,LC[3])
    txt5.delete(0,tk.END)
    txt5.insert(0,LC[4])
    txt6.delete(0,tk.END)
    txt6.insert(0,LC[5])
    """
    txt7.delete(0,tk.END)
    txt7.insert(0,0)
    txt8.delete(0,tk.END)
    txt8.insert(0,0)
    """
    txt15.delete(0,tk.END)
    txt15.insert(0,N_mcu)
    txt9.delete(0,tk.END)
    txt9.insert(0,SV1[5])
    txt10.delete(0,tk.END)
    txt10.insert(0,SV1[6])
    txt11.delete(0,tk.END)
    txt11.insert(0,SV1[7])
    txt12.delete(0,tk.END)
    txt12.insert(0,SV2[5])
    txt13.delete(0,tk.END)
    txt13.insert(0,SV2[6])
    txt14.delete(0,tk.END)
    txt14.insert(0,SV2[7])

#SPICE出力ファイルを読み込みサンプル情報をボックスに自動入力してくれるボタンの作成
button5 = ttk.Button(frame3,text="initialize",command=initialize_param)
button5.grid(row=6, column=2, sticky="NSEW")

def load_param():
    #csvファイルを呼び出す。
    filetypes = [("csv file","*.csv")]
 
    pfile_path = tk.filedialog.askopenfilename(filetypes = filetypes)
    with open(pfile_path, newline='') as f:
        csvreader = csv.reader(f)
        for row in csvreader:
            pass

    txt1.delete(0,tk.END)
    txt1.insert(0,row[0])
    txt2.delete(0,tk.END)
    txt2.insert(0,row[1])
    txt3.delete(0,tk.END)
    txt3.insert(0,row[2])
    txt4.delete(0,tk.END)
    txt4.insert(0,row[3])
    txt5.delete(0,tk.END)
    txt5.insert(0,row[4])
    txt6.delete(0,tk.END)
    txt6.insert(0,row[5])
    txt7.delete(0,tk.END)
    txt7.insert(0,row[6])
    txt8.delete(0,tk.END)
    txt8.insert(0,row[7])
    txt15.delete(0,tk.END)
    txt15.insert(0,row[8])
    txt9.delete(0,tk.END)
    txt9.insert(0,row[9])
    txt10.delete(0,tk.END)
    txt10.insert(0,row[10])
    txt11.delete(0,tk.END)
    txt11.insert(0,row[11])
    txt_ul.delete(0,tk.END)
    txt_ul.insert(0,row[12])
    txt12.delete(0,tk.END)
    txt12.insert(0,row[13])
    txt13.delete(0,tk.END)
    txt13.insert(0,row[14])
    txt14.delete(0,tk.END)
    txt14.insert(0,row[15])
    txt_vl.delete(0,tk.END)
    txt_vl.insert(0,row[16])

#csv形式で保存したパラメータを呼び出すボタン
button5_2 = ttk.Button(frame3,text="load param",command=load_param)
button5_2.grid(row=6, column=1, sticky="NSEW")

# 空のプログレスバーを表示
pb = ttk.Progressbar(frame3, orient="horizontal", mode="determinate")
pb.grid(row=6, column=6, columnspan=2, sticky="NSEW")

#ファイルの読み込みボタンの定義
def loadfile():
    # 補正用fittingは常に毎回行う。変なファイルを選んだ時にcalibrationを毎回押すのはめんどくさい。そんなに時間もかからないし。
    
    # fittingから検出器効率の補正値を算出する
    with open(vfile_path[0], "r", encoding="utf-8") as f:
        line = f.readlines()
        chead = line[31]
        chead2 = chead.split()
        if "Pt." in chead2:
            pass
        else:
            chead = line[32]
            chead2 = chead.split()

        #パラメータは何番目ですか？
        No_Pt=chead2.index('Pt.')
        No_c2=chead2.index('c2')
        No_a2=chead2.index('a2')
        No_timeact=chead2.index('time-act')
        #mcuは最初から読み込まない
        No_e=chead2.index('e')
        No_ei=chead2.index('ei')
        No_D01=chead2.index('D01')
        No_D24=chead2.index('D24')
    
    #リストにあるファイルを順に読み込んでいく
    with open(vfile_path[0],"r", encoding="utf-8") as f:
        #選択ファイルの数値を全て読み込む
        vrdb = np.loadtxt(vfile_path[0], comments='#')
        
    t_a = vrdb[:,No_timeact-1]
    # time-actが0のデータを検索
    Ind_t0 = np.where(t_a == 0)
    # time-actが0のデータを削除
    vrdb = np.delete(vrdb, Ind_t0, axis=0)
    
    pt = vrdb[:,No_Pt-1]
    c2 = vrdb[:,No_c2-1]
    a2 = vrdb[:,No_a2-1]
    
    e = vrdb[:,No_e-1]
    ei = vrdb[:,No_ei-1]
    D_I = vrdb[:,No_D01-1:No_D24]
    
    #ガウス関数fitting
    def func(x, a, mu, sigma, bg):
        return a*np.exp(-(x-mu)**2/(2*sigma**2))+bg
    
    #初期値
    param_ini = [100,0,0.1,0]
    fit_param = np.zeros((24,4))
    fit_result=np.zeros((3,24))
    for i in range(24):
        popt, pcov = curve_fit(func, e, D_I[:,i], p0=param_ini)
        #高さ popt[0]
        #中心 popt[1]
        #幅　popt[2]
        #background popt[3]
        #fit_result[0,i]=popt[0]#intensity
        #積分強度
        fit_param[i,:]=[popt[0],popt[1],popt[2],popt[3]]
        
        #fit_result[0,i]=popt[0]*2*(2*math.log(2))**(1/2)*abs(popt[2])*(3.1415926535/(4*math.log(2)))**(1/2)#intensity
        fit_result[0,i]=popt[0]# height
        fit_result[1,i]=popt[1]#energy transfer
        fit_result[2,i]=2*(2*math.log(2))**(1/2)*abs(popt[2])#FWHM
    
    # Efのtoleranceは保存する。
    global ef_tol,ef_cen
    ef_tol = np.max(fit_result[1,:]) - np.min(fit_result[1,:])
    ef_cen = np.mean(fit_result[1,:])
    
    """
    # デフォルトでcalibrationのFHWMが入力される
    if fgt_txt1.get()=='':
        if hw_nan.get()==0:
            fgt_txt1.insert(0,round(ef_tol+0.005,3))
    """
    
    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    c2_off=float(txt7.get())
    Vt=float(txt8.get())
    N_mcu=float(txt15.get())
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())
    
    bgm=bg_type.get()
    
    #pp_bg_tof=pp_BG_tof_var.get()

    #散乱面のベクトルを指定
    global u,v
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    vt = [v1*Vt,v2*Vt,v3*Vt]

    # ベクトルu,v,wを定義し、rluを自動で計算する
    U = [la*math.cos(math.radians(0)), 0, 0]
    V = [lb*math.cos(math.radians(lga)), lb*math.sin(math.radians(lga)), 0]
    W = [lc*math.cos(math.radians(lbe)), lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)), math.sqrt(lc**2-(lc*math.cos(math.radians(lbe)))**2-(lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)))**2)]
    astar = 2*3.141592*np.cross(V,W)/np.dot(U,np.cross(V,W))
    bstar = 2*3.141592*np.cross(W,U)/np.dot(V,np.cross(W,U))
    cstar = 2*3.141592*np.cross(U,V)/np.dot(W,np.cross(U,V))

    U1=u[0]*astar+u[1]*bstar+u[2]*cstar
    V1=v[0]*astar+v[1]*bstar+v[2]*cstar
    Vt1=vt[0]*astar+vt[1]*bstar+vt[2]*cstar

    #計算されたrlu
    global NU1,NV1
    NU1=np.linalg.norm(U1)
    NV1=np.linalg.norm(V1)
    NVt1=np.linalg.norm(Vt1)
    # 面間隔を計算
    dhkl=2*math.pi/NVt1
    # ここで出るのはθだから気を付けること
    hacho=9.044/((3.635)**(1/2))
    tta=math.degrees(math.asin(hacho/(2*dhkl)))

    #入力した値から色々計算
    w_off = c2_off - tta
    
    # プログレスバー内の変数にアクセスできるように一番外枠でglobal定義
    global pb
    var1 = 0 # 変数の初期値
    # 最初にバックグラウンドを差し引くか決定。(処理スピードを優先)
    if sbListbox.size() == 0:
        # プログレスバーの表示
        pb["maximum"] = len(file_paths) # プログレスバーの最大値
        pb["value"] = 0
        pb.update()
        
        for i in range(len(file_paths)):
            # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
            with open(file_paths[i],"r", encoding="utf-8") as f:
                line = f.readlines()
                head = line[31]
                head2 = head.split()
                if "Pt." in head2:
                    pass
                else:
                    head = line[32]
                    head2 = head.split()
            
                #パラメータは何番目ですか？
                #global No_Pt,No_c2,No_a2,No_mcu,No_e,No_ei,No_D01,No_D02,No_D03,No_D04,No_D05,No_D06,No_D07,No_D08,No_D09,No_D10,No_D11,No_D12,No_D13,No_D14,No_D15,No_D16,No_D17,No_D18,No_D19,No_D20,No_D21,No_D22,No_D23,No_D24
                No_Pt=head2.index('Pt.')
                No_c2=head2.index('c2')
                No_a2=head2.index('a2')
                No_timeact=head2.index('time-act')
                #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                if head.find('mcu')!=-1:
                    No_mcu=head2.index('mcu')
                else :
                    pass
                
                #No_mcu=data2.index('mcu')
                No_e=head2.index('e')
                No_ei=head2.index('ei')
                No_D01=head2.index('D01')
                No_D24=head2.index('D24')
            
            #リストにあるファイルを順に読み込んでいく
            with open(file_paths[i],"r", encoding="utf-8") as f:
                #選択ファイルの数値を全て読み込む
                rdb = np.loadtxt(file_paths[i], comments='#')
                # データが１次元配列の際に２次元配列に格納
                if len(rdb.shape) == 1:
                    rdb = np.expand_dims(rdb, axis=0)
                
                t_a = rdb[:,No_timeact-1]
                # time-actが0のデータを検索
                Ind_t0 = np.where(t_a == 0)
                # time-actが0のデータを削除
                rdb = np.delete(rdb, Ind_t0, axis=0)
                
                pt = rdb[:,No_Pt-1]
                c2 = rdb[:,No_c2-1]
                a2 = rdb[:,No_a2-1]
                #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                if head.find('mcu')!=-1:
                    mcu = rdb[:,No_mcu-1]
                else :
                    mcu = np.zeros((len(pt)))
                e = rdb[:,No_e-1]
                ei = rdb[:,No_ei-1]
                D = rdb[:,No_D01-1:No_D24]
            
            #kiとkfの定義
            ki = np.zeros((2, len(pt)))
            kf = np.zeros((2, len(pt)*24))
            #ki2 = np.zeros((2, len(pt)*24))
            #Qのベクトルとスカラーの定義、あとここに強度の情報を加える。
            global Qvector
            Qvector=np.zeros((6, len(pt)*24))# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
            #検出器の角度
            d_angle=np.linspace(0, 46, 24)
            A2 = np.zeros((1, 24))
            phi=-22;# offset angle of No.1
            #C2のオフセット
            C2=c2-w_off

            #　HODACAで測定した点を計算してくれる
            #pythonでは行列の数えやfor文は0から始まるので注意すること
            for n in range(len(pt)):# nは各ファイルのデータの個数に対応
                #ki_x[0,n] = math.sqrt(ei[n]/2.072)*math.cos(math.radians(-c2[n]))
                #ki_y[0,n] = -math.sqrt(ei[n]/2.072)*math.sin(math.radians(-c2[n]))
                ki[0:2,n] = [math.sqrt(ei[n]/2.072)*math.cos(math.radians(-C2[n])),-math.sqrt(ei[n]/2.072)*math.sin(math.radians(-C2[n]))]
                #A2の絶対値変換
                A2=d_angle+phi+a2[n];# cover range
                for m in range(24):# mは検出器の番号に対応
                    #ki2[:,24*n+m] = ki[:,n]
                    # 各検出器の補正として-fit_result[1,m]
                    kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                    #kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                    Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]                   
                    #powder用にqも入れておく
                    Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                    # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                    Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                    # 強度の情報を入れる。ここでバナジウムとmcuの補正をする。12番を基準とする
                    Qvector[4,24*n+m] = D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                    Qvector[5,24*n+m] = math.sqrt(D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                    
            # 全てのデータを格納するボックスを立ち上げる。Qvectorのデータをどんどん連結していく。最初のファイルだけdataboxをQvectorにする。
            if i == 0:
                Databox=Qvector
            #databox.extend(Qvector)
            if i > 0:
                Databox=(np.concatenate([Databox, Qvector], 1))

            # プログレスバー (確定的)。エネルギー毎にステータスが進む
            var1=var1+1
            #pb.configure(value = var1)
            pb["value"] = var1
            pb.update()
            
    else: #バックグラウンドファイルのリストボックスにファイルがあるとき
        if bgm==0:# detectro by detector
            # detector by detectorFGとBGの許容エネルギー差を入力。
            if bgt_txt1.get()=='':
                bgt_txt1.insert(0,0.01)
            # この段階でバックグラウンドのすべてのデータを読み込んでしまう。
            # プログレスバーの表示
            pb["maximum"] = len(file_paths)+len(sbfile_paths) # プログレスバーの最大値
            pb["value"] = 0
            pb.update()
            
            # detector by detectorにおけるA2,C2 tolerance
            if sbtype1.get()==0:# チェックボックスが平均化の場合
                dE = float(bgt_txt1.get())
                tol_A2 = float(bgt_txt4.get())
                tol_C2 = float(bgt_txt5.get())
                for k in range(len(sbfile_paths)):
                    # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
                    with open(sbfile_paths[k],"r", encoding="utf-8") as f:
                        line = f.readlines()
                        sbhead = line[31]
                        sbhead2 = sbhead.split()
                        if "Pt." in sbhead2:
                            pass
                        else:
                            sbhead = line[32]
                            sbhead2 = sbhead.split()
                    
                        #パラメータは何番目ですか？
                        #global SbNo_Pt,SbNo_c2,SbNo_a2,SbNo_mcu,SbNo_e,SbNo_ei,SbNo_D01,SbNo_D02,SbNo_D03,SbNo_D04,SbNo_D05,SbNo_D06,SbNo_D07,SbNo_D08,SbNo_D09,SbNo_D10,SbNo_D11,SbNo_D12,SbNo_D13,SbNo_D14,SbNo_D15,SbNo_D16,SbNo_D17,SbNo_D18,SbNo_D19,SbNo_D20,SbNo_D21,SbNo_D22,SbNo_D23,SbNo_D24
                        sbNo_Pt=sbhead2.index('Pt.')
                        sbNo_c2=sbhead2.index('c2')
                        sbNo_a2=sbhead2.index('a2')
                        sbNo_timeact=sbhead2.index('time-act')
                        #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                        if sbhead.find('mcu')!=-1:
                            sbNo_mcu=sbhead2.index('mcu')
                        else :
                            pass
                        
                        #SbNo_mcu=data2.index('mcu')
                        sbNo_e=sbhead2.index('e')
                        sbNo_ei=sbhead2.index('ei')
                        sbNo_D01=sbhead2.index('D01')
                        sbNo_D24=sbhead2.index('D24')
                    
                    #リストにあるファイルを順に読み込んでいく
                    with open(sbfile_paths[k],"r", encoding="utf-8") as f:
                        #選択ファイルの数値を全て読み込む
                        sbrdb = np.loadtxt(sbfile_paths[k], comments='#')
                        
                        # データが１次元配列の際に２次元配列に格納
                        if len(sbrdb.shape) == 1:
                            sbrdb = np.expand_dims(sbrdb, axis=0)
                        
                        sbt_a = sbrdb[:,sbNo_timeact-1]
                        # time-actが0のデータを検索
                        sbInd_t0 = np.where(sbt_a == 0)
                        # time-actが0のデータを削除
                        sbrdb = np.delete(sbrdb, sbInd_t0, axis=0)
                        sbpt = sbrdb[:,sbNo_Pt-1].reshape(-1, 1)
                        sbe = sbrdb[:,sbNo_e-1].reshape(-1, 1)
                        sbei = sbrdb[:,sbNo_ei-1].reshape(-1, 1)
                        sbc2 = sbrdb[:,sbNo_c2-1].reshape(-1, 1)
                        sba2 = sbrdb[:,sbNo_a2-1].reshape(-1, 1)
                        #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                        if sbhead.find('mcu')!=-1:
                            sbmcu = sbrdb[:,sbNo_mcu-1].reshape(-1, 1)
                        else :
                            sbmcu = np.zeros((len(sbpt))).reshape(-1, 1)
                        sbD = sbrdb[:,sbNo_D01-1:sbNo_D24]
                            
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var1=var1+1
                    pb.configure(value = var1)
                    pb.update()
                    #バックグラウンドのデータを積算する。

                    if k == 0:
                        # 縦方向に連結
                        sb_Databox0 = np.hstack((sbpt,sbe,sbei,sbc2,sba2,sbD,sbmcu))
                    #databox.extend(Qvector)
                    if k > 0:
                        # 横方向に連結
                        sb_Databox0=np.vstack((sb_Databox0,np.hstack((sbpt,sbe,sbei,sbc2,sba2,sbD,sbmcu))))
                #sb_Databox=sb_Databox.T
                    
                for i in range(len(file_paths)):
                    # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
                    with open(file_paths[i],"r", encoding="utf-8") as f:
                        line = f.readlines()
                        head = line[31]
                        head2 = head.split()
                        if "Pt." in head2:
                            pass
                        else:
                            head = line[32]
                            head2 = head.split()
                            
                        #パラメータは何番目ですか？
                        #global No_Pt,No_c2,No_a2,No_mcu,No_e,No_ei,No_D01,No_D02,No_D03,No_D04,No_D05,No_D06,No_D07,No_D08,No_D09,No_D10,No_D11,No_D12,No_D13,No_D14,No_D15,No_D16,No_D17,No_D18,No_D19,No_D20,No_D21,No_D22,No_D23,No_D24
                        No_Pt=head2.index('Pt.')
                        No_c2=head2.index('c2')
                        No_a2=head2.index('a2')
                        No_timeact=head2.index('time-act')
                        #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                        if head.find('mcu')!=-1:
                            No_mcu=head2.index('mcu')
                        else :
                            pass
                        
                        #No_mcu=data2.index('mcu')
                        No_e=head2.index('e')
                        No_ei=head2.index('ei')
                        No_D01=head2.index('D01')
                        No_D24=head2.index('D24')
                    
                    #リストにあるファイルを順に読み込んでいく
                    with open(file_paths[i],"r", encoding="utf-8") as f:
                        #選択ファイルの数値を全て読み込む
                        rdb = np.loadtxt(file_paths[i], comments='#')
                        
                        # データが１次元配列の際に２次元配列に格納
                        if len(rdb.shape) == 1:
                            rdb = np.expand_dims(rdb, axis=0)
                        
                        t_a = rdb[:,No_timeact-1]
                        # time-actが0のデータを検索
                        Ind_t0 = np.where(t_a == 0)
                        # time-actが0のデータを削除
                        rdb = np.delete(rdb, Ind_t0, axis=0)
                        
                        pt = rdb[:,No_Pt-1]
                        c2 = rdb[:,No_c2-1]
                        a2 = rdb[:,No_a2-1]
                        #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                        if head.find('mcu')!=-1:
                            mcu = rdb[:,No_mcu-1]
                        else :
                            mcu = np.zeros((len(pt)))
                        e = rdb[:,No_e-1]
                        ei = rdb[:,No_ei-1]
                        D = rdb[:,No_D01-1:No_D24]
                    
                    #kiとkfの定義
                    ki = np.zeros((2, len(pt)))
                    kf = np.zeros((2, len(pt)*24))
                    #ki2 = np.zeros((2, len(pt)*24))
                    #Qのベクトルとスカラーの定義、あとここに強度の情報を加える。
                    Qvector=np.zeros((6, len(pt)*24))# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
                    global sb_Qvector
                    sb_Qvector=np.zeros((6, len(pt)*24))# backgroundファイル用
                    #検出器の角度
                    d_angle=np.linspace(0, 46, 24)
                    A2 = np.zeros((1, 24))
                    phi=-22;# offset angle of No.1
                    #C2のオフセット
                    C2=c2-w_off

                    #　HODACAで測定した点を計算してくれる
                    #pythonでは行列の数えやfor文は0から始まるので注意すること
                    for n in range(len(pt)):# nは各ファイルのデータの個数に対応
                        
                        #ki_x[0,n] = math.sqrt(ei[n]/2.072)*math.cos(math.radians(-c2[n]))
                        #ki_y[0,n] = -math.sqrt(ei[n]/2.072)*math.sin(math.radians(-c2[n]))
                        ki[0:2,n] = [math.sqrt(ei[n]/2.072)*math.cos(math.radians(-C2[n])),-math.sqrt(ei[n]/2.072)*math.sin(math.radians(-C2[n]))]
                        #A2の絶対値変換
                        A2=d_angle+phi+a2[n];# cover range
                        
                        # ここで対応するバックグラウンドデータを差し引く。
                        # ((sbpt,sbe,sbei,sbc2,sba2,sbD01,sbD02,sbD03,sbD04,sbD05,sbD06,sbD07,sbD08,sbD09,sbD10,sbD11,sbD12,sbD13,sbD14,sbD15,sbD16,sbD17,sbD18,sbD19,sbD20,sbD21,sbD22,sbD23,sbD24))
                        
                        # まずはエネルギートランスファーが一致する部分を抜き出す。補正をする前同士作業なのでOK。
                        # エネルギースキャンステップに依存するがとりあえず一般的なモータートレランスの範囲内にあるエネルギー値のものをサーチする。
                        ind_E = (list(zip(*np.where(((e[n]-dE) < sb_Databox0[:,1]) & (sb_Databox0[:,1] < (e[n]+dE))))))
                        # リスト型に出力
                        Ind_E = list(np.ravel(ind_E))
                        
                        if len(Ind_E) > 0:# Ind_Eが空でないとき
                            sb_data_e=sb_Databox0[Ind_E,:]
                            # まずA2が最も近いデータを選び、その中からC2が最も近いデータを選ぶ。
                            sba2 = sb_data_e[:,4]
                            sbc2 = sb_data_e[:,3]
                            
                            # 新しいコードではtol_A2とtol_C2を設定できる。指定がない場合は±180degの範囲から選択する。                       
                            ind_tol_A2C2 = (list(zip(*np.where( ((a2[n] - tol_A2) < sba2) & (sba2 < (a2[n] + tol_A2)) & ((c2[n] - tol_C2) < sbc2) & (sbc2 < (c2[n] + tol_C2)) ))))
                            index_BG = list(np.ravel(ind_tol_A2C2))
                            
                            for m in range(24):# mは検出器の番号に対応
                                #ki2[:,24*n+m] = ki[:,n]
                                # 各検出器の補正として-fit_result[1,m]
                                kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                #kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                sb_Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                #powder用にqも入れておく
                                Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                sb_Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                                Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                sb_Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                # 強度の情報を入れる。ここでバナジウムとmcuの補正をする。12番を基準とする。
                                Qvector[4,24*n+m] = D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                sb_Qvector[4,24*n+m] = np.sum(sb_data_e[index_BG,5+m])/fit_result[0,m]*fit_result[0,11]*N_mcu/np.sum(sb_data_e[index_BG,29])
                                Qvector[5,24*n+m] = (math.sqrt(D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n])
                                sb_Qvector[5,24*n+m] = math.sqrt(np.sum(sb_data_e[index_BG,5+m]))/fit_result[0,m]*fit_result[0,11]*N_mcu/np.sum(sb_data_e[index_BG,29])

                        else:# 対応するエネルギーが無かった場合
                            if sbtype2.get()==0:# Nanが選択されていない
                                for m in range(24):# mは検出器の番号に対応
                                    #ki2[:,24*n+m] = ki[:,n]
                                    # 各検出器の補正として-fit_result[1,m]
                                    kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                    #kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                    Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                    sb_Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                    #powder用にqも入れておく
                                    Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                    sb_Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                    # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                                    Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                    sb_Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                    Qvector[4,24*n+m] = D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                    sb_Qvector[4,24*n+m] = np.nan
                                    Qvector[5,24*n+m] = math.sqrt(D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                    sb_Qvector[5,24*n+m] = np.nan
                            else:# Nanが選択されている
                                pass
                            
                    # 全てのデータを格納するボックスを立ち上げる。Qvectorのデータをどんどん連結していく。最初のファイルだけdataboxをQvectorにする。
                    if i == 0:
                        Databox=Qvector
                        sb_Databox=sb_Qvector
                    #databox.extend(Qvector)
                    if i > 0:
                        Databox=(np.concatenate([Databox, Qvector], 1))
                        sb_Databox=(np.concatenate([sb_Databox, sb_Qvector], 1))

                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var1=var1+1
                    pb["value"] = var1
                    pb.update() 
                
            elif sbtype1.get()==1:# チェックボックスが最隣接選択の場合。デフォルトはこっち。
                dE=float(bgt_txt1.get())
                for k in range(len(sbfile_paths)):
                    # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
                    with open(sbfile_paths[k],"r", encoding="utf-8") as f:
                        line = f.readlines()
                        sbhead = line[31]
                        sbhead2 = sbhead.split()
                        if "Pt." in sbhead2:
                            pass
                        else:
                            sbhead = line[32]
                            sbhead2 = sbhead.split()
                    
                        #パラメータは何番目ですか？
                        #global SbNo_Pt,SbNo_c2,SbNo_a2,SbNo_mcu,SbNo_e,SbNo_ei,SbNo_D01,SbNo_D02,SbNo_D03,SbNo_D04,SbNo_D05,SbNo_D06,SbNo_D07,SbNo_D08,SbNo_D09,SbNo_D10,SbNo_D11,SbNo_D12,SbNo_D13,SbNo_D14,SbNo_D15,SbNo_D16,SbNo_D17,SbNo_D18,SbNo_D19,SbNo_D20,SbNo_D21,SbNo_D22,SbNo_D23,SbNo_D24
                        sbNo_Pt=sbhead2.index('Pt.')
                        sbNo_c2=sbhead2.index('c2')
                        sbNo_a2=sbhead2.index('a2')
                        sbNo_timeact=sbhead2.index('time-act')
                        #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                        if sbhead.find('mcu')!=-1:
                            sbNo_mcu=sbhead2.index('mcu')
                        else :
                            pass
                        
                        #SbNo_mcu=data2.index('mcu')
                        sbNo_e=sbhead2.index('e')
                        sbNo_ei=sbhead2.index('ei')
                        sbNo_D01=sbhead2.index('D01')
                        sbNo_D24=sbhead2.index('D24')
                    
                    #リストにあるファイルを順に読み込んでいく
                    with open(sbfile_paths[k],"r", encoding="utf-8") as f:
                        #選択ファイルの数値を全て読み込む
                        sbrdb = np.loadtxt(sbfile_paths[k], comments='#')
                        
                        # データが１次元配列の際に２次元配列に格納
                        if len(sbrdb.shape) == 1:
                            sbrdb = np.expand_dims(sbrdb, axis=0)
                        
                        sbt_a = sbrdb[:,sbNo_timeact-1].reshape(-1, 1)
                        # time-actが0のデータを検索
                        sbInd_t0 = np.where(sbt_a == 0)
                        # time-actが0のデータを削除
                        sbrdb = np.delete(sbrdb, sbInd_t0, axis=0)
                        sbpt = sbrdb[:,sbNo_Pt-1].reshape(-1, 1)
                        sbe = sbrdb[:,sbNo_e-1].reshape(-1, 1)
                        sbei = sbrdb[:,sbNo_ei-1].reshape(-1, 1)
                        sbc2 = sbrdb[:,sbNo_c2-1].reshape(-1, 1)
                        sba2 = sbrdb[:,sbNo_a2-1].reshape(-1, 1)
                        #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                        if sbhead.find('mcu')!=-1:
                            sbmcu = sbrdb[:,sbNo_mcu-1].reshape(-1, 1)
                        else :
                            sbmcu = np.zeros((len(sbpt))).reshape(-1, 1)
                        sbD = sbrdb[:,sbNo_D01-1:sbNo_D24]
                            
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var1=var1+1
                    pb.configure(value = var1)
                    pb.update()
                    #バックグラウンドのデータを積算する。

                    if k == 0:
                        # 縦方向に連結
                        sb_Databox0 = np.hstack((sbpt,sbe,sbei,sbc2,sba2,sbD,sbmcu))
                    #databox.extend(Qvector)
                    if k > 0:
                        # 横方向に連結
                        sb_Databox0=np.vstack((sb_Databox0,np.hstack((sbpt,sbe,sbei,sbc2,sba2,sbD,sbmcu))))
                for i in range(len(file_paths)):
                    # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
                    with open(file_paths[i],"r", encoding="utf-8") as f:
                        line = f.readlines()
                        head = line[31]
                        head2 = head.split()
                        if "Pt." in head2:
                            pass
                        else:
                            head = line[32]
                            head2 = head.split()
                            
                        #パラメータは何番目ですか？
                        #global No_Pt,No_c2,No_a2,No_mcu,No_e,No_ei,No_D01,No_D02,No_D03,No_D04,No_D05,No_D06,No_D07,No_D08,No_D09,No_D10,No_D11,No_D12,No_D13,No_D14,No_D15,No_D16,No_D17,No_D18,No_D19,No_D20,No_D21,No_D22,No_D23,No_D24
                        No_Pt=head2.index('Pt.')
                        No_c2=head2.index('c2')
                        No_a2=head2.index('a2')
                        No_timeact=head2.index('time-act')
                        #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                        if head.find('mcu')!=-1:
                            No_mcu=head2.index('mcu')
                        else :
                            pass
                        
                        #No_mcu=data2.index('mcu')
                        No_e=head2.index('e')
                        No_ei=head2.index('ei')
                        No_D01=head2.index('D01')
                        No_D24=head2.index('D24')
                    
                    #リストにあるファイルを順に読み込んでいく
                    with open(file_paths[i],"r", encoding="utf-8") as f:
                        #選択ファイルの数値を全て読み込む
                        rdb = np.loadtxt(file_paths[i], comments='#')
                        
                        # データが１次元配列の際に２次元配列に格納
                        if len(rdb.shape) == 1:
                            rdb = np.expand_dims(rdb, axis=0)
                        
                        t_a = rdb[:,No_timeact-1]
                        # time-actが0のデータを検索
                        Ind_t0 = np.where(t_a == 0)
                        # time-actが0のデータを削除
                        rdb = np.delete(rdb, Ind_t0, axis=0)
                        
                        pt = rdb[:,No_Pt-1]
                        c2 = rdb[:,No_c2-1]
                        a2 = rdb[:,No_a2-1]
                        #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                        if head.find('mcu')!=-1:
                            mcu = rdb[:,No_mcu-1]
                        else :
                            mcu = np.zeros((len(pt)))
                        e = rdb[:,No_e-1]
                        ei = rdb[:,No_ei-1]
                        D = rdb[:,No_D01-1:No_D24]
                    
                    #kiとkfの定義
                    ki = np.zeros((2, len(pt)))
                    kf = np.zeros((2, len(pt)*24))
                    #ki2 = np.zeros((2, len(pt)*24))
                    #Qのベクトルとスカラーの定義、あとここに強度の情報を加える。
                    Qvector=np.zeros((6, len(pt)*24))# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
                    sb_Qvector=np.zeros((6, len(pt)*24))# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
                    #検出器の角度
                    d_angle=np.linspace(0, 46, 24)
                    A2 = np.zeros((1, 24))
                    phi=-22;# offset angle of No.1
                    #C2のオフセット
                    C2=c2-w_off

                    #　HODACAで測定した点を計算してくれる
                    #pythonでは行列の数えやfor文は0から始まるので注意すること
                    for n in range(len(pt)):# nは各ファイルのデータの個数に対応
                        
                        #ki_x[0,n] = math.sqrt(ei[n]/2.072)*math.cos(math.radians(-c2[n]))
                        #ki_y[0,n] = -math.sqrt(ei[n]/2.072)*math.sin(math.radians(-c2[n]))
                        ki[0:2,n] = [math.sqrt(ei[n]/2.072)*math.cos(math.radians(-C2[n])),-math.sqrt(ei[n]/2.072)*math.sin(math.radians(-C2[n]))]
                        #A2の絶対値変換
                        A2=d_angle+phi+a2[n];# cover range
                        
                        # ここで対応するバックグラウンドデータを差し引く。
                        # ((sbpt,sbe,sbei,sbc2,sba2,sbD01,sbD02,sbD03,sbD04,sbD05,sbD06,sbD07,sbD08,sbD09,sbD10,sbD11,sbD12,sbD13,sbD14,sbD15,sbD16,sbD17,sbD18,sbD19,sbD20,sbD21,sbD22,sbD23,sbD24))
                        
                        # まずはエネルギートランスファーが一致する部分を抜き出す。補正をする前同士作業なのでOK。
                        # エネルギースキャンステップに依存するがとりあえず指定したモータートレランスの範囲内にあるエネルギー値のものをサーチする。
                        ind_E = (list(zip(*np.where(((e[n]-dE) < sb_Databox0[:,1]) & (sb_Databox0[:,1] < (e[n]+dE))))))
                        # リスト型に出力
                        Ind_E = list(np.ravel(ind_E))
                        if len(Ind_E) > 0:# Ind_Eが空でないとき
                            # 最も近い場所を選ぶコード
                            sb_data_e=sb_Databox0[Ind_E,:]
                            # まずA2が最も近いデータを選び、その中からC2が最も近いデータを選ぶ。
                            sba2 = sb_data_e[:,4]
                            sbc2 = sb_data_e[:,3]
                            
                            nearestA2 = np.argmin(np.abs(sba2 - a2[n]))
                            closest_a2_indices = np.where(sba2 == sba2[nearestA2])[0]  # インデックスのリストを取得

                            # closest_a2_indices に対応する sbc2 の値を取得し、c2[n] に最も近い値を持つインデックスを取得
                            subset_c2 = sbc2[closest_a2_indices]
                            closest_c2_index = np.argmin(np.abs(subset_c2 - c2[n]))

                            # closest_a2_indices かつ closest_c2_index に含まれるインデックスを取得
                            index_BG = closest_a2_indices[closest_c2_index]
                            for m in range(24):# mは検出器の番号に対応
                                #ki2[:,24*n+m] = ki[:,n]
                                # 各検出器の補正として-fit_result[1,m]
                                kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                #kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                sb_Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                #powder用にqも入れておく
                                Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                sb_Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                                Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                sb_Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                # 強度の情報を入れる。ここでバナジウムとmcuの補正をする。12番を基準とする。
                                Qvector[4,24*n+m] = D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                sb_Qvector[4,24*n+m] = np.sum(sb_data_e[index_BG,5+m])/fit_result[0,m]*fit_result[0,11]*N_mcu/np.sum(sb_data_e[index_BG,29])
                                Qvector[5,24*n+m] = math.sqrt(D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                sb_Qvector[5,24*n+m] = math.sqrt(np.sum(sb_data_e[index_BG,5+m]))/fit_result[0,m]*fit_result[0,11]*N_mcu/np.sum(sb_data_e[index_BG,29])
   
                        else:# 対応するエネルギーが無かった場合
                            if sbtype2.get()==0:# Nanが選択されていない
                                for m in range(24):# mは検出器の番号に対応
                                    #ki2[:,24*n+m] = ki[:,n]
                                    # 各検出器の補正として-fit_result[1,m]
                                    kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                    #kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                                    Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                    sb_Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]
                                    #powder用にqも入れておく
                                    Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                    sb_Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                                    # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                                    Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                    sb_Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                                    Qvector[4,24*n+m] = D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                    sb_Qvector[4,24*n+m] = np.nan
                                    Qvector[5,24*n+m] = math.sqrt(D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                                    sb_Qvector[5,24*n+m] = np.nan
                            elif sbtype2.get()==1:# Nanoptionがon
                                pass
                            
                    # 全てのデータを格納するボックスを立ち上げる。Qvectorのデータをどんどん連結していく。最初のファイルだけdataboxをQvectorにする。
                    if i == 0:
                        Databox=Qvector
                        sb_Databox=sb_Qvector
                    #databox.extend(Qvector)
                    if i > 0:
                        Databox=(np.concatenate([Databox, Qvector], 1))
                        sb_Databox=(np.concatenate([sb_Databox, sb_Qvector], 1))

                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var1=var1+1
                    pb["value"] = var1
                    pb.update()          
                
        elif bgm==1:# ユーザーがある程度の範囲でバックグラウンドを測定している場合に対応。
            # プログレスバーの表示
            pb["maximum"] = len(file_paths)+len(sbfile_paths) # プログレスバーの最大値
            pb["value"] = 0
            pb.update()
            
            for i in range(len(file_paths)):
                # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
                with open(file_paths[i],"r", encoding="utf-8") as f:
                    line = f.readlines()
                    head = line[31]
                    head2 = head.split()
                    if "Pt." in head2:
                        pass
                    else:
                        head = line[32]
                        head2 = head.split()
                
                    #パラメータは何番目ですか？
                    #global No_Pt,No_c2,No_a2,No_mcu,No_e,No_ei,No_D01,No_D02,No_D03,No_D04,No_D05,No_D06,No_D07,No_D08,No_D09,No_D10,No_D11,No_D12,No_D13,No_D14,No_D15,No_D16,No_D17,No_D18,No_D19,No_D20,No_D21,No_D22,No_D23,No_D24
                    No_Pt=head2.index('Pt.')
                    No_c2=head2.index('c2')
                    No_a2=head2.index('a2')
                    No_timeact=head2.index('time-act')
                    #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                    if head.find('mcu')!=-1:
                        No_mcu=head2.index('mcu')
                    else :
                        pass
                    
                    #No_mcu=data2.index('mcu')
                    No_e=head2.index('e')
                    No_ei=head2.index('ei')
                    No_D01=head2.index('D01')
                    No_D24=head2.index('D24')
                
                #リストにあるファイルを順に読み込んでいく
                with open(file_paths[i],"r", encoding="utf-8") as f:
                    #選択ファイルの数値を全て読み込む
                    rdb = np.loadtxt(file_paths[i], comments='#')
                    
                    # データが１次元配列の際に２次元配列に格納
                    if len(rdb.shape) == 1:
                        rdb = np.expand_dims(rdb, axis=0)
                    
                    t_a = rdb[:,No_timeact-1]
                    # time-actが0のデータを検索
                    Ind_t0 = np.where(t_a == 0)
                    # time-actが0のデータを削除
                    rdb = np.delete(rdb, Ind_t0, axis=0)
                    
                    pt = rdb[:,No_Pt-1]
                    c2 = rdb[:,No_c2-1]
                    a2 = rdb[:,No_a2-1]
                    #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                    if head.find('mcu')!=-1:
                        mcu = rdb[:,No_mcu-1]
                    else :
                        mcu = np.zeros((len(pt)))
                    e = rdb[:,No_e-1]
                    ei = rdb[:,No_ei-1]
                    D = rdb[:,No_D01-1:No_D24]
                
                #kiとkfの定義
                ki = np.zeros((2, len(pt)))
                kf = np.zeros((2, len(pt)*24))
                #ki2 = np.zeros((2, len(pt)*24))
                #Qのベクトルとスカラーの定義、あとここに強度の情報を加える。
                Qvector=np.zeros((6, len(pt)*24))# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
                #検出器の角度
                d_angle=np.linspace(0, 46, 24)
                A2 = np.zeros((1, 24))
                phi=-22;# offset angle of No.1
                #C2のオフセット
                C2=c2-w_off

                #　HODACAで測定した点を計算してくれる
                #pythonでは行列の数えやfor文は0から始まるので注意すること
                for n in range(len(pt)):# nは各ファイルのデータの個数に対応
                    #ki_x[0,n] = math.sqrt(ei[n]/2.072)*math.cos(math.radians(-c2[n]))
                    #ki_y[0,n] = -math.sqrt(ei[n]/2.072)*math.sin(math.radians(-c2[n]))
                    ki[0:2,n] = [math.sqrt(ei[n]/2.072)*math.cos(math.radians(-C2[n])),-math.sqrt(ei[n]/2.072)*math.sin(math.radians(-C2[n]))]
                    #A2の絶対値変換
                    A2=d_angle+phi+a2[n];# cover range
                    for m in range(24):# mは検出器の番号に対応
                        #ki2[:,24*n+m] = ki[:,n]
                        # 各検出器の補正として-fit_result[1,m]
                        kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                        #kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(A2[m]-C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(A2[m]-C2[n]))]
                        Qvector[0:2,24*n+m] = ki[0:2,n] - kf[0:2,24*n+m]                   
                        #powder用にqも入れておく
                        Qvector[2,24*n+m] = math.sqrt((ki[0,n] - kf[0,24*n+m])**2+(ki[1,n] - kf[1,24*n+m])**2)
                        # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                        Qvector[3,24*n+m] = e[n]-fit_result[1,m]
                        Qvector[4,24*n+m] = D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                        Qvector[5,24*n+m] = math.sqrt(D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/mcu[n]
                    
                # 全てのデータを格納するボックスを立ち上げる。Qvectorのデータをどんどん連結していく。最初のファイルだけdataboxをQvectorにする。
                if i == 0:
                    Databox=Qvector
                #databox.extend(Qvector)
                if i > 0:
                    Databox=(np.concatenate([Databox, Qvector], 1))

                # プログレスバー (確定的)。エネルギー毎にステータスが進む
                var1=var1+1
                #pb.configure(value = var1)
                pb["value"] = var1
                pb.update()
            
            # backgroundのdataを読み込む。   
            # backgroundのdataを読み込む。すべての範囲をスキャンすることを前提にしている。そうしないと場合分けが不可能なので疑似データを作成できない。   
            for i in range(len(sbfile_paths)):
                # データ形式が異なっているファイル(例えば、c2 scanとenergy scanが混じっていても)でも読み取れるように毎回読む仕様に変更する。
                with open(sbfile_paths[i],"r", encoding="utf-8") as f:
                    line = f.readlines()
                    head = line[31]
                    head2 = head.split()
                    if "Pt." in head2:
                        pass
                    else:
                        head = line[32]
                        head2 = head.split()
                
                    #パラメータは何番目ですか？
                    #global SbNo_Pt,SbNo_c2,SbNo_a2,SbNo_mcu,SbNo_e,SbNo_ei,SbNo_D01,SbNo_D02,SbNo_D03,SbNo_D04,SbNo_D05,SbNo_D06,SbNo_D07,SbNo_D08,SbNo_D09,SbNo_D10,SbNo_D11,SbNo_D12,SbNo_D13,SbNo_D14,SbNo_D15,SbNo_D16,SbNo_D17,SbNo_D18,SbNo_D19,SbNo_D20,SbNo_D21,SbNo_D22,SbNo_D23,SbNo_D24
                    sb_No_Pt=head2.index('Pt.')
                    sb_No_c2=head2.index('c2')
                    sb_No_a2=head2.index('a2')
                    sb_No_timeact=head2.index('time-act')
                    #mcuがない場合は読み込まない。もちろんデータも表示されないけどね
                    if head.find('mcu')!=-1:
                        sb_No_mcu=head2.index('mcu')
                    else :
                        pass
                    
                    #SbNo_mcu=data2.index('mcu')
                    sb_No_e=head2.index('e')
                    sb_No_ei=head2.index('ei')
                    sb_No_D01=head2.index('D01')
                    sb_No_D24=head2.index('D24')
                
                #リストにあるファイルを順に読み込んでいく
                with open(sbfile_paths[i],"r", encoding="utf-8") as f:
                    #選択ファイルの数値を全て読み込む
                    sb_rdb = np.loadtxt(sbfile_paths[i], comments='#')
                    
                    # データが１次元配列の際に２次元配列に格納
                    if len(sb_rdb.shape) == 1:
                        sb_rdb = np.expand_dims(sb_rdb, axis=0)
                    
                    t_a = sb_rdb[:,sb_No_timeact-1]
                    # time-actが0のデータを検索
                    Ind_t0 = np.where(t_a == 0)
                    # time-actが0のデータを削除
                    sb_rdb = np.delete(sb_rdb, Ind_t0, axis=0)
                    
                    sb_pt = sb_rdb[:,sb_No_Pt-1]
                    sb_c2 = sb_rdb[:,sb_No_c2-1]
                    sb_a2 = sb_rdb[:,sb_No_a2-1]
                    #mcuがない場合は読み込まない。強制的にmcuが0となり、IntensityはNan値となる。
                    if head.find('mcu')!=-1:
                        sb_mcu = sb_rdb[:,sb_No_mcu-1]
                    else :
                        sb_mcu = np.zeros((len(sb_pt)))
                    sb_e = sb_rdb[:,sb_No_e-1]
                    sb_ei = sb_rdb[:,sb_No_ei-1]
                    sb_D = sb_rdb[:,sb_No_D01-1:sb_No_D24]
                
                #sb_kiとsb_kfの定義
                sb_ki = np.zeros((2, len(sb_pt)))
                sb_kf = np.zeros((2, len(sb_pt)*24))
                #sb_ki2 = np.zeros((2, len(pt)*24))
                #Qのベクトルとスカラーの定義、あとここに強度の情報を加える。
                sb_Qvector=np.zeros((6, len(sb_pt)*24))# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
                #検出器の角度
                d_angle=np.linspace(0, 46, 24)
                sb_A2 = np.zeros((1, 24))
                phi=-22;# offset angle of No.1
                #sb_C2のオフセット
                sb_C2=sb_c2-w_off

                #　HODACAで測定した点を計算してくれる
                #pythonでは行列の数えやfor文は0から始まるので注意すること
                for n in range(len(sb_pt)):# nは各ファイルのデータの個数に対応
                    #sb_ki_x[0,n] = math.sqrt(ei[n]/2.072)*math.cos(math.radians(-c2[n]))
                    #sb_ki_y[0,n] = -math.sqrt(ei[n]/2.072)*math.sin(math.radians(-c2[n]))
                    sb_ki[0:2,n] = [math.sqrt(sb_ei[n]/2.072)*math.cos(math.radians(-sb_C2[n])),-math.sqrt(sb_ei[n]/2.072)*math.sin(math.radians(-sb_C2[n]))]
                    #sb_A2の絶対値変換
                    sb_A2=d_angle+phi+sb_a2[n];# cover range
                    for m in range(24):# mは検出器の番号に対応
                        #sb_ki2[:,24*n+m] = sb_ki[:,n]
                        # 各検出器の補正として-fit_result[1,m]
                        sb_kf[0:2,24*n+m] = [math.sqrt((3.635-fit_result[1,m])/2.072)*math.cos(math.radians(sb_A2[m]-sb_C2[n])),-math.sqrt((3.635-fit_result[1,m])/2.072)*math.sin(math.radians(sb_A2[m]-sb_C2[n]))]
                        #sb_kf[0:2,24*n+m] = [math.sqrt(3.635/2.072)*math.cos(math.radians(sb_A2[m]-sb_C2[n])),-math.sqrt(3.635/2.072)*math.sin(math.radians(sb_A2[m]-sb_C2[n]))]
                        sb_Qvector[0:2,24*n+m] = sb_ki[0:2,n] - sb_kf[0:2,24*n+m]                   
                        #powder用にqも入れておく
                        sb_Qvector[2,24*n+m] = math.sqrt((sb_ki[0,n] - sb_kf[0,24*n+m])**2+(sb_ki[1,n] - sb_kf[1,24*n+m])**2)
                        # エネルギートランスファーの情報を入れる。各検出器の補正として-fit_result[1,m]
                        sb_Qvector[3,24*n+m] = sb_e[n]-fit_result[1,m]
                        sb_Qvector[4,24*n+m] = sb_D[n,m]/fit_result[0,m]*fit_result[0,11]*N_mcu/sb_mcu[n]
                        sb_Qvector[5,24*n+m] = math.sqrt(sb_D[n,m])/fit_result[0,m]*fit_result[0,11]*N_mcu/sb_mcu[n]
                # 全てのデータを格納するボックスを立ち上げる。sb_Qvectorのデータをどんどん連結していく。最初のファイルだけdataboxをsb_Qvectorにする。
                if i == 0:
                    sb_Databox=sb_Qvector
                #databox.extend(sb_Qvector)
                if i > 0:
                    sb_Databox=(np.concatenate([sb_Databox, sb_Qvector], 1))

                # プログレスバー (確定的)。エネルギー毎にステータスが進む
                var1=var1+1
                #pb.configure(value = var1)
                pb["value"] = var1
                pb.update()  

    # 全ての処理が終わった後にmaskした検出器のデータ点を省く
    # maskする検出器の番号を取得する。
    mask_det = [var.get() for var in check_vars]
    # 値が1である要素のインデックスを取得
    n_delete = [i for i, value in enumerate(mask_det) if value == 1]
    # 削除する余りの番号を指定
    remainder_numbers_to_delete = n_delete

    # 対応する列を特定し、削除
    global databox # 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
    columns_to_delete = [i for i in range(len(Databox[0,:])) if i % 24 in remainder_numbers_to_delete]
    databox = np.delete(Databox, columns_to_delete, axis=1)
    
    #バックグラウンドファイルがあった場合
    if len(sbfile_paths)>0:
        global sb_databox # 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
        sb_columns_to_delete = [i for i in range(len(sb_Databox[0,:])) if i % 24 in remainder_numbers_to_delete]
        sb_databox = np.delete(sb_Databox, sb_columns_to_delete, axis=1)
    
    if float(txt9.get())==0:
        ul1 = 0
    elif float(txt9.get())==1:
        ul1 = str(txt_ul.get())
    elif float(txt9.get())==-1:
        ul1 = str('-')+str(txt_ul.get())
    else:
        try:
            number0 = float(txt9.get())
            if number0.is_integer():#整数である
                ul1 = str(int(float(txt9.get())))+str(txt_ul.get())
            else:#整数でない
                ul1 = str(float(txt9.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
            
    if float(txt10.get())==0:
        ul2 = 0
    elif float(txt10.get())==1:
        ul2 = str(txt_ul.get())
    elif float(txt10.get())==-1:
        ul2 = str('-')+str(txt_ul.get())
    else:
        try:
            number1 = float(txt10.get())
            if number1.is_integer():#整数である
                ul2 = str(int(float(txt10.get())))+str(txt_ul.get())
            else:#整数でない
                ul2 = str(float(txt10.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
            
    if float(txt11.get())==0:
        ul3 = 0
    elif float(txt11.get())==1:
        ul3 = str(txt_ul.get())
    elif float(txt11.get())==-1:
        ul3 = str('-')+str(txt_ul.get())
    else:
        try:
            number2 = float(txt11.get())
            if number2.is_integer():#整数である
                ul3 = str(int(float(txt11.get())))+str(txt_ul.get())
            else:#整数でない
                ul3 = str(float(txt11.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
            
    if float(txt12.get())==0:
        vl1 = 0
    elif float(txt12.get())==1:
        vl1 = str(txt_vl.get())
    elif float(txt12.get())==-1:
        vl1 = str('-')+str(txt_vl.get())
    else:
        try:
            number1 = float(txt12.get())
            if number1.is_integer():#整数である
                vl1 = str(int(float(txt12.get())))+str(txt_vl.get())
            else:#整数でない
                vl1 = str(float(txt12.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
            
    if float(txt13.get())==0:
        vl2 = 0
    elif float(txt13.get())==1:
        vl2 = str(txt_vl.get())
    elif float(txt13.get())==-1:
        vl2 = str('-')+str(txt_vl.get())
    else:
        try:
            number2 = float(txt13.get())
            if number2.is_integer():#整数である
                vl2 = str(int(float(txt13.get())))+str(txt_vl.get())
            else:#整数でない
                vl2 = str(float(txt13.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
            
    if float(txt14.get())==0:
        vl3 = 0
    elif float(txt14.get())==1:
        vl3 = str(txt_vl.get())
    elif float(txt14.get())==-1:
        vl3 = str('-')+str(txt_vl.get())
    else:
        try:
            number3 = float(txt14.get())
            if number3.is_integer():#整数である
                vl3 = str(int(float(txt14.get())))+str(txt_vl.get())
            else:#整数でない
                vl3 = str(float(txt14.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
        
    global Ulabel,Vlabel
    Ulabel = (f"({ul1},{ul2},{ul3})")
    Vlabel = (f"({vl1},{vl2},{vl3})")
    
#ファイルの読み込みのボタンの作成:
button6 = ttk.Button(frame3,text="load file(s)",command=loadfile)
button6.grid(row=6, column=4,columnspan=2, sticky="NSEW")
############################################################
# 単結晶と粉末とシミュレーションで切り替えるフレームを作成

# まずは単結晶
# ファイル選択のフレームの作成と設置
frame1 = ttk.Labelframe(root,text= "sample type")
frame1.grid(row=2,column=0,padx=5,sticky="NSEW")
#frame1.grid_propagate(True)

frame1.columnconfigure(0, weight=1)
frame1.rowconfigure(0, weight=1)

# テーマ
style = ttk.Style()

# タブの文字色を変えて見やすくする
# Style.map (TNotebook.Tab)
style.map(
    "example.TNotebook.Tab",
    foreground=[
        ('active', 'red'),
        ('disabled', 'black'),
        ('selected', 'blue'),
    ],
    background=[
        ('active', 'orange'),
        ('disabled', 'black'),
        ('selected', 'lightgreen'),
    ],
)

# Notebookウィジェットの作成
notebook1 = ttk.Notebook(frame1,style="example.TNotebook")

# タブの作成
tab_01 = tk.Frame(notebook1)# 単結晶
tab_02 = tk.Frame(notebook1)# 粉末
tab_03 = tk.Frame(notebook1)# 計算、スキャン範囲とか
tab_04 = tk.Frame(notebook1)# UB行列の計算。ωとか出してくれる。

# notebookにタブを追加
notebook1.add(tab_01, text="single crystal")# 単結晶試料の測定範囲シミュレーション
notebook1.add(tab_02, text="powder")# 粉末試料の測定範囲シミュレーション
notebook1.add(tab_03, text="calculation")# エネルギーに合わせて2thetaを計算
notebook1.add(tab_04, text="UB calculation")# 軸変換を簡単にできるようにした。

tab_01.columnconfigure(0, weight=2)
tab_01.columnconfigure(1, weight=1)
tab_01.columnconfigure(2, weight=1)
tab_01.rowconfigure(0, weight=1)
tab_01.rowconfigure(1, weight=1)

tab_02.columnconfigure(0, weight=2)
tab_02.columnconfigure(1, weight=1)
tab_02.columnconfigure(2, weight=1)
tab_02.rowconfigure(0, weight=1)
tab_02.rowconfigure(1, weight=1)

tab_03.columnconfigure(0, weight=2)
tab_03.columnconfigure(1, weight=1)
tab_03.rowconfigure(0, weight=1)

tab_04.columnconfigure(0, weight=1)
tab_04.columnconfigure(1, weight=1)
tab_04.rowconfigure(0, weight=1)
tab_04.rowconfigure(1, weight=1)
tab_04.rowconfigure(2, weight=1)

# ウィジェットの配置
notebook1.pack(expand=True, fill='both')

# データボックスを作成するボタン周りのフレーム作成。
frame4 = ttk.Labelframe(tab_01, text= "data construction")
frame4.grid(row = 0, column = 0,columnspan=2,sticky="NSEW")
#frame4.grid_propagate(True)

frame4.columnconfigure(0, weight=1)
frame4.columnconfigure(1, weight=1)
frame4.columnconfigure(2, weight=1)
frame4.columnconfigure(3, weight=1)
frame4.columnconfigure(4, weight=1)
frame4.columnconfigure(5, weight=1)
frame4.columnconfigure(6, weight=1)
frame4.columnconfigure(7, weight=1)
frame4.columnconfigure(8, weight=1)
frame4.rowconfigure(0, weight=1)
frame4.rowconfigure(1, weight=1)
frame4.rowconfigure(2, weight=1)

# Q範囲とbin sizeの入力欄
# 範囲に関しては自動で入るようにする
lbl22 = tk.Label(frame4,text='min ℏω',width=6)
lbl22.grid(row=0, column=0,sticky="NSEW")
txt22 = ttk.Entry(frame4,width=6)
txt22.grid(row=1, column=0,sticky="NSEW")

lbl23 = tk.Label(frame4,text='max ℏω',width=6)
lbl23.grid(row=0, column=1,sticky="NSEW")
txt23 = ttk.Entry(frame4,width=6)
txt23.grid(row=1, column=1,sticky="NSEW")

lbl24 = tk.Label(frame4,text='bin ℏω',width=6)
lbl24.grid(row=0, column=2,sticky="NSEW")
txt24 = ttk.Entry(frame4,width=6)
txt24.grid(row=1, column=2,sticky="NSEW")

lbl16 = tk.Label(frame4,textvariable=minU_label,width=6)
lbl16.grid(row=0, column=3,sticky="NSEW")
txt16 = ttk.Entry(frame4,width=6)
txt16.grid(row=1, column=3,sticky="NSEW")

lbl17 = tk.Label(frame4,textvariable=maxU_label,width=6)
lbl17.grid(row=0, column=4,sticky="NSEW")
txt17 = ttk.Entry(frame4,width=6)
txt17.grid(row=1, column=4,sticky="NSEW")

lbl18 = tk.Label(frame4,textvariable=binU_label,width=6)
lbl18.grid(row=0, column=5,sticky="NSEW")
txt18 = ttk.Entry(frame4,width=6)
#txt18.insert(0,'0.05')
txt18.grid(row=1, column=5,sticky="NSEW")

lbl19 = tk.Label(frame4,textvariable=minV_label,width=6)
lbl19.grid(row=0, column=6,sticky="NSEW")
txt19 = ttk.Entry(frame4,width=6)
txt19.grid(row=1, column=6,sticky="NSEW")

lbl20 = tk.Label(frame4,textvariable=maxV_label,width=6)
lbl20.grid(row=0, column=7,sticky="NSEW")
txt20 = ttk.Entry(frame4,width=6)
txt20.grid(row=1, column=7,sticky="NSEW")

lbl21 = tk.Label(frame4,textvariable=binV_label,width=6)
lbl21.grid(row=0, column=8,sticky="NSEW")
txt21 = ttk.Entry(frame4,width=6)
#txt21.insert(0,'0.05')
txt21.grid(row=1, column=8,sticky="NSEW")

pb2 = ttk.Progressbar(frame4,orient='horizontal',mode='determinate')
pb2.grid(row=2, column=6, columnspan=3,sticky="NSEW")

def data_box():
    #UとVのメッシュを用意する
    Umin = float(txt16.get())
    Umax = float(txt17.get())
    Ubin = float(txt18.get())
    Vmin = float(txt19.get())
    Vmax = float(txt20.get())
    Vbin = float(txt21.get())
    
    #energy transferを出す。
    global energylist
    if hw_nan.get()==0:# hw cellに☑が入っていない場合
        if fgt_txt1.get()=='':
            E_T = round(ef_tol+0.005,3)
        else:
            E_T = float(fgt_txt1.get())
        dEfg = 0 # energy方向のsmoothing
        dEbg = 0 # energy方向のsmoothing
        # もとのコード
        energylist=(list(set(databox[3,:])))
        # さらにソートする(元のリストを書き換え)
        energylist.sort()
        # さらにエネルギートランスファーのトレランスを考慮して±E_TmeV以内は同じ数値にする。
        Energylist = [energylist[0]]  # 初めて値を代入

        for i in range(1, (len(energylist)-1)):
            if Energylist[-1] <= energylist[i] and energylist[i] < Energylist[-1] + 2*E_T:
                pass
            else:
                Energylist.append(energylist[i+1])
        # 最後の範囲が記録されないので最後に付け足す。
        if Energylist[-1] < energylist[-1] + 2*E_T:
            pass
        else:
            Energylist.append(energylist[-1])
        # energylistを再構成
        energylist=list(set(Energylist))
        energylist.sort()
    
    if hw_nan.get()==1:# hw cellに☑が入っている場合
        Emin = float(txt22.get())
        Emax = float(txt23.get())
        Ebin = float(txt24.get())
        # 処理速度更新のため、E_Tに統一
        E_T = Ebin/2
        if fgt_txt1.get()=="":
            dEfg=0
        else:
            dEfg = (float(fgt_txt1.get())-Ebin)/2 # energy方向のsmoothing
            
        if bgt_txt1.get()=="":
            dEbg=0
        else:
            dEbg = (float(bgt_txt1.get())-Ebin)/2 # energy方向のsmoothing

        Ne=round((Emax-Emin)/Ebin+1)
        if Ne==1:
            Energylist_cal = [Emin,Emax]
            #ind_e = (list(zip(*np.where(((Energylist_cal[0]) <= databox[3,:]) & (databox[3,:] < (Energylist_cal[-1]))))))
            energylist = [(Energylist_cal[i] + Energylist_cal[i+1])/2]
        else:
            Energylist_cal=np.zeros((Ne))
            energylist=np.zeros((Ne-1))
            for i in range(Ne):
                Energylist_cal[i] = Emin + Ebin * i
            for i in range(Ne-1):
                #ind_e = (list(zip(*np.where(((Energylist_cal[i]) <= databox[3,:]) & (databox[3,:] < (Energylist_cal[i+1]))))))
                energylist[i] = (Energylist_cal[i] + Energylist_cal[i+1])/2

    # smoothing
    if fgt_txt2.get()=="":
        dU = 0
        #fgt_txt2.insert(0,Ubin)
    else:
        dU = (float(fgt_txt2.get())-Ubin)/2
    if fgt_txt3.get()=="":
        dV = 0
        #fgt_txt3.insert(0,Vbin)
    else:
        dV = (float(fgt_txt3.get())-Vbin)/2
    
    # backgroundのsmoothing
    if bgt_txt2.get()=="":
        sb_dU = 0
    else:
        sb_dU = (float(bgt_txt2.get())-Ubin)/2
    if bgt_txt3.get()=="":
        sb_dV = 0
    else:
        sb_dV = (float(bgt_txt3.get())-Vbin)/2
    
    if Umin > Umax:
        return
    if Vmin > Vmax:
        return
    if Ubin < 0:
        return
    if Vbin < 0:
        return
    global nqu,nqv
    nqu=round((Umax-Umin)/Ubin+1)
    nqv=round((Vmax-Vmin)/Vbin+1)
    
    global QU,QV
    QU=np.zeros((nqu))
    QV=np.zeros((nqv))
    for i in range(nqu):
        QU[i] = Umin + Ubin * i
    for i in range(nqv):
        QV[i] = Vmin + Vbin * i
            
    # 強度とエラーバーのセルを用意する。もちろん3次元の行列
    global I,Ierr,sb_I,sb_Ierr
    I = None
    Ierr = None
    sb_I = None
    sb_Ierr = None
    I=np.zeros((len(energylist),nqv-1,nqu-1))
    Ierr=np.zeros((len(energylist),nqv-1,nqu-1))
    sb_I=np.zeros((len(energylist),nqv-1,nqu-1))
    sb_Ierr=np.zeros((len(energylist),nqv-1,nqu-1))
    global QU2,QV2
    QU2=np.zeros((nqu-1))
    QV2=np.zeros((nqv-1))
    
    for nx in range(nqu-1):
        QU2[nx] = (QU[nx]+QU[nx+1])/2
        for ny in range(nqv-1):
            QV2[ny] = (QV[ny]+QV[ny+1])/2
    
    ############
    # cell化するための関数。
    def process_data(box,NV,NU,energylist,QV,QU):
        x = box[3, :]
        y = box[1, :]/NV
        z = box[0, :]/NU

        I_data = box[4, :]
        Ierr_data = box[5, :]

        energylist = np.array(energylist)

        if len(energylist) != 1:
            mid_points = (energylist[:-1] + energylist[1:]) / 2
            x_edges = np.insert(mid_points, 0, energylist[0] - (mid_points[0] - energylist[0]))
            x_edges = np.append(x_edges, energylist[-1] + (energylist[-1] - mid_points[-1]))
        else:
            x_edges = [np.min(box[3,:]), np.max(box[3,:])]

        y_edges = QV
        z_edges = QU

        data = np.vstack([x, y, z]).T

        I_sum, edges, binnumbers = stats.binned_statistic_dd(data, I_data, statistic='sum', bins=[x_edges, y_edges, z_edges])
        Ierr_sum, _, _ = stats.binned_statistic_dd(data, Ierr_data**2, statistic='sum', bins=[x_edges, y_edges, z_edges])
        count, _, _ = stats.binned_statistic_dd(data, None, statistic='count', bins=[x_edges, y_edges, z_edges])

        with np.errstate(divide='ignore', invalid='ignore'):
            bin_I = np.where(count != 0, I_sum / count, np.nan)
            bin_Ierr = np.where(count != 0, np.sqrt(Ierr_sum) / count, np.nan)

        return bin_I, bin_Ierr
    ############
    
    # プログレスバーの表示
    global pb2
    var2 = 0 # プログレスバーの変数
    pb2["maximum"] = len(energylist) # プログレスバーの最大値
    pb2["value"] = 0
    pb2.update()
    if CSX.get()==1:# S(q,w), kf/ki
        ssf1=1
        ssf2=float(sb_txt1.get())
        #バックグラウンドファイルがあった場合。
        if len(sbfile_paths)>0:
            if dEfg==0 and dU==0 and dV==0 and dEbg==0 and sb_dU==0 and sb_dV==0:#smoothing処理をしない場合
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T))))))
                    if not ind_e: # 空行列の時
                        energylist[ne] = energylist[ne]
                    else: # 空行列でない時
                        energylist[ne] = np.mean(databox[3,ind_e])
                        
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                    
                # databoxとsb_databoxの処理
                I, Ierr = process_data(databox, NV1, NU1,energylist,QV,QU)
                I=ssf1*I
                Ierr=ssf1*Ierr
                
                sb_I, sb_Ierr = process_data(sb_databox, NV1, NU1,energylist,QV,QU)
                sb_I=ssf2*sb_I
                sb_Ierr=ssf2*sb_Ierr
                
                I = np.where(np.isfinite(I), I, np.nan)
                Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                sb_I = np.where(np.isfinite(sb_I), sb_I, np.nan)
                sb_Ierr = np.where(np.isfinite(sb_Ierr), sb_Ierr, np.nan)
                
                # nanから数値を引くことはできない。nanを0にする
                I_trans=np.nan_to_num(I, nan=0)-np.nan_to_num(sb_I, nan=0)
                # nanから数値を引くことはできない。nanを0にする
                Ierr_trans=np.sqrt(np.square(np.nan_to_num(Ierr, nan=0))+np.square(np.nan_to_num(sb_Ierr, nan=0)))
                
                if sbtype2.get()==0:
                    # 差し引き後に両方の要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) & np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) & np.isnan(sb_Ierr)] = np.nan
                elif sbtype2.get()==1:
                    # 差し引き後にFGもしくはBGの要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) | np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) | np.isnan(sb_Ierr)] = np.nan
                    
                I=I_trans
                Ierr=Ierr_trans
            
            else:#smoothing処理をする場合
                # メッシュの中にデータを入れていく。
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    Databox_kari=None
                    Ind_e = None
                    sb_Databox_kari=None
                    sb_Ind_e = None
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                    sb_ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEbg) <= sb_databox[3,:]) & (sb_databox[3,:] < (energylist[ne]+E_T+dEbg))))))
                    if not ind_e: # 空行列の時
                        energylist[ne] = energylist[ne]
                    else: # 空行列でない時
                        energylist[ne] = np.mean(databox[3,ind_e])
                    
                    Ind_e = list(np.ravel(ind_e))
                    sb_Ind_e = list(np.ravel(sb_ind_e))
                    Databox_kari = databox[:,Ind_e]
                    sb_Databox_kari = sb_databox[:,sb_Ind_e]
                    for nx in range(nqu-1):
                        for ny in range(nqv-1):
                            #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                            #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                            # 条件を満たすインデックスを取得。
                            ind_x = None
                            Ind_x = None
                            sb_ind_x = None
                            sb_Ind_x = None
                            ind_x = (list(zip(*np.where(( QU[nx]-dU < Databox_kari[0,:]/NU1 ) & (Databox_kari[0,:]/NU1 <= QU[nx+1]+dU) & ( QV[ny]-dV < Databox_kari[1,:]/NV1 ) & ( Databox_kari[1,:]/NV1 <= QV[ny+1]+dV )))))
                            # バックグラウンドは別にsmoothingをかけられる。
                            sb_ind_x = (list(zip(*np.where(( QU[nx]-sb_dU < sb_Databox_kari[0,:]/NU1 ) & (sb_Databox_kari[0,:]/NU1 <= QU[nx+1]+sb_dU) & ( QV[ny]-sb_dV < sb_Databox_kari[1,:]/NV1 ) & ( sb_Databox_kari[1,:]/NV1 <= QV[ny+1]+sb_dV )))))
                            # ind_xが何もない場合はnan値として出力されるから良し
                            # ind_xを1次元化して0の要素を省く。そしてリスト型にして取り出す
                            Ind_x = list(np.ravel(ind_x)[::1])
                            sb_Ind_x = list(np.ravel(sb_ind_x)[::1])
                            # ind_xが[(49, 0)]のように出力されるためInd_xで1次元化する。すると49,0...という１次元配列になるため、2つおきの数値[49]を取ってくるように[::1]を追加

                            # runtimeエラーが出ないように工夫
                            I[ne,ny,nx]=(np.nansum(Databox_kari[4,:][Ind_x]))/len(Ind_x)*ssf1
                            Ierr[ne,ny,nx]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_x],Databox_kari[5,:][Ind_x])))**(1/2))/len(Ind_x)*ssf1
                            sb_I[ne,ny,nx]=(np.nansum(sb_Databox_kari[4,:][sb_Ind_x]))/len(sb_Ind_x)*ssf2
                            sb_Ierr[ne,ny,nx]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_x],sb_Databox_kari[5,:][sb_Ind_x])))**(1/2))/len(sb_Ind_x)*ssf2
                            
                    I = np.where(np.isfinite(I), I, np.nan)
                    Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                    sb_I = np.where(np.isfinite(sb_I), sb_I, np.nan)
                    sb_Ierr = np.where(np.isfinite(sb_Ierr), sb_Ierr, np.nan)
                
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                # nanから数値を引くことはできない。nanを0にする
                I_trans=np.nan_to_num(I, nan=0)-np.nan_to_num(sb_I, nan=0)
                # nanから数値を引くことはできない。nanを0にする
                Ierr_trans=np.sqrt(np.square(np.nan_to_num(Ierr, nan=0))+np.square(np.nan_to_num(sb_Ierr, nan=0)))
                
                if sbtype2.get()==0:
                    # 差し引き後に両方の要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) & np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) & np.isnan(sb_Ierr)] = np.nan
                elif sbtype2.get()==1:
                    # 差し引き後にFGもしくはBGの要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) | np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) | np.isnan(sb_Ierr)] = np.nan
                    
                I=I_trans
                Ierr=Ierr_trans
                
        else:# background fileがない場合
            if dEfg==0 and dU==0 and dV==0:#smoothing処理をしない場合
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T))))))
                    if not ind_e: # 空行列の時
                        energylist[ne] = energylist[ne]
                    else: # 空行列でない時
                        energylist[ne] = np.mean(databox[3,ind_e])
                        
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                    
                # databoxとsb_databoxの処理
                I, Ierr = process_data(databox, NV1, NU1,energylist,QV,QU)
                I=ssf1*I
                Ierr=ssf1*Ierr
                
                I = np.where(np.isfinite(I), I, np.nan)
                Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                
            # smoothing処理をする場合
            else:
                # メッシュの中にデータを入れていく。
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    Databox_kari=None
                    Ind_e = None
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                    if not ind_e:
                        energylist[ne] = energylist[ne]
                    else:
                        energylist[ne] = np.mean(databox[3,ind_e])
                    
                    Ind_e = list(np.ravel(ind_e))
                    Databox_kari = databox[:,Ind_e]
                    for nx in range(nqu-1):
                        for ny in range(nqv-1):
                            #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                            #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                            # 条件を満たすインデックスを取得。
                            ind_x = None
                            Ind_x = None
                            ind_x = (list(zip(*np.where(( QU[nx]-dU < Databox_kari[0,:]/NU1 ) & (Databox_kari[0,:]/NU1 <= QU[nx+1]+dU) & ( QV[ny]-dV < Databox_kari[1,:]/NV1 ) & ( Databox_kari[1,:]/NV1 <= QV[ny+1]+dV )))))
                            # ind_xが何もない場合はnan値として出力されるから良し
                            # ind_xを1次元化して0の要素を省く。そしてリスト型にして取り出す
                            Ind_x = list(np.ravel(ind_x)[::1])
                            # ind_xが[(49, 0)]のように出力されるためInd_xで1次元化する。すると49,0...という１次元配列になるため、2つおきの数値[49]を取ってくるように[::1]を追加

                            # runtimeエラーが出ないように工夫
                            I[ne,ny,nx]=(np.nansum(Databox_kari[4,:][Ind_x]))/len(Ind_x)*ssf1
                            Ierr[ne,ny,nx]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_x],Databox_kari[5,:][Ind_x])))**(1/2))/len(Ind_x)*ssf1
                            #sb_I[ne,ny,nx]=(np.nansum(sb_Databox_kari[4,:][sb_Ind_x]))/len(sb_Ind_x)*ssf2
                            #sb_Ierr[ne,ny,nx]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_x],sb_Databox_kari[5,:][sb_Ind_x])))**(1/2))/len(sb_Ind_x)*ssf2
                            
                    #I = np.where(np.isfinite(I), I, np.nan)
                    #Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                    #sb_I = np.where(np.isfinite(sb_I), sb_I, np.nan)
                    #sb_Ierr = np.where(np.isfinite(sb_Ierr), sb_Ierr, np.nan)
                                
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                    
    elif CSX.get()==2:# χ(q,w), kf/ki
        if len(sbfile_paths)>0:#バックグラウンドファイルがあった場合。
            # smoothing処理をしない場合
            if dEfg==0 and dU==0 and dV==0 and dEbg==0 and sb_dU==0 and sb_dV==0:#smoothing処理をしない場合
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T))))))
                    if not ind_e: # 空行列の時
                        energylist[ne] = energylist[ne]
                    else: # 空行列でない時
                        energylist[ne] = np.mean(databox[3,ind_e])
                
                # databoxとsb_databoxの処理
                I, Ierr = process_data(databox, NV1, NU1,energylist,QV,QU)
                sb_I, sb_Ierr = process_data(sb_databox, NV1, NU1,energylist,QV,QU)
                
                for ne in range(len(energylist)):
                    if energylist[ne]>=0:
                        ssf1=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt2.get())))
                        I[ne,:,:]=ssf1*I[ne,:,:]
                        Ierr[ne,:,:]=ssf1*Ierr[ne,:,:]
                        ssf2=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt3.get())))
                        sb_I[ne,:,:]=ssf2*sb_I[ne,:,:]
                        sb_Ierr[ne,:,:]=ssf2*sb_Ierr[ne,:,:]
                    else:
                        ssf1=(math.exp(11.60497*-(energylist[ne])/float(sb_txt2.get()))-1)
                        I[ne,:,:]=ssf1*I[ne,:,:]
                        Ierr[ne,:,:]=ssf1*Ierr[ne,:,:]
                        ssf2=(math.exp(11.60497*-(energylist[ne])/float(sb_txt3.get()))-1)
                        sb_I[ne,:,:]=ssf2*sb_I[ne,:,:]
                        sb_Ierr[ne,:,:]=ssf2*sb_Ierr[ne,:,:]
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                    
                I = np.where(np.isfinite(I), I, np.nan)
                Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                sb_I = np.where(np.isfinite(sb_I), sb_I, np.nan)
                sb_Ierr = np.where(np.isfinite(sb_Ierr), sb_Ierr, np.nan)
                
                # nanから数値を引くことはできない。nanを0にする
                I_trans=np.nan_to_num(I, nan=0)-np.nan_to_num(sb_I, nan=0)
                # nanから数値を引くことはできない。nanを0にする
                Ierr_trans=np.sqrt(np.square(np.nan_to_num(Ierr, nan=0))+np.square(np.nan_to_num(sb_Ierr, nan=0)))
                
                if sbtype2.get()==0:
                    # 差し引き後に両方の要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) & np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) & np.isnan(sb_Ierr)] = np.nan
                elif sbtype2.get()==1:
                    # 差し引き後にFGもしくはBGの要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) | np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) | np.isnan(sb_Ierr)] = np.nan
                    
                I=I_trans
                Ierr=Ierr_trans
                
            else:# smoothing処理を行う場合
                # メッシュの中にデータを入れていく。
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    Databox_kari=None
                    Ind_e = None
                    sb_Databox_kari=None
                    sb_Ind_e = None
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                    sb_ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEbg) <= sb_databox[3,:]) & (sb_databox[3,:] < (energylist[ne]+E_T+dEbg))))))
                    if not ind_e:
                        energylist[ne] = energylist[ne]
                    else:
                        energylist[ne] = np.mean(databox[3,ind_e])
                    if energylist[ne]>=0:
                        ssf1=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt2.get())))
                        ssf2=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt3.get())))
                    else:
                        ssf1=(math.exp(11.60497*-(energylist[ne])/float(sb_txt2.get()))-1)
                        ssf2=(math.exp(11.60497*-(energylist[ne])/float(sb_txt3.get()))-1)
                    Ind_e = list(np.ravel(ind_e))
                    sb_Ind_e = list(np.ravel(sb_ind_e))
                    Databox_kari = databox[:,Ind_e]
                    sb_Databox_kari = sb_databox[:,sb_Ind_e]
                    for nx in range(nqu-1):
                        for ny in range(nqv-1):
                            #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                            #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                            # 条件を満たすインデックスを取得。
                            ind_x = None
                            Ind_x = None
                            sb_ind_x = None
                            sb_Ind_x = None
                            ind_x = (list(zip(*np.where(( QU[nx]-dU < Databox_kari[0,:]/NU1 ) & (Databox_kari[0,:]/NU1 <= QU[nx+1]+dU) & ( QV[ny]-dV < Databox_kari[1,:]/NV1 ) & ( Databox_kari[1,:]/NV1 <= QV[ny+1]+dV )))))
                            # バックグラウンドは別にsmoothingをかけられる。
                            sb_ind_x = (list(zip(*np.where(( QU[nx]-sb_dU < sb_Databox_kari[0,:]/NU1 ) & (sb_Databox_kari[0,:]/NU1 <= QU[nx+1]+sb_dU) & ( QV[ny]-sb_dV < sb_Databox_kari[1,:]/NV1 ) & ( sb_Databox_kari[1,:]/NV1 <= QV[ny+1]+sb_dV )))))
                            # ind_xが何もない場合はnan値として出力されるから良し
                            # ind_xを1次元化して0の要素を省く。そしてリスト型にして取り出す
                            Ind_x = list(np.ravel(ind_x)[::1])
                            sb_Ind_x = list(np.ravel(sb_ind_x)[::1])
                            # ind_xが[(49, 0)]のように出力されるためInd_xで1次元化する。すると49,0...という１次元配列になるため、2つおきの数値[49]を取ってくるように[::1]を追加
                            # runtimeエラーが出ないように工夫
                            I[ne,ny,nx]=(np.nansum(Databox_kari[4,:][Ind_x]))/len(Ind_x)*ssf1
                            Ierr[ne,ny,nx]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_x],Databox_kari[5,:][Ind_x])))**(1/2))/len(Ind_x)*ssf1
                            sb_I[ne,ny,nx]=(np.nansum(sb_Databox_kari[4,:][sb_Ind_x]))/len(sb_Ind_x)*ssf2
                            sb_Ierr[ne,ny,nx]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_x],sb_Databox_kari[5,:][sb_Ind_x])))**(1/2))/len(sb_Ind_x)*ssf2
                            
                    I = np.where(np.isfinite(I), I, np.nan)
                    Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                    sb_I = np.where(np.isfinite(sb_I), sb_I, np.nan)
                    sb_Ierr = np.where(np.isfinite(sb_Ierr), sb_Ierr, np.nan)
                                
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                # nanから数値を引くことはできない。nanを0にする
                I_trans=np.nan_to_num(I, nan=0)-np.nan_to_num(sb_I, nan=0)
                # nanから数値を引くことはできない。nanを0にする
                Ierr_trans=np.sqrt(np.square(np.nan_to_num(Ierr, nan=0))+np.square(np.nan_to_num(sb_Ierr, nan=0)))
                
                if sbtype2.get()==0:
                    # 差し引き後に両方の要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) & np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) & np.isnan(sb_Ierr)] = np.nan
                elif sbtype2.get()==1:
                    # 差し引き後にFGもしくはBGの要素でnan値であった部分をnan値にする。
                    I_trans[np.isnan(I) | np.isnan(sb_I)] = np.nan
                    Ierr_trans[np.isnan(Ierr) | np.isnan(sb_Ierr)] = np.nan
                    
                I=I_trans
                Ierr=Ierr_trans
                
        else:# background fileがない場合
            if dEfg==0 and dU==0 and dV==0:#smoothing処理をしない場合
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T))))))
                    if not ind_e: # 空行列の時
                        energylist[ne] = energylist[ne]
                    else: # 空行列でない時
                        energylist[ne] = np.mean(databox[3,ind_e])
                        
                # databoxとsb_databoxの処理
                I, Ierr = process_data(databox, NV1, NU1,energylist,QV,QU)
                
                for ne in range(len(energylist)):    
                    if energylist[ne]>=0:
                        ssf1=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt2.get())))
                        I[ne,:,:]=ssf1*I[ne,:,:]
                        Ierr[ne,:,:]=ssf1*Ierr[ne,:,:]
                    else:
                        ssf1=(math.exp(11.60497*-(energylist[ne])/float(sb_txt2.get()))-1)
                        I[ne,:,:]=ssf1*I[ne,:,:]
                        Ierr[ne,:,:]=ssf1*Ierr[ne,:,:]
                        
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()
                    
                I = np.where(np.isfinite(I), I, np.nan)
                Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
            
            else:#smoothing処理をする場合
                # メッシュの中にデータを入れていく。
                for ne in range(len(energylist)):
                    # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す。このときエネルギートランスファートレランスを考慮する。
                    Databox_kari=None
                    Ind_e = None
                    # Ind_e = (list(zip(*np.where(databox[3,:] == energylist[ne]))))
                    ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                    if not ind_e:
                        energylist[ne] = energylist[ne]
                    else:
                        energylist[ne] = np.mean(databox[3,ind_e])
                    if energylist[ne]>=0:
                        ssf1=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt2.get())))
                        ssf2=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt3.get())))
                    else:
                        ssf1=(math.exp(11.60497*-(energylist[ne])/float(sb_txt2.get()))-1)
                        ssf2=(math.exp(11.60497*-(energylist[ne])/float(sb_txt3.get()))-1)
                    Ind_e = list(np.ravel(ind_e))
                    Databox_kari = databox[:,Ind_e]
                    for nx in range(nqu-1):
                        for ny in range(nqv-1):
                            #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                            #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                            # 条件を満たすインデックスを取得。
                            ind_x = None
                            Ind_x = None
                            ind_x = (list(zip(*np.where(( QU[nx]-dU < Databox_kari[0,:]/NU1 ) & (Databox_kari[0,:]/NU1 <= QU[nx+1]+dU) & ( QV[ny]-dV < Databox_kari[1,:]/NV1 ) & ( Databox_kari[1,:]/NV1 <= QV[ny+1]+dV )))))
                            # ind_xが何もない場合はnan値として出力されるから良し
                            # ind_xを1次元化して0の要素を省く。そしてリスト型にして取り出す
                            Ind_x = list(np.ravel(ind_x)[::1])
                            # ind_xが[(49, 0)]のように出力されるためInd_xで1次元化する。すると49,0...という１次元配列になるため、2つおきの数値[49]を取ってくるように[::1]を追加

                            # runtimeエラーが出ないように工夫
                            I[ne,ny,nx]=(np.nansum(Databox_kari[4,:][Ind_x]))/len(Ind_x)*ssf1
                            Ierr[ne,ny,nx]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_x],Databox_kari[5,:][Ind_x])))**(1/2))/len(Ind_x)*ssf1
                            #sb_I[ne,ny,nx]=(np.nansum(sb_Databox_kari[4,:][sb_Ind_x]))/len(sb_Ind_x)*ssf2
                            #sb_Ierr[ne,ny,nx]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_x],sb_Databox_kari[5,:][sb_Ind_x])))**(1/2))/len(sb_Ind_x)*ssf2
                            
                    #I = np.where(np.isfinite(I), I, np.nan)
                    #Ierr = np.where(np.isfinite(Ierr), Ierr, np.nan)
                    #sb_I = np.where(np.isfinite(sb_I), sb_I, np.nan)
                    #sb_Ierr = np.where(np.isfinite(sb_Ierr), sb_Ierr, np.nan)
                                
                    # プログレスバー (確定的)。エネルギー毎にステータスが進む
                    var2=var2+1
                    pb2["value"] = var2
                    pb2.update()

# 自動でボックスのサイズを決めてくれるボタンの動作定義
def set_range():
    # 小数点第３位を四捨五入。float(format(a, '.2f'))±0.01
    txt22.delete(0,tk.END)
    txt23.delete(0,tk.END)
    txt24.delete(0,tk.END)
        
    txt22.insert(0, round(np.nanmin(databox[3, :]), 3))
    txt23.insert(0, round(np.nanmax(databox[3, :]), 3))
    
    E_T = round(ef_tol+0.005,3)
    # もとのコード
    energylist=(list(set(databox[3,:])))
    # さらにソートする(元のリストを書き換え)
    energylist.sort()
    # さらにエネルギートランスファーのトレランスを考慮して±E_TmeV以内は同じ数値にする。
    Energylist = [energylist[0]]  # 初めて値を代入

    for i in range(1, (len(energylist)-1)):
        if Energylist[-1] <= energylist[i] and energylist[i] < Energylist[-1] + 2*E_T:
            pass
        else:
            Energylist.append(energylist[i+1])
    # 最後の範囲が記録されないので最後に付け足す。
    if Energylist[-1] == energylist[-1]:
        pass
    else:
        Energylist.append(energylist[-1])
    # energylistを再構成
    energylist=list(set(Energylist))
    energylist.sort()
    
    # 差分の平均値を計算
    estep = np.nanmean(np.diff(energylist))
    
    txt24.insert(0, round(estep+0.005, 3))
    
    txt16.delete(0,tk.END)
    txt17.delete(0,tk.END)
    txt19.delete(0,tk.END)
    txt20.delete(0,tk.END)
    if 'sb_databox' in globals():
        if np.nanmin(databox[0, :])<=np.nanmin(sb_databox[0, :]):
            txt16.insert(0, round(np.nanmin(databox[0, :] / NU1) - 0.01, 2))
        else:
            txt16.insert(0, round(np.nanmin(sb_databox[0, :] / NU1) - 0.01, 2))
        if np.nanmax(databox[0, :])>=np.nanmax(sb_databox[0, :]):
            txt17.insert(0, round(np.nanmax(databox[0, :] / NU1) + 0.01, 2))
        else:
            txt17.insert(0, round(np.nanmax(sb_databox[0, :] / NU1) + 0.01, 2))
        if np.nanmin(databox[1, :])<=np.nanmin(sb_databox[1, :]):
            txt19.insert(0, round(np.nanmin(databox[1, :] / NV1) - 0.01, 2))
        else:
            txt19.insert(0, round(np.nanmin(sb_databox[1, :] / NV1) - 0.01, 2))
        if np.nanmax(databox[1, :])>=np.nanmax(sb_databox[1, :]):
            txt20.insert(0, round(np.nanmax(databox[1, :] / NV1) + 0.01, 2))
        else:
            txt20.insert(0, round(np.nanmax(sb_databox[1, :] / NV1) + 0.01, 2))
    else:
        txt16.insert(0, round(np.nanmin(databox[0, :] / NU1) - 0.01, 2))
        txt17.insert(0, round(np.nanmax(databox[0, :] / NU1) + 0.01, 2))
        txt19.insert(0, round(np.nanmin(databox[1, :] / NV1) - 0.01, 2))
        txt20.insert(0, round(np.nanmax(databox[1, :] / NV1) + 0.01, 2))
    # hwの最大値からq間隔の最大値を求める。
    ki_norm=((3.635+11)/2.072)**(1/2)
    kf_norm=((3.635)/2.072)**(1/2)
    q_1=(ki_norm**2+kf_norm**2-2*ki_norm*kf_norm*math.cos(math.radians(56)))**(1/2)
    q_2=(ki_norm**2+kf_norm**2-2*ki_norm*kf_norm*math.cos(math.radians(54)))**(1/2)
    dqx=format(float(abs(q_2-q_1)/NU1), '.2f')
    txt18.delete(0,tk.END)
    txt18.insert(0,dqx)
    dqy=format(float(abs(q_2-q_1)/NV1), '.2f')
    txt21.delete(0,tk.END)
    txt21.insert(0,dqy)
    # defaultでδU,δVを自動入力する。正直個人的にはいらないと思ってる。
    """
    if 'sb_databox' in globals():
        bgt_txt2.delete(0,tk.END)
        bgt_txt2.insert(0,dqx)
        bgt_txt3.delete(0,tk.END)
        bgt_txt3.insert(0,dqy)
    """
# hwに関するoptionボタン
# チェック有無変数
hw_nan = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
hw_nan.set(0)

hw_nan_op = tk.Checkbutton(frame4, variable=hw_nan, text='ℏω cell',command=update_labels)
hw_nan_op.grid(row=2, column=0, columnspan=2,sticky="NSEW")

def toggle_entry_hwcell():
    if hw_nan.get()==0:
        txt22.config(state=tk.DISABLED) # min hw 
        txt23.config(state=tk.DISABLED) # max hw
        txt24.config(state=tk.DISABLED) # bin hw
        #fgt_txt1.config(state=tk.NORMAL) # tolerance ±δhw (FG)
        #bgt_txt1.config(state=tk.NORMAL) # tolerance ±δhw (BG)
    elif  hw_nan.get()==1:#ユーザーがhw cellを指定したい場合
        txt22.config(state=tk.NORMAL) # min hw 
        txt23.config(state=tk.NORMAL) # max hw
        txt24.config(state=tk.NORMAL) # bin hw
        #fgt_txt1.config(state=tk.DISABLED) # tolerance ±δhw (FG)
        #bgt_txt1.config(state=tk.DISABLED) # tolerance ±δhw (BG)

# プログラム開始時に一度だけtoggle_entryを呼び出す
toggle_entry_hwcell()

# Radiobutton選択状態の変更時にtoggle_entry関数を呼び出す
hw_nan.trace('w', lambda *args: toggle_entry_hwcell())
    
# 自動でボックスのサイズを決めてくれるボタン
button7_0 = ttk.Button(frame4,text="auto bin",command=set_range,width=12)
button7_0.grid(row=2, column=2, columnspan=2,sticky="NSEW")

#指定した範囲とbinサイズの箱にデータを詰めるボタン
button7 = ttk.Button(frame4,text="re-bin",command=data_box,width=12)
button7.grid(row=2, column=4, columnspan=2,sticky="NSEW")

###########################################################################

# graph opetionを表示するボタン周りのフレーム作成。
frame6 = ttk.Labelframe(tab_01, text= "option")
frame6.grid(row = 0, column = 2, sticky="NSEW")
#frame6.grid_propagate(True)

frame6.columnconfigure(0, weight=1)
frame6.rowconfigure(0, weight=1)
frame6.rowconfigure(1, weight=1)
frame6.rowconfigure(2, weight=1)

# チェック有無変数
axistype = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
axistype.set(0)

# ラジオボタン作成
#rdolbl = tk.Label(frameGL, text='axis type',width=7)
#rdolbl.grid(row=0,column=6,columnspan=2)

#at=axistype.get()で線形スケールかログスケールを選択
rdo_at1 = tk.Radiobutton(frame6, value=0, variable=axistype, text='linear')#もともとframeGL
rdo_at1.grid(row=0,column=0, sticky="NSEW")

rdo_at2 = tk.Radiobutton(frame6, value=1, variable=axistype, text='log')#もともとframeGL
rdo_at2.grid(row=1,column=0, sticky="NSEW")

# チェック有無変数
gridtype = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
gridtype.set(1)

chk_gt = tk.Checkbutton(frame6, variable=gridtype, text='grid')
chk_gt.grid(row=2, column=0, sticky="NSEW")

# 3D,2D,1Dを表示するボタン周りのフレーム作成。
frame5 = ttk.Labelframe(tab_01, text= "create figure")
frame5.grid(row = 1, column = 0,sticky="NSEW")
#frame5.grid_propagate(True)

# graph opetionを表示するボタン周りのフレーム作成。
frameGSs = ttk.Labelframe(tab_01, text= "graph scale")
frameGSs.grid(row = 1, column = 1,columnspan=2,sticky="NSEW")
#frameGSs.grid_propagate(True)

frameGSs.columnconfigure(0, weight=1)
frameGSs.columnconfigure(1, weight=1)
frameGSs.columnconfigure(2, weight=1)
frameGSs.rowconfigure(0, weight=1)
frameGSs.rowconfigure(1, weight=1)
frameGSs.rowconfigure(2, weight=1)
frameGSs.rowconfigure(3, weight=1)
frameGSs.rowconfigure(4, weight=1)
frameGSs.rowconfigure(5, weight=1)

# graph scale
graph_scale_lbl0 = tk.Label(frameGSs,text='min',width=6)
graph_scale_lbl0.grid(row=0, column=1,sticky="NSEW")
graph_scale_lbl1 = tk.Label(frameGSs,text='max',width=6)
graph_scale_lbl1.grid(row=0, column=2,sticky="NSEW")

scale_s_Emin_lbl = tk.Label(frameGSs,text='ℏω',width=6)
scale_s_Emin_lbl.grid(row=1, column=0,sticky="NSEW")
scale_s_Emin_txt = ttk.Entry(frameGSs,width=6)
scale_s_Emin_txt.grid(row=1, column=1,sticky="NSEW")
scale_s_Emax_txt = ttk.Entry(frameGSs,width=6)
scale_s_Emax_txt.grid(row=1, column=2,sticky="NSEW")

scale_s_Umin_lbl = tk.Label(frameGSs,width=6,textvariable=U_lavel)
scale_s_Umin_lbl.grid(row=2, column=0,sticky="NSEW")
scale_s_Umin_txt = ttk.Entry(frameGSs,width=6)
scale_s_Umin_txt.grid(row=2, column=1,sticky="NSEW")
scale_s_Umax_txt = ttk.Entry(frameGSs,width=6)
scale_s_Umax_txt.grid(row=2, column=2,sticky="NSEW")

scale_s_Vmin_lbl = tk.Label(frameGSs,width=6,textvariable=V_lavel)
scale_s_Vmin_lbl.grid(row=3, column=0,sticky="NSEW")
scale_s_Vmin_txt = ttk.Entry(frameGSs,width=6)
scale_s_Vmin_txt.grid(row=3, column=1,sticky="NSEW")
scale_s_Vmax_txt = ttk.Entry(frameGSs,width=6)
scale_s_Vmax_txt.grid(row=3, column=2,sticky="NSEW")

scale_s_Imin_lbl = tk.Label(frameGSs,text='I',width=6)
scale_s_Imin_lbl.grid(row=4, column=0,sticky="NSEW")
scale_s_Imin_txt = ttk.Entry(frameGSs,width=6)
scale_s_Imin_txt.grid(row=4, column=1,sticky="NSEW")
scale_s_Imax_txt = ttk.Entry(frameGSs,width=6)
scale_s_Imax_txt.grid(row=4, column=2,sticky="NSEW")

def gs_clear():
    scale_s_Emin_txt.delete(0,tk.END)
    scale_s_Emax_txt.delete(0,tk.END)
    scale_s_Umin_txt.delete(0,tk.END)
    scale_s_Umax_txt.delete(0,tk.END)
    scale_s_Vmin_txt.delete(0,tk.END)
    scale_s_Vmax_txt.delete(0,tk.END)
    scale_s_Imin_txt.delete(0,tk.END)
    scale_s_Imax_txt.delete(0,tk.END)

gs_clear = ttk.Button(frameGSs,text="clear",command=gs_clear,width=6)
gs_clear.grid(row=0, column=0,sticky="NSEW")

def gs_auto(): 
    scale_s_Emin_txt.delete(0,tk.END)
    scale_s_Emax_txt.delete(0,tk.END)
    if round(energylist[0], 2) == round(energylist[-1], 2):
        scale_s_Emin_txt.insert(0, round(energylist[0]-(ef_tol), 2))
        scale_s_Emax_txt.insert(0, round(energylist[-1]+(ef_tol), 2))
    else:
        scale_s_Emin_txt.insert(0, round(energylist[0], 2))
        scale_s_Emax_txt.insert(0, round(energylist[-1], 2))
    scale_s_Umin_txt.delete(0,tk.END)
    scale_s_Umin_txt.insert(0, round(np.min(QU),2))
    scale_s_Umax_txt.delete(0,tk.END)
    scale_s_Umax_txt.insert(0, round(np.max(QU),2))
    scale_s_Vmin_txt.delete(0,tk.END)
    scale_s_Vmin_txt.insert(0, round(np.min(QV),2))
    scale_s_Vmax_txt.delete(0,tk.END)
    scale_s_Vmax_txt.insert(0, round(np.max(QV),2))
    scale_s_Imin_txt.delete(0,tk.END)
    scale_s_Imax_txt.delete(0,tk.END)
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if np.nanmean(I) >= 0:
        scale_s_Imax_txt.insert(0,round(np.nanmean(I),1))
        scale_s_Imin_txt.insert(0,0)
    elif np.nanmean(I) < 0:
        scale_s_Imin_txt.insert(0,round(np.nanmean(I),1))
        scale_s_Imax_txt.insert(0,np.abs(round(np.nanmean(I),1)))

gs_auto = ttk.Button(frameGSs,text="auto scale",command=gs_auto)
gs_auto.grid(row=5, column=0, columnspan=3,sticky="NSEW")
#################

# テーマ
style = ttk.Style()

# タブの文字色を変えて見やすくする
# Style.map (TNotebook.Tab)
style.map(
    "example.TNotebook.Tab",
    foreground=[
        ('active', 'red'),
        ('disabled', 'black'),
        ('selected', 'blue'),
    ],
    background=[
        ('active', 'orange'),
        ('disabled', 'black'),
        ('selected', 'lightgreen'),
    ],
)

# Notebookウィジェットの作成
notebook = ttk.Notebook(frame5,style="example.TNotebook")

# タブの作成
tab_3d = tk.Frame(notebook)
tab_2d = tk.Frame(notebook)
tab_1d = tk.Frame(notebook)
# 斜め方向のスライス及び１次元カットを行うモード。ここではテストモードとして独立したタブを作成。
tab_slice = tk.Frame(notebook)
tab_4 = tk.Frame(notebook)

# notebookにタブを追加
notebook.add(tab_3d, text="3D view")# 3D mapの表示
notebook.add(tab_2d, text="2D view")# 2D mapの表示
notebook.add(tab_1d, text="1D view")# 1D cutの作成
notebook.add(tab_slice, text="Advanced")# 斜め方向のスライス
notebook.add(tab_4, text="TAS mode")# 各検出器のデータを見る。これだけtime-actに対応するため、個別に対応

tab_3d.columnconfigure(0, weight=1)
tab_3d.columnconfigure(1, weight=1)
tab_3d.columnconfigure(2, weight=1)
tab_3d.rowconfigure(0, weight=1)
tab_3d.rowconfigure(1, weight=1)
tab_3d.rowconfigure(2, weight=1)
tab_3d.rowconfigure(3, weight=1)

tab_2d.columnconfigure(0, weight=1)
tab_2d.columnconfigure(1, weight=1)
tab_2d.columnconfigure(2, weight=1)
tab_2d.columnconfigure(3, weight=1)
tab_2d.columnconfigure(4, weight=1)
tab_2d.columnconfigure(5, weight=1)
tab_2d.rowconfigure(0, weight=1)
tab_2d.rowconfigure(1, weight=1)
tab_2d.rowconfigure(2, weight=1)
tab_2d.rowconfigure(3, weight=1)

tab_1d.columnconfigure(0, weight=1)
tab_1d.columnconfigure(1, weight=1)
tab_1d.columnconfigure(2, weight=1)
tab_1d.columnconfigure(3, weight=1)
tab_1d.columnconfigure(4, weight=1)
tab_1d.columnconfigure(5, weight=1)
tab_1d.rowconfigure(0, weight=1)
tab_1d.rowconfigure(1, weight=1)
tab_1d.rowconfigure(2, weight=1)
tab_1d.rowconfigure(3, weight=1)

tab_slice.columnconfigure(0, weight=1)
tab_slice.columnconfigure(1, weight=1)
tab_slice.columnconfigure(2, weight=1)
tab_slice.columnconfigure(3, weight=1)
tab_slice.columnconfigure(4, weight=1)
tab_slice.columnconfigure(5, weight=1)
tab_slice.columnconfigure(6, weight=1)
tab_slice.rowconfigure(0, weight=1)
tab_slice.rowconfigure(1, weight=1)
tab_slice.rowconfigure(2, weight=1)
tab_slice.rowconfigure(3, weight=1)

tab_4.columnconfigure(0, weight=1)
tab_4.columnconfigure(1, weight=1)
tab_4.columnconfigure(2, weight=1)
tab_4.columnconfigure(3, weight=1)
tab_4.rowconfigure(0, weight=1)
tab_4.rowconfigure(1, weight=1)
tab_4.rowconfigure(2, weight=1)
tab_4.rowconfigure(3, weight=1)

# ウィジェットの配置
notebook.pack(expand=True, fill='both')
#########################################################
# advancedモードの内容

lbl_ad01 = tk.Label(tab_slice,text='h',width=6)
lbl_ad01.grid(row=0, column=2,sticky="NSEW")
lbl_ad02 = tk.Label(tab_slice,text='k',width=6)
lbl_ad02.grid(row=0, column=3,sticky="NSEW")
lbl_ad03 = tk.Label(tab_slice,text='l',width=6)
lbl_ad03.grid(row=0, column=4,sticky="NSEW")

lbl_ad04 = tk.Label(tab_slice,text='from',width=3)
lbl_ad04.grid(row=1, column=0,sticky="NSEW")
lbl_ad05 = tk.Label(tab_slice,text='to',width=3)
lbl_ad05.grid(row=2, column=0,sticky="NSEW")

lbl_ad06 = tk.Label(tab_slice,text='±δhkl(ver)',width=7)
lbl_ad06.grid(row=0, column=5,sticky="NSEW")
lbl_ad07 = tk.Label(tab_slice,text='±δhkl(hor)',width=7)
lbl_ad07.grid(row=2, column=5,sticky="NSEW")

lbl_ad08 = tk.Label(tab_slice,text='ℏω',width=6)
lbl_ad08.grid(row=0, column=1,sticky="NSEW")
txt_ad01_1 = ttk.Entry(tab_slice,width=6)
txt_ad01_1.grid(row=1, column=1,sticky="NSEW")
txt_ad01_2 = ttk.Entry(tab_slice,width=6)
txt_ad01_2.grid(row=2, column=1,sticky="NSEW")

txt_ad02_1 = ttk.Entry(tab_slice,width=6)
txt_ad02_1.grid(row=1, column=2,sticky="NSEW")
txt_ad02_2 = ttk.Entry(tab_slice,width=6)
txt_ad02_2.grid(row=1, column=3,sticky="NSEW")
txt_ad02_3 = ttk.Entry(tab_slice,width=6)
txt_ad02_3.grid(row=1, column=4,sticky="NSEW")

txt_ad03_1 = ttk.Entry(tab_slice,width=6)
txt_ad03_1.grid(row=2, column=2,sticky="NSEW")
txt_ad03_2 = ttk.Entry(tab_slice,width=6)
txt_ad03_2.grid(row=2, column=3,sticky="NSEW")
txt_ad03_3 = ttk.Entry(tab_slice,width=6)
txt_ad03_3.grid(row=2, column=4,sticky="NSEW")

txt_ad04_1 = ttk.Entry(tab_slice,width=6)
txt_ad04_1.grid(row=1, column=5,sticky="NSEW")
txt_ad04_2 = ttk.Entry(tab_slice,width=6)
txt_ad04_2.grid(row=3, column=5,sticky="NSEW")

def advanced_2D_constE():  
    # 入力情報の読み込み
    hw_ini=float(txt_ad01_1.get())
    hw_fin=float(txt_ad01_2.get())
    
    #Ec=(hw_ini+hw_fin)/2
    #Epm=np.abs((hw_ini-hw_fin)/2)
    
    # constE面の行列を生成
    # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
    global I_ce_adv,Ierr_ce_adv
    I_ce_adv=np.zeros((len(QV)-1,len(QU)-1))
    Ierr_ce_adv=np.zeros((len(QV)-1,len(QU)-1))
    
    hwlist1_ad=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist1_ad[ne] = float(energylist[ne])
        
    # 条件を満たすエネルギーの面を指定
    ind_e = list(zip(*np.where(( hw_ini <=  hwlist1_ad ) & (  hwlist1_ad <= hw_fin ))))
    Ind_e = list(np.ravel(ind_e))
    if not Ind_e:
        Ind_e = [np.abs(hw_ini-hwlist1_ad).argmin()]
    
    #I[ll,nn,mm]=I[hw,V,U]の順番でリスト化されている。
    for nn in range(len(QV)-1):
        for mm in range(len(QU)-1):
            n_nanind = (list(zip(*np.where(~np.isnan(I[Ind_e,nn,mm])))))
            N_nanind = list(np.ravel(n_nanind)[::1])
            if N_nanind:
                I_ce_adv[nn,mm] = np.nansum(I[Ind_e,nn,mm])/(len(N_nanind))
                Ierr_ce_adv[nn,mm] = ((np.nansum(np.multiply(Ierr[Ind_e,nn,mm],Ierr[Ind_e,nn,mm])))**(1/2))/(len(N_nanind))
            else:
                I_ce_adv[nn,mm] = np.nan
                Ierr_ce_adv[nn,mm] = np.nan
    #図を出力する
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Umin_txt.get()=="":
        Ulim_min=float(txt16.get())
    else:
        Ulim_min=float(scale_s_Umin_txt.get())
    if scale_s_Umax_txt.get()=="":
        Ulim_max=float(txt17.get())
    else:
        Ulim_max=float(scale_s_Umax_txt.get())
        
    if scale_s_Vmin_txt.get()=="":
        Vlim_min=float(txt19.get())
    else:
        Vlim_min=float(scale_s_Vmin_txt.get())
    if scale_s_Vmax_txt.get()=="":
        Vlim_max=float(txt20.get())
    else:
        Vlim_max=float(scale_s_Vmax_txt.get())
        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=np.abs(round(np.mean(databox[4,:])+np.mean(databox[5,:]),1))
    else:
        z_max=float(scale_s_Imax_txt.get())

    # 散乱面の読み込み
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())
    
    global table_2DX,table_2DY
    table_2DX = np.zeros((len(QU2),3))
    table_2DY = np.zeros((len(QV2),3))
    for i in range(len(QU2)):
        table_2DX[i] = QU2[i] * np.array([u1, u2, u3])
    for j in range(len(QV2)):
        table_2DY[j] = QV2[j] * np.array([v1, v2, v3])
    
    # 図を作成
    #fig, ax = plt.figure()
    #axにカラーバーを表示
    fig00, ax = plt.subplots()
    #plt.subplots_adjust(left=0.15, bottom=0.2)
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.2)  # マージンを調整してグラフを中央に配置
    # アスペクト比を変更
    ax.set_aspect(NV1/NU1)
    # グリッド線を引く
    gt=gridtype.get()
    if gt == 0:
        #ax.set_axisbelow(True)  # グリッド線を背面に配置
        ax.grid(False)
    elif gt == 1:
        ax.grid(True)
    #im=plt.pcolormesh(QU, QV, I_ce, cmap='jet', vmin=z_min, vmax=z_max)
    at=axistype.get()
    if at==0:
        im=plt.pcolormesh(QU, QV, I_ce_adv, cmap='jet', vmin=z_min, vmax=z_max)
    elif at==1:
        if z_min==0:
            z_min=np.nanmin(I[I != 0])
            im=plt.pcolormesh(QU, QV, I_ce_adv, cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
        else:
            im=plt.pcolormesh(QU, QV, I_ce_adv, cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
    #sb4=z_max#初期値を一応セット
    cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
    global E_I_ce
    E_I_ce = [hw_ini,hw_fin]
    # カラーバーのタイトルを設定
    cbar.set_label('Intenisty (a.u.)')
    ax.set_xlabel(str(Ulabel))
    ax.set_ylabel(str(Vlabel))
    ax.set_xlim(Ulim_min,Ulim_max)
    ax.set_ylim(Vlim_min,Vlim_max)
    #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
    #plt.axis('tight')
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(Ulim_min, 3)
    default_xmax = round(Ulim_max, 3)

    default_ymin = round(Vlim_min, 3)
    default_ymax = round(Vlim_max, 3)
    
    default_zmin = round(z_min, 3)
    default_zmax = round(z_max, 3)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.6, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
    zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            zmin_val = float(zmin_box.text)
            zmax_val = float(zmax_box.text)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
            fig00.canvas.draw_idle()
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    zmin_box.on_submit(update_axis_range)
    zmax_box.on_submit(update_axis_range)
    
    plt.show()

def advanced_2D_constQ():
    # 散乱面の読み込み
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    
    # 入力情報の読み込み、2D viewの場合エネルギーの読み込みは不要
    #hw_ini=float(txt_ad01_1.get())
    #hw_fin=float(txt_ad01_2.get())
    
    h_ini=float(txt_ad02_1.get())
    k_ini=float(txt_ad02_2.get())
    l_ini=float(txt_ad02_3.get())
    h_fin=float(txt_ad03_1.get())
    k_fin=float(txt_ad03_2.get())
    l_fin=float(txt_ad03_3.get())
    pm=float(txt_ad04_1.get())
    
    hkl_ini=[h_ini,k_ini,l_ini]
    hkl_fin=[h_fin,k_fin,l_fin]
    
    # uとvを連結して逆行列を生成する。
    #np.linalg.pinv(np.vstack((u, v)).T)
    
    # 入力した方向を生成するuとvの定数を計算。Uの定数とVの定数
    constants1 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_ini)
    constants2 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_fin)
    # constant1=[U_ini,V_ini],constant2=[U_fin,V_fin]
    
    # U,Vの要素とvalueの差の絶対値を計算し、最小値のインデックスを取得
    Uini_index = np.abs(QU2 - constants1[0]).argmin()
    Vini_index = np.abs(QV2 - constants1[1]).argmin()

    Ufin_index = np.abs(QU2 - constants2[0]).argmin()
    Vfin_index = np.abs(QV2 - constants2[1]).argmin()
    
    Unum=np.abs(Ufin_index-Uini_index)+1
    Vnum=np.abs(Vfin_index-Vini_index)+1
    
    # スライス及びカットの際に自動的に個数が多い方をX軸として選択。
    #I[ll,nn,mm]=I[hw,V,U]の順番でリスト化されている。
    if Unum>=Vnum:
        N=Unum
        if Uini_index<Ufin_index:
            Xrange=np.linspace(QU2[Uini_index],QU2[Ufin_index], N)
            Xtable=Xrange
        elif Uini_index>Ufin_index:
            Xrange=np.linspace(QU2[Ufin_index],QU2[Uini_index], N)
            Xtable=Xrange
        if Vfin_index!=Vini_index:
            #Yrange=(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*Xrange+constants2[0]-(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*constants2[1]
            Yrange=(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*Xrange+constants2[1]-(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*constants2[0]
            Ytable=Yrange
        elif Vfin_index==Vini_index:# 傾きが定義できない場合と0の場合を除く
            Yrange=np.ones(len(Xrange))*QV2[Vini_index]
            Ytable=np.ones(len(Yrange))*constants1[1]
        global table_2D
        table_2D=np.zeros((len(Xtable),3))
        # Xrange[0]に最も近い値のインデックスを取得
        index_Xrange_0 = np.abs(QU2 - Xrange[0]).argmin()
        # Xrange[-1]に最も近い値のインデックスを取得
        index_Xrange_last = np.abs(QU2 - Xrange[-1]).argmin()
        global I_cq,I_cq_err
        I_cq=np.zeros((len(energylist), len(Xrange)))
        I_cq_err=np.zeros((len(energylist), len(Xrange)))
        for ll in range(len(energylist)):
            for i in range(len(Xrange)):
                table_2D[i]=np.array([u1, u2, u3])* Xtable[i] + np.array([v1, v2, v3])*Ytable[i]
                # 条件を満たすインデックスを取得。Yrangeの±pmの範囲内にあるインデックス。この条件ではY軸はV
                ind_cut = list(zip(*np.where((Yrange[i] - pm <= QV2 ) & (QV2 <= Yrange[i] + pm))))
                Ind_cut = list(np.ravel(ind_cut))
                n_nanind = (list(zip(*np.where(~np.isnan(I[:,:,index_Xrange_0:index_Xrange_last+1][ll,Ind_cut,i])))))
                N_nanind = list(np.ravel(n_nanind)[::2])
                if N_nanind:
                    I_cq[ll,i] = np.nansum(I[:,:,index_Xrange_0:index_Xrange_last+1][ll,Ind_cut,i])/(len(N_nanind))
                    I_cq_err[ll,i] = np.nansum((np.multiply(Ierr[:,:,index_Xrange_0:index_Xrange_last+1][ll,Ind_cut,i],Ierr[:,:,index_Xrange_0:index_Xrange_last+1][ll,Ind_cut,i]))**(1/2))/(len(N_nanind))
                else:
                    I_cq[ll,i] = np.nan
                    I_cq_err[ll,i] = np.nan
                    
    elif Unum<Vnum:
        N=Vnum
        if Vini_index<Vfin_index:
            Xrange=np.linspace(QV2[Vini_index],QV2[Vfin_index], N)
            Xtable=Xrange
        elif Vini_index>Vfin_index:
            Xrange=np.linspace(QV2[Vfin_index],QV2[Vini_index], N)
            Xtable=Xrange
        if Ufin_index!=Uini_index:
            #Yrange=(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*Xrange+constants2[1]-(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*constants2[0]
            Yrange=(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*Xrange+constants2[0]-(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*constants2[1]
            Ytable=Yrange
        elif Ufin_index==Uini_index:# 傾きが定義できない場合と0の場合を除く
            Yrange=np.ones(len(Xrange))*QU2[Uini_index]
            Ytable=np.ones(len(Yrange))*constants1[0]
        table_2D=np.zeros((len(Xtable),3))
        # Xrange[0]に最も近い値のインデックスを取得
        index_Xrange_0 = np.abs(QV2 - Xrange[0]).argmin()
        # Xrange[-1]に最も近い値のインデックスを取得
        index_Xrange_last = np.abs(QV2 - Xrange[-1]).argmin()
        
        I_cq=np.zeros((len(energylist), len(Xrange)))
        I_cq_err=np.zeros((len(energylist), len(Xrange)))
        for ll in range(len(energylist)):
            for i in range(len(Xrange)):
                table_2D[i]=np.array([v1, v2, v3])* Xtable[i] + np.array([u1, u2, u3])*Ytable[i]
                # 条件を満たすインデックスを取得。Yrangeの±pmの範囲内にあるインデックス。この条件ではY軸はV
                ind_cut = list(zip(*np.where((Yrange[i] - pm <= QU2 ) & (QU2 <= Yrange[i] + pm))))
                Ind_cut = list(np.ravel(ind_cut))
                n_nanind = (list(zip(*np.where(~np.isnan(I[:,index_Xrange_0:index_Xrange_last+1,:][ll,i,Ind_cut])))))
                N_nanind = list(np.ravel(n_nanind)[::2])
                if N_nanind:
                    I_cq[ll,i] = np.nansum(I[:,index_Xrange_0:index_Xrange_last+1,:][ll,i,Ind_cut])/(len(N_nanind))
                    I_cq_err[ll,i] = np.nansum((np.multiply(Ierr[:,index_Xrange_0:index_Xrange_last+1,:][ll,i,Ind_cut],Ierr[:,index_Xrange_0:index_Xrange_last+1,:][ll,i,Ind_cut]))**(1/2))/(len(N_nanind))
                else:
                    I_cq[ll,i] = np.nan
                    I_cq_err[ll,i] = np.nan
    # X軸の範囲は入力した範囲
    if Unum>=Vnum:
        Xlim_min=constants1[0]
        Xlim_max=constants2[0]
    elif Unum<Vnum:
        Xlim_min=constants1[1]
        Xlim_max=constants2[1]
    
    if scale_s_Emin_txt.get()=="":
        Elim_min=round(float(energylist[0]), 2)
    else:
        Elim_min=float(scale_s_Emin_txt.get())
    if scale_s_Emax_txt.get()=="":
        Elim_max=round(float(energylist[-1]), 2)
    else:
        Elim_max=float(scale_s_Emax_txt.get())
        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=np.abs(round(np.mean(databox[4,:])+np.mean(databox[5,:]),1))
    else:
        z_max=float(scale_s_Imax_txt.get())
        
    # X軸を3等分する
    x_values = np.linspace(constants1[0], constants2[0], 3)
    y_values = np.linspace(constants1[1], constants2[1], 3)
    # x_labels を生成
    x_labels = []
    for u, v in zip(x_values, y_values):
        label = [round(u1*u + v1*v, 3), round(u2*u + v2*v, 3), round(u3*u + v3*v, 3)]
        x_labels.append(label)
    
    #図を出力する
    #intensityの範囲
    fig01, ax = plt.subplots()
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.2)  # マージンを調整してグラフを中央に配置
    global table_2D_qrange
    if Unum>=Vnum:
        ax.text(0.1,1.1,f'{str(Vlabel)} ± %.3f r.l.u.' %(pm), transform=ax.transAxes)
        table_2D_qrange=[[-pm*v1,pm*v1],[-pm*v2,pm*v2],[-pm*v3,pm*v3]]
    elif Unum<=Vnum:
        ax.text(0.1,1.1,f'{str(Ulabel)} ± %.3f r.l.u.' %(pm), transform=ax.transAxes)
        table_2D_qrange=[[-pm*u1,pm*u1],[-pm*u2,pm*u2],[-pm*u3,pm*u3]]
    #ax.set_xlabel(str(xlabel))
    # X軸の目盛りとラベルを設定
    if Unum>=Vnum:
        ax.set_xticks(x_values,x_labels)
        ax.set_xticklabels(x_labels, rotation=0)  # ラベルを45度回転させる
    elif Unum<Vnum:
        ax.set_xticks(y_values,x_labels)
        ax.set_xticklabels(x_labels, rotation=0)  # ラベルを45度回転させる
    ax.set_xlabel("[H, K, L] (r.l.u.)")
    ax.set_ylabel("ℏω (meV)")
    ax.set_xlim(Xlim_min,Xlim_max)
    ax.set_ylim(Elim_min,Elim_max)
    #im=plt.pcolormesh(QV, hwlist4, I_hwV, cmap='jet', vmin=z_min, vmax=z_max)
    at=axistype.get()
    # グリッド線を引く
    gt=gridtype.get()
    if gt == 0:
        #ax.set_axisbelow(True)  # グリッド線を背面に配置
        ax.grid(False)
    elif gt == 1:
        ax.grid(True)
    if at==0:
        im=plt.pcolormesh(Xrange, energylist, I_cq, cmap='jet', vmin=z_min, vmax=z_max)
    elif at==1:
        if z_min==0:
            z_min=np.nanmin(I[I != 0])
            im=plt.pcolormesh(Xrange, energylist, I_cq, cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
        else:
            im=plt.pcolormesh(Xrange, energylist, I_cq, cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
    cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
    # カラーバーのタイトルを設定
    cbar.set_label('Intenisty (a.u.)')
    #ax.text(0.1,1.1,f'{txt_ul.get()} = %.3f ± %.3f r.l.u.' %(Uc,Upm), transform=ax.transAxes)
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_ymin = round(Elim_min, 3)
    default_ymax = round(Elim_max, 3)
    
    default_zmin = round(z_min, 3)
    default_zmax = round(z_max, 3)

    # テキストボックスを作成して最小値と最大値を設定
    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
    zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            zmin_val = float(zmin_box.text)
            zmax_val = float(zmax_box.text)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
            fig01.canvas.draw_idle()
        except ValueError:
            pass

    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    zmin_box.on_submit(update_axis_range)
    zmax_box.on_submit(update_axis_range)
    
    plt.show()

# constant E mapを表示するボタン
button01_ad = ttk.Button(tab_slice,text="HKL vs hkl",command=advanced_2D_constE,width=12)
button01_ad.grid(row=3, column=1,columnspan=2,sticky="NSEW")

# constant Q mapを表示するボタン
button02_ad = ttk.Button(tab_slice,text="ℏω vs HKL",command=advanced_2D_constQ,width=12)
button02_ad.grid(row=3, column=3,columnspan=2,sticky="NSEW")

def advanced_1D_alongE():
    # 散乱面の読み込み
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    
    # 入力情報の読み込み    
    h_cen=float(txt_ad02_1.get())
    k_cen=float(txt_ad02_2.get())
    l_cen=float(txt_ad02_3.get())
    parp_pm=float(txt_ad04_1.get())
    para_pm=float(txt_ad04_2.get())
    
    hkl_cen=[h_cen,k_cen,l_cen]
    
    # ラベル作成用に
    label_hkl_cen=[round(h_cen,3),round(k_cen,3),round(l_cen,3)]
    label_pm1=[round(u1*para_pm,3),round(u2*para_pm,3),round(u3*para_pm,3)]
    label_pm2=[round(v1*parp_pm,3),round(v2*parp_pm,3),round(v3*parp_pm,3)]
    
    # 入力した方向を生成するuとvの定数を計算。Uの定数とVの定数
    constants1 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_cen)
    
    #U,Vの要素から範囲内のインデックスを取り出す
    ind_para_range = list(zip(*np.where((constants1[0]-para_pm <= QU2 ) & (QU2 <= constants1[0]+para_pm))))
    Ind_para_range = list(np.ravel(ind_para_range))
    ind_parp_range = list(zip(*np.where((constants1[1]-parp_pm <= QV2 ) & (QV2 <= constants1[1]+parp_pm))))
    Ind_parp_range = list(np.ravel(ind_parp_range))
    
    if not Ind_para_range:
        Ind_para_range = [np.abs(QU2 - constants1[0]).argmin()]
    if not Ind_parp_range:
        Ind_parp_range = [np.abs(QV2 - constants1[1]).argmin()]
    
    global I_1d_alongE,I_1d_alongE_err
    I_1d_alongE=np.zeros((len(energylist)))
    I_1d_alongE_err=np.zeros((len(energylist)))
    for ll in range(len(energylist)):
        n_nanind = (list(zip(*np.where(~np.isnan(I[ll, Ind_parp_range[0]:Ind_parp_range[-1]+1, Ind_para_range[0]:Ind_para_range[-1]+1])))))
        N_nanind = list(np.ravel(n_nanind)[::2])
        I_1d_alongE[ll] = np.nansum(I[ll,Ind_parp_range[0]:Ind_parp_range[-1]+1,Ind_para_range[0]:Ind_para_range[-1]+1])/(len(N_nanind))
        I_1d_alongE_err[ll] = ((np.nansum(np.multiply(Ierr[ll,Ind_parp_range[0]:Ind_parp_range[-1]+1,Ind_para_range[0]:Ind_para_range[-1]+1],Ierr[ll,Ind_parp_range[0]:Ind_parp_range[-1]+1,Ind_para_range[0]:Ind_para_range[-1]+1])))**(1/2))/(len(N_nanind))
    
    if np.all(np.isnan(I_1d_alongE)):
        pass
    else:
        # グラフの軸設定
        if scale_s_Emin_txt.get()=="":
            xlim_min=round(float(energylist[0]), 2)
        else:
            xlim_min=float(scale_s_Emin_txt.get())
        if scale_s_Emax_txt.get()=="":
            xlim_max=round(float(energylist[-1]), 2)
        else:
            xlim_max=float(scale_s_Emax_txt.get())
            
        # カラーバースケール。空欄の場合は平均値を出力するようにする。
        if scale_s_Imin_txt.get()=="":
            if np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err) >= 0:
                ylim_min=0
            elif np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err) < 0:
                ylim_min=round(np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err),1)
        else:
            ylim_min=float(scale_s_Imin_txt.get())
            
        if scale_s_Imax_txt.get()=="":
            if np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err) >= 0:
                ylim_max=round(np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err),1)
            elif np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err) < 0:
                ylim_max=np.abs(round(np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err),1))
        else:
            ylim_max=float(scale_s_Imax_txt.get())
            
        global adv1DE
        # エラーバーのグラフを作成
        fig02=plt.figure()
        
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_xmin = round(xlim_min, 2)
        default_xmax = round(xlim_max, 2)

        default_ymin = round(ylim_min, 2)
        default_ymax = round(ylim_max, 2)

        # テキストボックスを作成して最小値と最大値を設定
        xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
        xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                xmin_val = float(xmin_box.text)
                xmax_val = float(xmax_box.text)
                ax02.set_xlim(xmin_val, xmax_val)
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax02.set_ylim(ymin_val, ymax_val)
                fig02.canvas.draw_idle()
            except ValueError:
                pass

        xmin_box.on_submit(update_axis_range)
        xmax_box.on_submit(update_axis_range)
        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        
        # 現在のFigure番号を取得
        adv1DE = plt.gcf().number
        fig02.subplots_adjust(left=0.30, bottom=0.2)
        ax02 = fig02.add_subplot(111)
        ax02.set_xlabel("ℏω (meV)")
        ax02.set_ylabel("Intensity (a. u.)")
        
        ax02.errorbar(energylist, I_1d_alongE, yerr=I_1d_alongE_err, capsize=10, label = str(label_hkl_cen) + '±' + str(label_pm1)+ '±' + str(label_pm2) + '(r.l.u.)')
        ax02.grid()
        at=axistype.get()
        if at==1:
            plt.yscale('log')
            if ylim_min==0:
                ylim_min=np.nanmin(I_1d_alongE)-np.nanmax(I_1d_alongE_err)
                
        global I_1d_Ivshw_E,I_1d_Ivshw_HKL,I_1d_Ivshw_hkl
        I_1d_Ivshw_E = energylist
        I_1d_Ivshw_HKL = [[round(h_cen+u1*-para_pm,3),round(h_cen+u1*para_pm,3)],[round(k_cen+u2*-para_pm,3),round(k_cen+u2*para_pm,3)],[round(l_cen+u3*-para_pm,3),round(l_cen+u3*para_pm,3)]]
        I_1d_Ivshw_hkl = [[round(h_cen+v1*-parp_pm,3),round(h_cen+v1*parp_pm,3)],[round(k_cen+v2*-parp_pm,3),round(k_cen+v2*parp_pm,3)],[round(l_cen+v3*-parp_pm,3),round(l_cen+v3*parp_pm,3)]]
        
        ax02.legend()
        ax02.set_xlim(xlim_min, xlim_max)
        ax02.set_ylim(ylim_min, ylim_max)
        
        plt.show()

def add_advanced_1D_alongE():
    # 図番号が存在するかどうかの確認
    if plt.fignum_exists(adv1DE)==True:
        # 散乱面の読み込み
        u1=float(txt9.get())
        u2=float(txt10.get())
        u3=float(txt11.get())
        v1=float(txt12.get())
        v2=float(txt13.get())
        v3=float(txt14.get())
        u = [u1,u2,u3]
        v = [v1,v2,v3]
        
        # 入力情報の読み込み    
        h_cen=float(txt_ad02_1.get())
        k_cen=float(txt_ad02_2.get())
        l_cen=float(txt_ad02_3.get())
        parp_pm=float(txt_ad04_1.get())
        para_pm=float(txt_ad04_2.get())
        
        hkl_cen=[h_cen,k_cen,l_cen]
        
        # ラベル作成用に
        label_hkl_cen=[round(h_cen,3),round(k_cen,3),round(l_cen,3)]
        label_pm1=[round(u1*para_pm,3),round(u2*para_pm,3),round(u3*para_pm,3)]
        label_pm2=[round(v1*parp_pm,3),round(v2*parp_pm,3),round(v3*parp_pm,3)]
        
        # 入力した方向を生成するuとvの定数を計算。Uの定数とVの定数
        constants1 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_cen)
        
        #U,Vの要素から範囲内のインデックスを取り出す
        ind_para_range = list(zip(*np.where((constants1[0]-para_pm <= QU2 ) & (QU2 <= constants1[0]+para_pm))))
        Ind_para_range = list(np.ravel(ind_para_range))
        ind_parp_range = list(zip(*np.where((constants1[1]-parp_pm <= QV2 ) & (QV2 <= constants1[1]+parp_pm))))
        Ind_parp_range = list(np.ravel(ind_parp_range))
        
        if not Ind_para_range:
            Ind_para_range = [np.abs(QU2 - constants1[0]).argmin()]
        if not Ind_parp_range:
            Ind_parp_range = [np.abs(QV2 - constants1[1]).argmin()]
        
        global I_1d_alongE,I_1d_alongE_err
        I_1d_alongE=np.zeros((len(energylist)))
        I_1d_alongE_err=np.zeros((len(energylist)))
        for ll in range(len(energylist)):
            n_nanind = (list(zip(*np.where(~np.isnan(I[ll, Ind_parp_range[0]:Ind_parp_range[-1]+1, Ind_para_range[0]:Ind_para_range[-1]+1])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1d_alongE[ll] = np.nansum(I[ll,Ind_parp_range[0]:Ind_parp_range[-1]+1,Ind_para_range[0]:Ind_para_range[-1]+1])/(len(N_nanind))
            I_1d_alongE_err[ll] = ((np.nansum(np.multiply(Ierr[ll,Ind_parp_range[0]:Ind_parp_range[-1]+1,Ind_para_range[0]:Ind_para_range[-1]+1],Ierr[ll,Ind_parp_range[0]:Ind_parp_range[-1]+1,Ind_para_range[0]:Ind_para_range[-1]+1])))**(1/2))/(len(N_nanind))
        
        if np.all(np.isnan(I_1d_alongE)):
            pass
        else:
            # グラフの軸設定
            xlim_min=energylist[0]
            xlim_max=energylist[-1]
            
            ylim_min=0
            ylim_max=np.nanmax(I_1d_alongE)+np.nanmax(I_1d_alongE_err)
            
            ## エラーバーのグラフを作成
            # 図番号に対応するaxオブジェクトにアクセス
            fig03 = plt.figure(adv1DE)
            ax03 = fig03.gca()
            ax03.errorbar(energylist, I_1d_alongE, yerr=I_1d_alongE_err, capsize=10, label = str(label_hkl_cen) + '±' + str(label_pm1)+ '±' + str(label_pm2) + '(r.l.u.)')
            
            at=axistype.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(I_1d_alongE)-np.nanmax(I_1d_alongE_err)
                    
            global I_1d_Ivshw_E,I_1d_Ivshw_HKL,I_1d_Ivshw_hkl
            I_1d_Ivshw_E = energylist
            I_1d_Ivshw_HKL = [[round(h_cen+u1*-para_pm,3),round(h_cen+u1*para_pm,3)],[round(k_cen+u2*-para_pm,3),round(k_cen+u2*para_pm,3)],[round(l_cen+u3*-para_pm,3),round(l_cen+u3*para_pm,3)]]
            I_1d_Ivshw_hkl = [[round(h_cen+v1*-parp_pm,3),round(h_cen+v1*parp_pm,3)],[round(k_cen+v2*-parp_pm,3),round(k_cen+v2*parp_pm,3)],[round(l_cen+v3*-parp_pm,3),round(l_cen+v3*parp_pm,3)]]
            
            ax03.legend()
            #ax03.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            #ax03.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            
            plt.draw()

# 1Dcut along Eを表示するボタン
button02_ad = ttk.Button(tab_slice,text="I vs ℏω",command=advanced_1D_alongE,width=11)
button02_ad.grid(row=0, column=6,sticky="NSEW")

# 1Dcut along Eを追加表示するボタン
button02_ad = ttk.Button(tab_slice,text="add I vs ℏω",command=add_advanced_1D_alongE,width=11)
button02_ad.grid(row=1, column=6,sticky="NSEW")

def advanced_1D_alongQ():
    # 散乱面の読み込み
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    
    # 入力情報の読み込み    
    hw_ini=float(txt_ad01_1.get())
    hw_fin=float(txt_ad01_2.get())
    
    hwlist2_ad=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist2_ad[ne] = float(energylist[ne])
        
    # 条件を満たすエネルギーの面を指定
    ind_e = list(zip(*np.where(( hw_ini <=  hwlist2_ad ) & (  hwlist2_ad <= hw_fin ))))
    Ind_e = list(np.ravel(ind_e))
    if not Ind_e:
        Ind_e = [np.abs(hw_ini-hwlist2_ad).argmin()]
    
    h_ini=float(txt_ad02_1.get())
    k_ini=float(txt_ad02_2.get())
    l_ini=float(txt_ad02_3.get())
    h_fin=float(txt_ad03_1.get())
    k_fin=float(txt_ad03_2.get())
    l_fin=float(txt_ad03_3.get())
    pm=float(txt_ad04_1.get())

    hkl_ini=[h_ini,k_ini,l_ini]
    hkl_fin=[h_fin,k_fin,l_fin]
    
    # 入力した方向を生成するuとvの定数を計算。Uの定数とVの定数
    constants1 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_ini)
    constants2 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_fin)

    # U,Vの要素とvalueの差の絶対値を計算し、最小値のインデックスを取得
    Uini_index = np.abs(QU2 - constants1[0]).argmin()
    Vini_index = np.abs(QV2 - constants1[1]).argmin()

    Ufin_index = np.abs(QU2 - constants2[0]).argmin()
    Vfin_index = np.abs(QV2 - constants2[1]).argmin()
    
    Unum=np.abs(Ufin_index-Uini_index)+1
    Vnum=np.abs(Vfin_index-Vini_index)+1
    
    # スライス及びカットの際に自動的に個数が多い方をX軸として選択。
    #I[ll,nn,mm]=I[hw,V,U]の順番でリスト化されている。
    if Unum>=Vnum:
        N=Unum
        if Uini_index<Ufin_index:
            #Xrange=QU2[Uini_index:Ufin_index+1]
            Xrange=np.linspace(QU2[Uini_index],QU2[Ufin_index], N)
        elif Uini_index>Ufin_index:
            #Xrange=QU2[Ufin_index:Uini_index+1]
            Xrange=np.linspace(QU2[Ufin_index],QU2[Uini_index], N)
        
        # Xrange[0]に最も近い値のインデックスを取得
        index_Xrange_0 = np.abs(QU2 - Xrange[0]).argmin()
        # Xrange[-1]に最も近い値のインデックスを取得
        index_Xrange_last = np.abs(QU2 - Xrange[-1]).argmin()
        
        global I_1d_alongQ,I_1d_alongQ_err
        I_1d_alongQ=np.zeros((len(Xrange)))
        I_1d_alongQ_err=np.zeros((len(Xrange)))
        
        # 理想のXYのテーブルを作成
        Xtable=Xrange
        Ytable=np.zeros((len(Xtable)))
        global table_1D
        table_1D=np.zeros((len(Xtable),3))
        
        for i in range(len(Xrange)):
            if Vfin_index!=Vini_index:
                Ycenter=(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*Xrange[i]+constants2[1]-(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*constants2[0]
                Ytable[i]=Ycenter
            elif Vfin_index==Vini_index:# 傾きが定義できない場合と0の場合を除く
                Ycenter=QV2[Vini_index]
                Ytable[i]=constants1[1]
            table_1D[i]=np.array([u1, u2, u3])* Xtable[i] + np.array([v1, v2, v3])*Ytable[i]
            ind_1d_range = list(zip(*np.where((Ycenter-pm <= QV2 ) & (QV2 <= Ycenter+pm))))
            Ind_1d_range = list(np.ravel(ind_1d_range))
            
            n_nanind = (list(zip(*np.where(~np.isnan(I[:,:,index_Xrange_0:index_Xrange_last+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1d_alongQ[i] = np.nansum(I[:,:,index_Xrange_0:index_Xrange_last+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i])/(len(N_nanind))
            I_1d_alongQ_err[i] = ((np.nansum(np.multiply(Ierr[:,:,index_Xrange_0:index_Xrange_last+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i],Ierr[:,:,index_Xrange_0:index_Xrange_last+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i])))**(1/2))/(len(N_nanind))
        
        # グラフの軸設定
        # X軸の範囲は入力した範囲
        Xlim_min=constants1[0]
        Xlim_max=constants2[0]
        
        # X軸を3等分する
        x_values = np.linspace(constants1[0], constants2[0], 3)
        y_values = np.linspace(constants1[1], constants2[1], 3)
        # x_labels を生成
        x_labels = []
        for U, V in zip(x_values, y_values):
            label = [round(u1*U + v1*V, 3), round(u2*U + v2*V, 3), round(u3*U + v3*V, 3)]
            x_labels.append(label)  
        
    if Vnum>=Unum:
        N=Vnum
        if Vini_index<Vfin_index:
            #Xrange=QU2[Uini_index:Ufin_index+1]
            Xrange=np.linspace(QV2[Vini_index],QV2[Vfin_index], N)
        elif Vini_index>Vfin_index:
            #Xrange=QU2[Ufin_index:Uini_index+1]
            Xrange=np.linspace(QV2[Vfin_index],QV2[Vini_index], N)
        
        # Xrange[0]に最も近い値のインデックスを取得
        index_Xrange_0 = np.abs(QV2 - Xrange[0]).argmin()
        # Xrange[-1]に最も近い値のインデックスを取得
        index_Xrange_last = np.abs(QV2 - Xrange[-1]).argmin()
        
        I_1d_alongQ=np.zeros((len(Xrange)))
        I_1d_alongQ_err=np.zeros((len(Xrange)))
        
        # 理想のXYのテーブルを作成
        Xtable=Xrange
        Ytable=np.zeros((len(Xtable)))
        table_1D=np.zeros((len(Xtable),3))
        
        for i in range(len(Xrange)):
            if Ufin_index!=Uini_index:
                Ycenter=(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*Xrange[i]+constants2[0]-(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*constants2[1]
                Ytable[i]=Ycenter
            elif Ufin_index==Uini_index:# 傾きが定義できない場合と0の場合を除く
                Ycenter=QU2[Uini_index]
                Ytable[i]=constants1[0]
            table_1D[i]=np.array([v1, v2, v3])* Xtable[i] + np.array([u1, u2, u3])*Ytable[i]
            ind_1d_range = list(zip(*np.where((Ycenter-pm <= QU2 ) & (QU2 <= Ycenter+pm))))
            Ind_1d_range = list(np.ravel(ind_1d_range))
            n_nanind = (list(zip(*np.where(~np.isnan(I[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1d_alongQ[i] = np.nansum(I[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1])/(len(N_nanind))
            I_1d_alongQ_err[i] = ((np.nansum(np.multiply(Ierr[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1],Ierr[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1])))**(1/2))/(len(N_nanind))
        # グラフの軸設定
        # X軸の範囲は入力した範囲
        
        Xlim_min=constants1[1]
        Xlim_max=constants2[1]

        # X軸を3等分する
        x_values = np.linspace(constants1[1], constants2[1], 3)
        y_values = np.linspace(constants1[0], constants2[0], 3)
        # x_labels を生成
        x_labels = []
        for V, U in zip(x_values, y_values):
            label = [round(u1*U + v1*V, 3), round(u2*U + v2*V, 3), round(u3*U + v3*V, 3)]
            x_labels.append(label)
    
    if np.all(np.isnan(I_1d_alongQ)):
        pass
    else:
        # InfをNaNに変換
        #I_1d_alongQ[I_1d_alongQ == np.inf] = np.nan
        #I_1d_alongQ_err[I_1d_alongQ_err == np.inf] = np.nan
        
        # グラフの軸設定
        # カラーバースケール。空欄の場合は平均値を出力するようにする。
        if scale_s_Imin_txt.get()=="":
            if np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err) >= 0:
                ylim_min=0
            elif np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err) < 0:
                ylim_min=round(np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err),1)
        else:
            ylim_min=float(scale_s_Imin_txt.get())
            
        if scale_s_Imax_txt.get()=="":
            if np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err) >= 0:
                ylim_max=round(np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err),1)
            elif np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err) < 0:
                ylim_max=np.abs(round(np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err),1))
        else:
            ylim_max=float(scale_s_Imax_txt.get())
        
        global adv1DQ
        # エラーバーのグラフを作成
        fig04=plt.figure()
         
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_ymin = round(ylim_min, 2)
        default_ymax = round(ylim_max, 2)

        # テキストボックスを作成して最小値と最大値を設定
        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax04.set_ylim(ymin_val, ymax_val)
                fig04.canvas.draw_idle()
            except ValueError:
                pass

        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        
        # 現在のFigure番号を取得
        adv1DQ = plt.gcf().number
        fig04.subplots_adjust(left=0.30, bottom=0.2)
        ax04 = fig04.add_subplot(111)
        
        #plt.text(0.1,1.1,f'{txt_vl.get()} = %.3f' %Vc, transform=ax.transAxes)
        #plt.text(0.3,1.1,' ± %.3f r.l.u.' %Vpm, transform=ax.transAxes)
        #plt.text(0.1,1.05,f'{txt_ul.get()} = %.3f' %Uc, transform=ax.transAxes)
        #plt.text(0.3,1.05,' ± %.3f r.l.u.' %Upm, transform=ax.transAxes)
        plt.xticks(x_values,x_labels)
        plt.ylabel("Intensity (a. u.)")
        plt.xlabel("[H, K, L] (r. l. u.)")
        if Unum>=Vnum:
            ax04.errorbar(Xrange, I_1d_alongQ, yerr=I_1d_alongQ_err, capsize=10, label = 'ℏω = ' + str(hw_ini) + '~' + str(hw_fin) + ' meV, ±' + str([pm*v1,pm*v2,pm*v3]) + ' (r.l.u.)')
        if Vnum>=Unum:
            ax04.errorbar(Xrange, I_1d_alongQ, yerr=I_1d_alongQ_err, capsize=10, label = 'ℏω = ' + str(hw_ini) + '~' + str(hw_fin) + ' meV, ±' + str([pm*u1,pm*u2,pm*u3]) + ' (r.l.u.)')
        global I_1d_IvsHKL_E,I_1d_IvsHKL_hkl,I_1d_IvsHKL_HKL
        I_1d_IvsHKL_E = [hw_ini,hw_fin]
        I_1d_IvsHKL_hkl = table_1D.T
        if Unum>=Vnum:
            I_1d_IvsHKL_HKL = [[-pm*v1,pm*v1],[-pm*v2,pm*v2],[-pm*v3,pm*v3]]
        if Vnum>=Unum:
            I_1d_IvsHKL_HKL = [[-pm*u1,pm*u1],[-pm*u2,pm*u2],[-pm*u3,pm*u3]]
        at=axistype.get()
        if at==1:
            plt.yscale('log')
            if ylim_min==0:
                ylim_min=np.nanmin(I_1d_alongQ)-np.nanmax(I_1d_alongQ_err)
        ax04.legend()
        ax04.set_xlim(Xlim_min,Xlim_max) #x軸の範囲を指定
        ax04.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
        #plt.tick_params(labelsize=20)
        plt.grid()
        plt.show()
    
def add_advanced_1D_alongQ():
    # 図番号が存在するかどうかの確認
    if plt.fignum_exists(adv1DQ)==True:
        # 散乱面の読み込み
        u1=float(txt9.get())
        u2=float(txt10.get())
        u3=float(txt11.get())
        v1=float(txt12.get())
        v2=float(txt13.get())
        v3=float(txt14.get())
        u = [u1,u2,u3]
        v = [v1,v2,v3]
        
        # 入力情報の読み込み    
        hw_ini=float(txt_ad01_1.get())
        hw_fin=float(txt_ad01_2.get())
        
        hwlist2_ad=np.zeros(len(energylist))
        for ne in range(len(energylist)):
            hwlist2_ad[ne] = float(energylist[ne])
            
        # 条件を満たすエネルギーの面を指定
        ind_e = list(zip(*np.where(( hw_ini <=  hwlist2_ad ) & (  hwlist2_ad <= hw_fin ))))
        Ind_e = list(np.ravel(ind_e))
        
        h_ini=float(txt_ad02_1.get())
        k_ini=float(txt_ad02_2.get())
        l_ini=float(txt_ad02_3.get())
        h_fin=float(txt_ad03_1.get())
        k_fin=float(txt_ad03_2.get())
        l_fin=float(txt_ad03_3.get())
        pm=float(txt_ad04_1.get())

        hkl_ini=[h_ini,k_ini,l_ini]
        hkl_fin=[h_fin,k_fin,l_fin]
        
        # 入力した方向を生成するuとvの定数を計算。Uの定数とVの定数
        constants1 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_ini)
        constants2 = np.dot(np.linalg.pinv(np.vstack((u, v)).T), hkl_fin)

        # U,Vの要素とvalueの差の絶対値を計算し、最小値のインデックスを取得
        Uini_index = np.abs(QU2 - constants1[0]).argmin()
        Vini_index = np.abs(QV2 - constants1[1]).argmin()

        Ufin_index = np.abs(QU2 - constants2[0]).argmin()
        Vfin_index = np.abs(QV2 - constants2[1]).argmin()
        
        Unum=np.abs(Ufin_index-Uini_index)+1
        Vnum=np.abs(Vfin_index-Vini_index)+1
        
        # 条件分岐の設定
        if len(Ind_e)!=0:
        
            # スライス及びカットの際に自動的に個数が多い方をX軸として選択。
            #I[ll,nn,mm]=I[hw,V,U]の順番でリスト化されている。
            if Unum>=Vnum:
                N=Unum
                if Uini_index<Ufin_index:
                    #Xrange=QU2[Uini_index:Ufin_index+1]
                    Xrange=np.linspace(QU2[Uini_index],QU2[Ufin_index], N)
                elif Uini_index>Ufin_index:
                    #Xrange=QU2[Ufin_index:Uini_index+1]
                    Xrange=np.linspace(QU2[Ufin_index],QU2[Uini_index], N)
                
                global I_1d_alongQ,I_1d_alongQ_err
                I_1d_alongQ=np.zeros((len(Xrange)))
                I_1d_alongQ_err=np.zeros((len(Xrange)))
                
                # 理想のXYのテーブルを作成
                Xtable=Xrange
                Ytable=np.zeros((len(Xtable)))
                global table
                table=np.zeros((len(Xtable),3))
                
                for i in range(len(Xrange)):
                    if Vfin_index!=Vini_index:
                        Ycenter=(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*Xrange[i]+constants2[1]-(constants1[1]-constants2[1])/(constants1[0]-constants2[0])*constants2[0]
                        Ytable[i]=Ycenter
                    elif Vfin_index==Vini_index:# 傾きが定義できない場合と0の場合を除く
                        Ycenter=QV2[Vini_index]
                        Ytable[i]=constants1[1]
                    table[i]=np.array([u1, u2, u3])* Xtable[i] + np.array([v1, v2, v3])*Ytable[i]
                    ind_1d_range = list(zip(*np.where((Ycenter-pm <= QV2 ) & (QV2 <= Ycenter+pm))))
                    Ind_1d_range = list(np.ravel(ind_1d_range))
                    n_nanind = (list(zip(*np.where(~np.isnan(I[:,:,Uini_index:Ufin_index+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i])))))
                    N_nanind = list(np.ravel(n_nanind)[::2])
                    I_1d_alongQ[i] = np.nansum(I[:,:,Uini_index:Ufin_index+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i])/(len(N_nanind))
                    I_1d_alongQ_err[i] = ((np.nansum(np.multiply(Ierr[:,:,Uini_index:Ufin_index+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i],Ierr[:,:,Uini_index:Ufin_index+1][Ind_e, Ind_1d_range[0]:Ind_1d_range[-1]+1, i])))**(1/2))/(len(N_nanind))
            # グラフの軸設定
            # X軸の範囲は入力した範囲
            Xlim_min=constants1[0]
            Xlim_max=constants2[0]
            
            if Vnum>=Unum:
                N=Vnum
                if Vini_index<Vfin_index:
                    #Xrange=QU2[Uini_index:Ufin_index+1]
                    Xrange=np.linspace(QV2[Vini_index],QV2[Vfin_index], N)
                elif Vini_index>Vfin_index:
                    #Xrange=QU2[Ufin_index:Uini_index+1]
                    Xrange=np.linspace(QV2[Vfin_index],QV2[Vini_index], N)
                
                # Xrange[0]に最も近い値のインデックスを取得
                index_Xrange_0 = np.abs(QV2 - Xrange[0]).argmin()
                # Xrange[-1]に最も近い値のインデックスを取得
                index_Xrange_last = np.abs(QV2 - Xrange[-1]).argmin()
                
                I_1d_alongQ=np.zeros((len(Xrange)))
                I_1d_alongQ_err=np.zeros((len(Xrange)))
                
                # 理想のXYのテーブルを作成
                Xtable=Xrange
                Ytable=np.zeros((len(Xtable)))
                table=np.zeros((len(Xtable),3))
                
                for i in range(len(Xrange)):
                    if Ufin_index!=Uini_index:
                        Ycenter=(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*Xrange[i]+constants2[0]-(constants1[0]-constants2[0])/(constants1[1]-constants2[1])*constants2[1]
                        Ytable[i]=Ycenter
                    elif Ufin_index==Uini_index:# 傾きが定義できない場合と0の場合を除く
                        Ycenter=QU2[Uini_index]
                        Ytable[i]=constants1[0]
                    table[i]=np.array([v1, v2, v3])* Xtable[i] + np.array([u1, u2, u3])*Ytable[i]
                    ind_1d_range = list(zip(*np.where((Ycenter-pm <= QU2 ) & (QU2 <= Ycenter+pm))))
                    Ind_1d_range = list(np.ravel(ind_1d_range))
                    n_nanind = (list(zip(*np.where(~np.isnan(I[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1])))))
                    N_nanind = list(np.ravel(n_nanind)[::2])
                    I_1d_alongQ[i] = np.nansum(I[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1])/(len(N_nanind))
                    I_1d_alongQ_err[i] = ((np.nansum(np.multiply(Ierr[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1],Ierr[:,index_Xrange_0:index_Xrange_last+1,:][Ind_e, i, Ind_1d_range[0]:Ind_1d_range[-1]+1])))**(1/2))/(len(N_nanind))
                # グラフの軸設定
                # X軸の範囲は入力した範囲
                Xlim_min=constants1[1]
                Xlim_max=constants2[1]
            
            if np.all(np.isnan(I_1d_alongQ)):
                pass
            else:
                    
                ylim_min=0
                ylim_max=np.nanmax(I_1d_alongQ)+np.nanmax(I_1d_alongQ_err)
                    
                # X軸を3等分する
                x_values = np.linspace(constants1[0], constants2[0], 3)
                y_values = np.linspace(constants1[1], constants2[1], 3)
                # x_labels を生成
                x_labels = []
                for U, V in zip(x_values, y_values):
                    label = [round(u1*U + v1*V, 3), round(u2*U + v2*V, 3), round(u3*U + v3*V, 3)]
                    x_labels.append(label)
            
                # エラーバーのグラフを作成
                fig06=plt.figure(adv1DQ)
                ax06 = fig06.gca()
                if Unum>=Vnum:
                    ax06.errorbar(Xrange, I_1d_alongQ, yerr=I_1d_alongQ_err, capsize=10, label = 'ℏω = ' + str(hw_ini) + '~' + str(hw_fin) + ' meV, ±' + str([pm*v1,pm*v2,pm*v3]) + ' (r.l.u.)')
                if Vnum>=Unum:
                    ax06.errorbar(Xrange, I_1d_alongQ, yerr=I_1d_alongQ_err, capsize=10, label = 'ℏω = ' + str(hw_ini) + '~' + str(hw_fin) + ' meV, ±' + str([pm*u1,pm*u2,pm*u3]) + ' (r.l.u.)')
                global I_1d_IvsHKL_E,I_1d_IvsHKL_hkl,I_1d_IvsHKL_HKL
                I_1d_IvsHKL_E = [hw_ini,hw_fin]
                I_1d_IvsHKL_hkl = table.T
                if Unum>=Vnum:
                    I_1d_IvsHKL_HKL = [[-pm*v1,pm*v1],[-pm*v2,pm*v2],[-pm*v3,pm*v3]]
                if Vnum>=Unum:
                    I_1d_IvsHKL_HKL = [[-pm*u1,pm*u1],[-pm*u2,pm*u2],[-pm*u3,pm*u3]]
                at=axistype.get()
                if at==1:
                    plt.yscale('log')
                    if ylim_min==0:
                        ylim_min=np.nanmin(I_1d_alongQ)-np.nanmax(I_1d_alongQ_err)
                ax06.legend()
                #ax06.set_xlim(Xlim_min,Xlim_max) #x軸の範囲を指定
                #ax06.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
                #plt.tick_params(labelsize=20)
                plt.show()
            
# 1Dcut along Qを表示するボタン
button02_ad = ttk.Button(tab_slice,text="I vs HKL",command=advanced_1D_alongQ,width=11)
button02_ad.grid(row=2, column=6,sticky="NSEW")

# 1Dcut along Qを追加表示するボタン
button02_ad = ttk.Button(tab_slice,text="add I vs HKL",command=add_advanced_1D_alongQ,width=11)
button02_ad.grid(row=3, column=6,sticky="NSEW")

#########################################################
# 3D view E direction

# initial値を入力する。 ℏω
lbl_3d_ini_hw = tk.Label(tab_3d,text='',width=6)
lbl_3d_ini_hw.grid(row=3, column=0,pady=1)

lbl_3d_ini_hw = tk.Label(tab_3d,text='initial ℏω',width=8)
lbl_3d_ini_hw.grid(row=0, column=0)
txt_3d_ini_hw = ttk.Entry(tab_3d,width=6)
txt_3d_ini_hw.grid(row=1, column=0,sticky="NSEW")

lbl_3d_ini_U = tk.Label(tab_3d,width=8,textvariable=initialU_label)
lbl_3d_ini_U.grid(row=0, column=1)
txt_3d_ini_U = ttk.Entry(tab_3d,width=6)
txt_3d_ini_U.grid(row=1, column=1,sticky="NSEW")

lbl_3d_ini_V = tk.Label(tab_3d,width=8,textvariable=initialV_label)
lbl_3d_ini_V.grid(row=0, column=2)
txt_3d_ini_V = ttk.Entry(tab_3d,width=6)
txt_3d_ini_V.grid(row=1, column=2,sticky="NSEW")

#constant E mapを動的に表示
def show_3DconEmap():
    # 初期値
    if txt_3d_ini_hw.get()=="":
        sa1 = 0
    else:
        # 一番近い値を探す
        # energylistをNumPy配列に変換
        energylist_np = np.array(energylist)
        sa1 = np.abs(energylist_np - float(txt_3d_ini_hw.get())).argmin()
        
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Umin_txt.get()=="":
        Ulim_min=round(np.min(QU),2)
    else:
        Ulim_min=float(scale_s_Umin_txt.get())
    if scale_s_Umax_txt.get()=="":
        Ulim_max=round(np.max(QU),2)
    else:
        Ulim_max=float(scale_s_Umax_txt.get())
        
    if scale_s_Vmin_txt.get()=="":
        Vlim_min=round(np.min(QV),2)
    else:
        Vlim_min=float(scale_s_Vmin_txt.get())
    if scale_s_Vmax_txt.get()=="":
        Vlim_max=round(np.max(QV),2)
    else:
        Vlim_max=float(scale_s_Vmax_txt.get())
        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=0
    else:
        z_max=float(scale_s_Imax_txt.get())
        
    # カラーバースケールを線形かリニアで

    #図を出力する
    #intensityの範囲
    #fig, ax = plt.figure()
    #axにカラーバーを表示
    fig1, ax = plt.subplots()
    #plt.subplots_adjust(left=0.15, bottom=0.25)
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.25)  # マージンを調整してグラフを中央に配置
    ax.set_xlim(Ulim_min,Ulim_max)
    ax.set_ylim(Vlim_min,Vlim_max)
    at=axistype.get()
    
    # アスペクト比を変更
    ax.set_aspect(NV1/NU1)
    # グリッド線を引く
    gt=gridtype.get()
    if gt == 0:
        #ax.set_axisbelow(True)  # グリッド線を背面に配置
        ax.grid(False)
    elif gt == 1:
        ax.grid(True)
    
    if at==0:
        im=plt.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', vmin=z_min, vmax=z_max)
    elif at==1:
        if z_min==0:
            z_min=np.nanmin(I[I != 0])
            im=plt.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
        else:
            im=plt.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
    #sb1=z_max#初期値を一応セット
    cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))#カラーバーの目盛りについて最小値、中央値、最大値を表示する。
    # カラーバーのタイトルを設定
    cbar.set_label('Intenisty (a.u.)')
    ax.set_xlabel(str(Ulabel))
    ax.set_ylabel(str(Vlabel))
    #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
    #plt.axis('tight')
    #横スライドでエネルギートランスファーを変更、縦スライドで強度の最大値を変更
    ax_a = plt.axes([0.3, 0.02, 0.45, 0.04]) #plt.axes([x, y, width, height] ) 
    sli_a1 = wg.Slider(ax_a, 'ℏω', 0, len(energylist)-1, valinit=sa1,valstep=1, orientation='horizontal')
    ax.text(0.1,1.01,'ℏω = %.3f meV' %energylist[sa1], transform=ax.transAxes)
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(Ulim_min, 3)
    default_xmax = round(Ulim_max, 3)

    default_ymin = round(Vlim_min, 3)
    default_ymax = round(Vlim_max, 3)
    
    default_zmin = round(z_min, 3)
    default_zmax = round(z_max, 3)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.1, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.6, 0.1, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
    zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
    
    def update1(val):
        ax.clear()
        
        xmin_val = float(xmin_box.text)
        xmax_val = float(xmax_box.text)
        ymin_val = float(ymin_box.text)
        ymax_val = float(ymax_box.text)
        zmin_val = float(zmin_box.text)
        zmax_val = float(zmax_box.text)
        
        # グリッド線を引く
        gt=gridtype.get()
        if gt == 0:
            #ax.set_axisbelow(True)  # グリッド線を背面に配置
            ax.grid(False)
        elif gt == 1:
            ax.grid(True)
        sa1 = sli_a1.val
        ax.text(0.1,1.01,'ℏω = %.3f meV' %energylist[sa1], transform=ax.transAxes)
        #ax.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', vmin=z_min, vmax=sb1)
        if at==0:
            ax.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', vmin=zmin_val, vmax=zmax_val)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)  # カラーバーのレンジを更新
            fig1.canvas.draw_idle()
        elif at==1:
            if zmin_val==0:
                ax.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=zmax_val))
                cbar.mappable.set_clim(vmin=np.nanmin(I[I != 0]), vmax=zmax_val)  # カラーバーのレンジを更新
                fig1.canvas.draw_idle()
            else:
                ax.pcolormesh(QU, QV, I[sa1,:,:], cmap='jet', norm = LogNorm(vmin=zmin_val, vmax=zmax_val))
                cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)  # カラーバーのレンジを更新
                fig1.canvas.draw_idle()
        ax.set_xlabel(str(Ulabel))
        ax.set_ylabel(str(Vlabel))
        ax.set_xlim(xmin_val,xmax_val) # x軸のレンジを更新
        ax.set_ylim(ymin_val,ymax_val) # y軸のレンジを更新
    
    # 矢印キーにスライダを対応。上限を超えて表示しないように設定。
    def on_key(event):
        if event.key == 'right':
            new_val_a = min(sli_a1.val + 1, sli_a1.valmax)
            sli_a1.set_val(new_val_a)
        elif event.key == 'left':
            new_val_a = max(sli_a1.val - 1, sli_a1.valmin)
            sli_a1.set_val(new_val_a)
    fig1.canvas.mpl_connect('key_press_event', on_key)
    sli_a1.on_changed(update1)
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            zmin_val = float(zmin_box.text)
            zmax_val = float(zmax_box.text)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
            fig1.canvas.draw_idle()
            update1(None)  # テキストボックスの値が変更されたらグラフを更新する
            return xmin_val,xmax_val,ymin_val,ymax_val,zmin_val,zmax_val
        except ValueError:
            pass
    
    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    zmin_box.on_submit(update_axis_range)
    zmax_box.on_submit(update_axis_range)
    
    plt.show()

# constant E mapを動的に表示するボタン
button17 = ttk.Button(tab_3d,command=show_3DconEmap,textvariable=constE_buttom)
button17.grid(row=2, column=0,sticky="NSEW")

# V方向のconstant Q mapの動的表示の定義
def constQmap_V2():
    # 初期値
    if txt_3d_ini_U.get()=="":
        sa3 = 0
    else:
        # 一番近い値を探す
        sa3 = np.abs(QU2 - float(txt_3d_ini_U.get())).argmin()
    
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Vmin_txt.get()=="":
        Vlim_min=round(np.min(QV),2)
    else:
        Vlim_min=float(scale_s_Vmin_txt.get())
    if scale_s_Vmax_txt.get()=="":
        Vlim_max=round(np.max(QV),2)
    else:
        Vlim_max=float(scale_s_Vmax_txt.get())

    if scale_s_Emin_txt.get()=="":
        Elim_min=round(float(energylist[0]), 2)
    else:
        Elim_min=float(scale_s_Emin_txt.get())
    if scale_s_Emax_txt.get()=="":
        Elim_max=float(round(energylist[-1],2))
    else:
        Elim_max=float(scale_s_Emax_txt.get())

        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=0
    else:
        z_max=float(scale_s_Imax_txt.get())

    # 変数　QU, QV, QU2, QV2, I ,Ierr
    hw_num = int(len(energylist)+1)
    hwlist7=np.zeros(hw_num)
    #hwが1つのときの例外処理として装置分解能の範囲を出力するようにする
    if hw_num==2:
        hwlist7[0] = float(energylist[0]-(ef_tol+0.005))
        hwlist7[1] = float(energylist[-1]+(ef_tol+0.005))
    else:
        hwlist7[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist7[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

    #hwlist5[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
    #hwlist5[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        for ne in range(hw_num-2):
            hwlist7[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2
    #図を出力する
    
    #intensityの範囲
    #fig, ax = plt.figure()
    #axにカラーバーを表示
    fig3, ax = plt.subplots()
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.25)
    at=axistype.get()
    # グリッド線を引く
    gt=gridtype.get()
    if gt == 0:
        #ax.set_axisbelow(True)  # グリッド線を背面に配置
        ax.grid(False)
    elif gt == 1:
        ax.grid(True)
    if at==0:
        im=plt.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', vmin=z_min, vmax=z_max)
    elif at==1:
        if z_min==0:
            z_min=np.nanmin(I[I != 0])
            im=plt.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
        else:
            im=plt.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
    cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
    # カラーバーのタイトルを設定
    cbar.set_label('Intenisty (a.u.)')
    #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
    #plt.axis('tight')
    #横スライドでUを変更、縦スライドで強度の最大値を変更
    ax_a = plt.axes([0.3, 0.02, 0.45, 0.04]) #plt.axes([x, y, width, height] ) 
    sli_a3 = wg.Slider(ax_a, f'{txt_ul.get()}', 0, len(QU2)-1, valinit=sa3,valstep=1, orientation='horizontal')
    ax.text(0.1,1.1,f'{txt_ul.get()} = %.2f r.l.u.' %QU2[sa3], transform=ax.transAxes)
    
    # 図のラベルを作成
    if float(txt12.get())==0:
        if float(txt9.get())==0:
            vl1 = str('0')
        else:
            vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))
    elif float(txt12.get())==1:
        if float(txt9.get())==0:
            vl1 = str(txt_vl.get())
        else:
            vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('+')+str(txt_vl.get())
    elif float(txt12.get())==-1:
        if float(txt9.get())==0:
            vl1 = str('-')+str(txt_vl.get())
        else:
            vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('-')+str(txt_vl.get())
    else:
        try:
            number1 = float(txt12.get())
            if number1.is_integer():#整数である
                if number1<0:#Vベクトルの値が負であった場合
                    vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('-')+str(int(np.abs(float(txt12.get()))))+str(txt_vl.get())
                elif number1>0:#Vベクトルの値が正であった場合
                    vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('+')+str(int(float(txt12.get())))+str(txt_vl.get())
            else:#整数でない
                if number1<0:#Vベクトルの値が負であった場合
                    vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('-')+str(np.abs(float(txt12.get())))+str(txt_vl.get())
                elif number1>0:#Vベクトルの値が正であった場合
                    vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('+')+str(float(txt12.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
            
    if float(txt13.get())==0:
        if float(txt10.get())==0:
            vl2 = str('0')
        else:
            vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))
    elif float(txt13.get())==1:
        if float(txt10.get())==0:
            vl2 = str(txt_vl.get())
        else:
            vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('+')+str(txt_vl.get())
    elif float(txt13.get())==-1:
        if float(txt10.get())==0:
            vl2 = str('-')+str(txt_vl.get())
        else:
            vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('-')+str(txt_vl.get())
    else:
        try:
            number2 = float(txt13.get())
            if number2.is_integer():#整数である
                if number2<0:#Vベクトルの値が負であった場合
                    vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('-')+str(int(np.abs(float(txt13.get()))))+str(txt_vl.get())
                elif number2>0:#Vベクトルの値が正であった場合
                    vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('+')+str(int(float(txt13.get())))+str(txt_vl.get())
            else:#整数でない
                if number2<0:#Vベクトルの値が負であった場合
                    vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('-')+str(np.abs(float(txt13.get())))+str(txt_vl.get())
                elif number2>0:#Vベクトルの値が正であった場合
                    vl2 = str("{:.3f}".format(float(txt10.get())*QU[sa3]))+str('+')+str(float(txt13.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
        
    if float(txt14.get())==0:
        if float(txt11.get())==0:
            vl3 = str('0')
        else:
            vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))
    elif float(txt14.get())==1:
        if float(txt11.get())==0:
            vl3 = str(txt_vl.get())
        else:
            vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('+')+str(txt_vl.get())
    elif float(txt14.get())==-1:
        if float(txt11.get())==0:
            vl3 = str('-')+str(txt_vl.get())
        else:
            vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('-')+str(txt_vl.get())
    else:
        try:
            number3 = float(txt14.get())
            if number3.is_integer():#整数である
                if number3<0:#Vベクトルの値が負であった場合
                    vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('-')+str(int(np.abs(float(txt14.get()))))+str(txt_vl.get())
                elif number3>0:#Vベクトルの値が正であった場合
                    vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('+')+str(int(float(txt14.get())))+str(txt_vl.get())
            else:#整数でない
                if number3<0:#Vベクトルの値が負であった場合
                    vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('-')+str(np.abs(float(txt14.get())))+str(txt_vl.get())
                elif number3>0:#Vベクトルの値が正であった場合
                    vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('+')+str(float(txt14.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
    
    Vlabel3 = (f"({vl1},{vl2},{vl3})")
    
    ax.set_xlabel(str(Vlabel))
    ax.set_ylabel("ℏω (meV)")
    ax.set_xlim(Vlim_min,Vlim_max)
    ax.set_ylim(Elim_min,Elim_max)
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(Vlim_min, 3)
    default_xmax = round(Vlim_max, 3)

    default_ymin = round(Elim_min, 3)
    default_ymax = round(Elim_max, 3)
    
    default_zmin = round(z_min, 3)
    default_zmax = round(z_max, 3)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.10, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.6, 0.10, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
    zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
    
    
    def update6(val):
        ax.clear()
        
        xmin_val = float(xmin_box.text)
        xmax_val = float(xmax_box.text)
        ax.set_xlim(xmin_val, xmax_val)
        ymin_val = float(ymin_box.text)
        ymax_val = float(ymax_box.text)
        ax.set_ylim(ymin_val, ymax_val)
        zmin_val = float(zmin_box.text)
        zmax_val = float(zmax_box.text)
        
        # グリッド線を引く
        gt=gridtype.get()
        if gt == 0:
            #ax.set_axisbelow(True)  # グリッド線を背面に配置
            ax.grid(False)
        elif gt == 1:
            ax.grid(True)
        sa3 = sli_a3.val
        ax.text(0.1,1.1,f'{txt_ul.get()} = %.2f r.l.u.' %QU2[sa3], transform=ax.transAxes)
        #ax.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', vmin=z_min, vmax=sb3)
        if at==0:
            ax.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', vmin=zmin_val, vmax=zmax_val)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)  # カラーバーのレンジを更新
        elif at==1:
            if zmin_val==0:
                ax.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=zmax_val))
                cbar.mappable.set_clim(vmin=np.nanmin(I[I != 0]), vmax=zmax_val)  # カラーバーのレンジを更新
            else:
                ax.pcolormesh(QV, hwlist7, I[:,:,sa3], cmap='jet', norm = LogNorm(vmin=zmin_val, vmax=zmax_val))
                cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)  # カラーバーのレンジを更新
                
        # 図のラベルを作成
        if float(txt12.get())==0:
            if float(txt9.get())==0:
                vl1 = str('0')
            else:
                vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))
        elif float(txt12.get())==1:
            if float(txt9.get())==0:
                vl1 = str(txt_vl.get())
            else:
                vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('+')+str(txt_vl.get())
        elif float(txt12.get())==-1:
            if float(txt9.get())==0:
                vl1 = str('-')+str(txt_vl.get())
            else:
                vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('-')+str(txt_vl.get())
        else:
            try:
                number1 = float(txt12.get())
                if number1.is_integer():#整数である
                    if number1<0:#Vベクトルの値が負であった場合
                        vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('-')+str(int(np.abs(float(txt12.get()))))+str(txt_vl.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('+')+str(int(float(txt12.get())))+str(txt_vl.get())
                else:#整数でない
                    if number1<0:#Vベクトルの値が負であった場合
                        vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('-')+str(np.abs(float(txt12.get())))+str(txt_vl.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        vl1 = str("{:.3f}".format(float(txt9.get())*QU2[sa3]))+str('+')+str(float(txt12.get()))+str(txt_vl.get())
            except ValueError:#整数でない
                pass
                
        if float(txt13.get())==0:
            if float(txt10.get())==0:
                vl2 = str('0')
            else:
                vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))
        elif float(txt13.get())==1:
            if float(txt10.get())==0:
                vl2 = str(txt_vl.get())
            else:
                vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('+')+str(txt_vl.get())
        elif float(txt13.get())==-1:
            if float(txt10.get())==0:
                vl2 = str('-')+str(txt_vl.get())
            else:
                vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('-')+str(txt_vl.get())
        else:
            try:
                number2 = float(txt13.get())
                if number2.is_integer():#整数である
                    if number2<0:#Vベクトルの値が負であった場合
                        vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('-')+str(int(np.abs(float(txt13.get()))))+str(txt_vl.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('+')+str(int(float(txt13.get())))+str(txt_vl.get())
                else:#整数でない
                    if number2<0:#Vベクトルの値が負であった場合
                        vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('-')+str(np.abs(float(txt13.get())))+str(txt_vl.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        vl2 = str("{:.3f}".format(float(txt10.get())*QU2[sa3]))+str('+')+str(float(txt13.get()))+str(txt_vl.get())
            except ValueError:#整数でない
                pass
            
        if float(txt14.get())==0:
            if float(txt11.get())==0:
                vl3 = str('0')
            else:
                vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))
        elif float(txt14.get())==1:
            if float(txt11.get())==0:
                vl3 = str(txt_vl.get())
            else:
                vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('+')+str(txt_vl.get())
        elif float(txt14.get())==-1:
            if float(txt11.get())==0:
                vl3 = str('-')+str(txt_vl.get())
            else:
                vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('-')+str(txt_vl.get())
        else:
            try:
                number3 = float(txt14.get())
                if number3.is_integer():#整数である
                    if number3<0:#Vベクトルの値が負であった場合
                        vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('-')+str(int(np.abs(float(txt14.get()))))+str(txt_vl.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('+')+str(int(float(txt14.get())))+str(txt_vl.get())
                else:#整数でない
                    if number3<0:#Vベクトルの値が負であった場合
                        vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('-')+str(np.abs(float(txt14.get())))+str(txt_vl.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        vl3 = str("{:.3f}".format(float(txt11.get())*QU2[sa3]))+str('+')+str(float(txt14.get()))+str(txt_vl.get())
            except ValueError:#整数でない
                pass
        
        Vlabel3 = (f"({vl1},{vl2},{vl3})")
        
        ax.set_xlabel(str(Vlabel3))
        ax.set_ylabel("ℏω (meV)")
        ax.set_xlim(xmin_val,xmax_val)
        ax.set_ylim(ymin_val,ymax_val)
        plt.draw()
    # 矢印キーにスライダを対応。
    def on_key(event):
        if event.key == 'right':
            new_val_a = min(sli_a3.val + 1, sli_a3.valmax)
            sli_a3.set_val(new_val_a)
        elif event.key == 'left':
            new_val_a = max(sli_a3.val - 1, sli_a3.valmin)
            sli_a3.set_val(new_val_a)
    fig3.canvas.mpl_connect('key_press_event', on_key)
    sli_a3.on_changed(update6)
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            zmin_val = float(zmin_box.text)
            zmax_val = float(zmax_box.text)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
            fig3.canvas.draw_idle()
            update6(None)
            return xmin_val,xmax_val,ymin_val,ymax_val,zmin_val,zmax_val
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    zmin_box.on_submit(update_axis_range)
    zmax_box.on_submit(update_axis_range)
    
    plt.show()

# V方向にconstantQカットした図を動的に表示するボタン
button15 = ttk.Button(tab_3d,command=constQmap_V2,textvariable=constV_buttom)
button15.grid(row=2, column=1,sticky="NSEW")

# U方向のconstant Q mapの動的な表示の定義
def constQmap_U2():
    # 初期値
    if txt_3d_ini_V.get()=="":
        sa2 = 0
    else:
        # 一番近い値を探す
        sa2 = np.abs(QV2 - float(txt_3d_ini_V.get())).argmin()
    
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Umin_txt.get()=="":
        Ulim_min=round(np.min(QU),2)
    else:
        Ulim_min=float(scale_s_Umin_txt.get())
    if scale_s_Umax_txt.get()=="":
        Ulim_max=round(np.max(QU),2)
    else:
        Ulim_max=float(scale_s_Umax_txt.get())

    if scale_s_Emin_txt.get()=="":
        Elim_min=round(float(energylist[0]), 2)
    else:
        Elim_min=float(scale_s_Emin_txt.get())
    if scale_s_Emax_txt.get()=="":
        Elim_max=float(round(energylist[-1],2))
    else:
        Elim_max=float(scale_s_Emax_txt.get())

        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=0
    else:
        z_max=float(scale_s_Imax_txt.get())

    # 変数　QU, QV2, QU2, QV2, I ,Ierr
    hw_num = int(len(energylist)+1)
    hwlist8=np.zeros(hw_num)
    #hwが1つのときの例外処理として装置分解能の範囲を出力するようにする
    if hw_num==2:
        hwlist8[0] = float(energylist[0]-(ef_tol+0.005))
        hwlist8[1] = float(energylist[-1]+(ef_tol+0.005))
    else:
        hwlist8[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist8[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        #hwlist5[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        #hwlist5[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        for ne in range(hw_num-2):
            hwlist8[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2
    
    #図を出力する
    #intensityの範囲
    #fig, ax = plt.figure()
    #axにカラーバーを表示
    fig2, ax = plt.subplots()
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.25)
    #im=plt.pcolormesh(QU, hwlist8, I[:,0,:], cmap='jet', vmin=z_min, vmax=z_max)
    at=axistype.get()
    # グリッド線を引く
    gt=gridtype.get()
    if gt == 0:
        #ax.set_axisbelow(True)  # グリッド線を背面に配置
        ax.grid(False)
    elif gt == 1:
        ax.grid(True)
    if at==0:
        im=plt.pcolormesh(QU, hwlist8, I[:,sa2,:], cmap='jet', vmin=z_min, vmax=z_max)
    elif at==1:
        if z_min==0:
            z_min=np.nanmin(I[I != 0])
            im=plt.pcolormesh(QU, hwlist8, I[:,sa2,:], cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
        else:
            im=plt.pcolormesh(QU, hwlist8, I[:,sa2,:], cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
    #sb2=z_max#初期値を一応セット
    cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
    # カラーバーのタイトルを設定
    cbar.set_label('Intenisty (a.u.)')
    #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
    #plt.axis('tight')
    #横スライドでVを変更、縦スライドで強度の最大値を変更
    ax_a = plt.axes([0.3, 0.02, 0.45, 0.04]) #plt.axes([x, y, width, height] ) 
    sli_a2 = wg.Slider(ax_a, f'{txt_vl.get()}', 0, len(QV2)-1, valinit=sa2,valstep=1, orientation='horizontal')
    ax.text(0.1,1.1,f'{txt_vl.get()} = %.2f (r.l.u.))' %QV2[sa2], transform=ax.transAxes)
    # 図のラベルを作成
    if float(txt9.get())==0:
        if float(txt12.get())==0:
            ul1 = str('0')
        else:
            ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))
    elif float(txt9.get())==1:
        if float(txt12.get())==0:
            ul1 = str(txt_ul.get())
        else:
            ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('+')+str(txt_ul.get())
    elif float(txt9.get())==-1:
        if float(txt12.get())==0:
            ul1 = str('-')+str(txt_ul.get())
        else:
            ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('-')+str(txt_ul.get())
    else:
        try:
            number1 = float(txt9.get())
            if number1.is_integer():#整数である
                if number1<0:#Vベクトルの値が負であった場合
                    ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('-')+str(int(np.abs(float(txt9.get()))))+str(txt_ul.get())
                elif number1>0:#Vベクトルの値が正であった場合
                    ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('+')+str(int(float(txt9.get())))+str(txt_ul.get())
            else:#整数でない
                if number1<0:#Vベクトルの値が負であった場合
                    ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('-')+str(np.abs(float(txt9.get())))+str(txt_ul.get())
                elif number1>0:#Vベクトルの値が正であった場合
                    ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('+')+str(float(txt9.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
        
    if float(txt10.get())==0:
        if float(txt13.get())==0:
            ul2 = str('0')
        else:
            ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))
    elif float(txt10.get())==1:
        if float(txt13.get())==0:
            ul2 = str(txt_ul.get())
        else:
            ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('+')+str(txt_ul.get())
    elif float(txt10.get())==-1:
        if float(txt13.get())==0:
            ul2 = str('-')+str(txt_ul.get())
        else:
            ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('-')+str(txt_ul.get())
    else:
        try:
            number2 = float(txt10.get())
            if number2.is_integer():#整数である
                if number2<0:#Vベクトルの値が負であった場合
                    ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('-')+str(int(np.abs(float(txt10.get()))))+str(txt_ul.get())
                elif number2>0:#Vベクトルの値が正であった場合
                    ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('+')+str(int(float(txt10.get())))+str(txt_ul.get())
            else:#整数でない
                if number2<0:#Vベクトルの値が負であった場合
                    ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('-')+str(np.abs(float(txt10.get())))+str(txt_ul.get())
                elif number2>0:#Vベクトルの値が正であった場合
                    ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('+')+str(float(txt10.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
        
        
    if float(txt11.get())==0:
        if float(txt14.get())==0:
            ul3 = str('0')
        else:
            ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))
    elif float(txt11.get())==1:
        if float(txt14.get())==0:
            ul3 = str(txt_ul.get())
        else:
            ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('+')+str(txt_ul.get())
    elif float(txt11.get())==-1:
        if float(txt14.get())==0:
            ul3 = str('-')+str(txt_ul.get())
        else:
            ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('-')+str(txt_ul.get())
    else:
        try:
            number3 = float(txt11.get())
            if number3.is_integer():#整数である
                if number3<0:#Vベクトルの値が負であった場合
                    ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('-')+str(int(np.abs(float(txt11.get()))))+str(txt_ul.get())
                elif number3>0:#Vベクトルの値が正であった場合
                    ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('+')+str(int(float(txt11.get())))+str(txt_ul.get())
            else:#整数でない
                if number3<0:#Vベクトルの値が負であった場合
                    ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('-')+str(np.abs(float(txt11.get())))+str(txt_ul.get())
                elif number3>0:#Vベクトルの値が正であった場合
                    ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('+')+str(float(txt11.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass

    Ulabel3 = (f"({ul1},{ul2},{ul3})")
    
    ax.set_xlabel(str(Ulabel3))
    ax.set_ylabel("ℏω (meV)")
    ax.set_xlim(Ulim_min,Ulim_max)
    ax.set_ylim(Elim_min,Elim_max)
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(Ulim_min, 3)
    default_xmax = round(Ulim_max, 3)

    default_ymin = round(Elim_min, 3)
    default_ymax = round(Elim_max, 3)
    
    default_zmin = round(z_min, 3)
    default_zmax = round(z_max, 3)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.10, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.6, 0.10, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
    zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
    
    def update7(val):
        ax.clear()
        
        xmin_val = float(xmin_box.text)
        xmax_val = float(xmax_box.text)
        ymin_val = float(ymin_box.text)
        ymax_val = float(ymax_box.text)
        zmin_val = float(zmin_box.text)
        zmax_val = float(zmax_box.text)
        
        # グリッド線を引く
        gt=gridtype.get()
        if gt == 0:
            #ax.set_axisbelow(True)  # グリッド線を背面に配置
            ax.grid(False)
        elif gt == 1:
            ax.grid(True)
        sa2 = sli_a2.val
        ax.text(0.1,1.1,f'{txt_vl.get()} = %.2f r.l.u.' %QV2[sa2], transform=ax.transAxes)
        #ax.pcolormesh(QU, hwlist8, I[:,sa,:], cmap='jet', vmin=z_min, vmax=sb2)
        if at==0:
            ax.pcolormesh(QU, hwlist8, I[:,sa2,:], cmap='jet', vmin=zmin_val, vmax=zmax_val)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)  # カラーバーのレンジを更新
        elif at==1:
            if zmin_val==0:
                ax.pcolormesh(QU, hwlist8, I[:,sa2,:], cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=zmax_val))
                cbar.mappable.set_clim(vmin=np.nanmin(I[I != 0]), vmax=zmax_val)  # カラーバーのレンジを更新
            else:
                ax.pcolormesh(QU, hwlist8, I[:,sa2,:], cmap='jet', norm = LogNorm(vmin=zmin_val, vmax=zmax_val))
                cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)  # カラーバーのレンジを更新
                
        # 図のラベルを作成
        if float(txt9.get())==0:
            if float(txt12.get())==0:
                ul1 = str('0')
            else:
                ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))
        elif float(txt9.get())==1:
            if float(txt12.get())==0:
                ul1 = str(txt_ul.get())
            else:
                ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('+')+str(txt_ul.get())
        elif float(txt9.get())==-1:
            if float(txt12.get())==0:
                ul1 = str('-')+str(txt_ul.get())
            else:
                ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('-')+str(txt_ul.get())
        else:
            try:
                number1 = float(txt9.get())
                if number1.is_integer():#整数である
                    if number1<0:#Vベクトルの値が負であった場合
                        ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('-')+str(int(np.abs(float(txt9.get()))))+str(txt_ul.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('+')+str(int(float(txt9.get())))+str(txt_ul.get())
                else:#整数でない
                    if number1<0:#Vベクトルの値が負であった場合
                        ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('-')+str(np.abs(float(txt9.get())))+str(txt_ul.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        ul1 = str("{:.3f}".format(float(txt12.get()) * QV2[sa2]))+str('+')+str(float(txt9.get()))+str(txt_ul.get())
            except ValueError:#整数でない
                pass
            
        if float(txt10.get())==0:
            if float(txt13.get())==0:
                ul2 = str('0')
            else:
                ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))
        elif float(txt10.get())==1:
            if float(txt13.get())==0:
                ul2 = str(txt_ul.get())
            else:
                ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('+')+str(txt_ul.get())
        elif float(txt10.get())==-1:
            if float(txt13.get())==0:
                ul2 = str('-')+str(txt_ul.get())
            else:
                ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('-')+str(txt_ul.get())
        else:
            try:
                number2 = float(txt10.get())
                if number2.is_integer():#整数である
                    if number2<0:#Vベクトルの値が負であった場合
                        ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('-')+str(int(np.abs(float(txt10.get()))))+str(txt_ul.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('+')+str(int(float(txt10.get())))+str(txt_ul.get())
                else:#整数でない
                    if number2<0:#Vベクトルの値が負であった場合
                        ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('-')+str(np.abs(float(txt10.get())))+str(txt_ul.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        ul2 = str("{:.3f}".format(float(txt13.get()) * QV2[sa2]))+str('+')+str(float(txt10.get()))+str(txt_ul.get())
            except ValueError:#整数でない
                pass
            
        if float(txt11.get())==0:
            if float(txt14.get())==0:
                ul3 = str('0')
            else:
                ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))
        elif float(txt11.get())==1:
            if float(txt14.get())==0:
                ul3 = str(txt_ul.get())
            else:
                ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('+')+str(txt_ul.get())
        elif float(txt11.get())==-1:
            if float(txt14.get())==0:
                ul3 = str('-')+str(txt_ul.get())
            else:
                ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('-')+str(txt_ul.get())
        else:
            try:
                number3 = float(txt11.get())
                if number3.is_integer():#整数である
                    if number3<0:#Vベクトルの値が負であった場合
                        ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('-')+str(int(np.abs(float(txt11.get()))))+str(txt_ul.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('+')+str(int(float(txt11.get())))+str(txt_ul.get())
                else:#整数でない
                    if number3<0:#Vベクトルの値が負であった場合
                        ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('-')+str(np.abs(float(txt11.get())))+str(txt_ul.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        ul3 = str("{:.3f}".format(float(txt14.get()) * QV2[sa2]))+str('+')+str(float(txt11.get()))+str(txt_ul.get())
            except ValueError:#整数でない
                pass

        Ulabel3 = (f"({ul1},{ul2},{ul3})")
        ax.set_xlabel(str(Ulabel3))
        ax.set_ylabel("ℏω (meV)")
        ax.set_xlim(xmin_val,xmax_val)
        ax.set_ylim(ymin_val,ymax_val)
        #cbar.mappable.set_clim(vmin=z_min, vmax=sb2)  # カラーバーのレンジを更新
        plt.draw()
    # 矢印キーにスライダを対応。
    def on_key(event):
        if event.key == 'right':
            new_val_a = min(sli_a2.val + 1, sli_a2.valmax)
            sli_a2.set_val(new_val_a)
        elif event.key == 'left':
            new_val_a = max(sli_a2.val - 1, sli_a2.valmin)
            sli_a2.set_val(new_val_a)
    fig2.canvas.mpl_connect('key_press_event', on_key)
    sli_a2.on_changed(update7)
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            zmin_val = float(zmin_box.text)
            zmax_val = float(zmax_box.text)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
            fig2.canvas.draw_idle()
            update7(None)
            return xmin_val,xmax_val,ymin_val,ymax_val,zmin_val,zmax_val
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    zmin_box.on_submit(update_axis_range)
    zmax_box.on_submit(update_axis_range)
    
    plt.show()

# U方向にconstantQカットした図を動的に表示するボタン
button16 = ttk.Button(tab_3d,command=constQmap_U2,textvariable=constU_buttom)
button16.grid(row=2, column=2,sticky="NSEW")
##############################################
# 2D view const E cut
# tab_2dに配置するウィジェットの作成。constant E mapの表示
# 取り出すEの範囲を指定する欄の整備
lbl_2d_1e = tk.Label(tab_2d,text='ℏω',width=6)
lbl_2d_1e.grid(row=0, column=0,sticky="NSEW")
lbl_2d_2e = tk.Label(tab_2d,text='±ℏω',width=6)
lbl_2d_2e.grid(row=0, column=1,sticky="NSEW")
txt_2d_1e = ttk.Entry(tab_2d,width=6)
txt_2d_1e.insert(0,0)
txt_2d_1e.grid(row=1, column=0,sticky="NSEW")
txt_2d_2e = ttk.Entry(tab_2d,width=6)
txt_2d_2e.insert(0,0.1)
txt_2d_2e.grid(row=1, column=1,sticky="NSEW")
lbl_2d_d = tk.Label(tab_2d,text='',width=6)
lbl_2d_d.grid(row=3, column=0,pady=1,sticky="NSEW")

# tab_2dに配置するウィジェットの作成。V方向のconstant Q mapの表示と1次元カット
# 取り出すEの範囲を指定する欄の整備
lbl_2d_1v = tk.Label(tab_2d,width=6,textvariable=U_lavel)
lbl_2d_1v.grid(row=0, column=2,sticky="NSEW")
lbl_2d_2v = tk.Label(tab_2d,width=6,textvariable=pmU_lavel)
lbl_2d_2v.grid(row=0, column=3,sticky="NSEW")
txt_2d_1v = ttk.Entry(tab_2d,width=6)
txt_2d_1v.insert(0,'0')
txt_2d_1v.grid(row=1, column=2,sticky="NSEW")
txt_2d_2v = ttk.Entry(tab_2d,width=6)
txt_2d_2v.insert(0,'0.1')
txt_2d_2v.grid(row=1, column=3,sticky="NSEW")

# tab_2dに配置するウィジェットの作成。U方向のconstant Q mapの表示
# 取り出すEの範囲を指定する欄の整備
lbl_2d_1u = tk.Label(tab_2d,width=6,textvariable=V_lavel)
lbl_2d_1u.grid(row=0, column=4,sticky="NSEW")
lbl_2d_2u = tk.Label(tab_2d,width=6,textvariable=pmV_lavel)
lbl_2d_2u.grid(row=0, column=5,sticky="NSEW")
txt_2d_1u = ttk.Entry(tab_2d,width=6)
txt_2d_1u.insert(0,'0')
txt_2d_1u.grid(row=1, column=4,sticky="NSEW")
txt_2d_2u = ttk.Entry(tab_2d,width=6)
txt_2d_2u.insert(0,'0.1')
txt_2d_2u.grid(row=1, column=5,sticky="NSEW")

# constEmap表示の定義
def constEmap():
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Umin_txt.get()=="":
        Ulim_min=round(np.min(QU),2)
    else:
        Ulim_min=float(scale_s_Umin_txt.get())
    if scale_s_Umax_txt.get()=="":
        Ulim_max=round(np.max(QU),2)
    else:
        Ulim_max=float(scale_s_Umax_txt.get())
        
    if scale_s_Vmin_txt.get()=="":
        Vlim_min=round(np.min(QV),2)
    else:
        Vlim_min=float(scale_s_Vmin_txt.get())
    if scale_s_Vmax_txt.get()=="":
        Vlim_max=round(np.max(QV),2)
    else:
        Vlim_max=float(scale_s_Vmax_txt.get())
        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=0
    else:
        z_max=float(scale_s_Imax_txt.get())
    
    Ind_e = None
    hwlist1 = None
    Ec=float(txt_2d_1e.get())
    Epm=float(txt_2d_2e.get())
    if Epm < 0:
        return

    hwlist1=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist1[ne] = float(energylist[ne])

    # 条件を満たすエネルギーの面を指定
    if Epm==0:
        Ind_e = [np.abs(hwlist1 - Ec).argmin()]
    else:
        ind_e = list(zip(*np.where(( Ec - Epm <=  hwlist1 ) & (  hwlist1 <= Ec + Epm ))))
        Ind_e = list(np.ravel(ind_e))

    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_e)!=0:
        global I_ce,Ierr_ce
        # 旧コード
        #I_ce = np.nanmean(I[ind_e],axis=0)
        #Ierr_ce = ((np.nansum(Ierr[ind_e]*Ierr[ind_e],axis=0))**(1/2))/len(ind_e)

        # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
        I_ce=np.zeros((len(QV)-1,len(QU)-1))
        Ierr_ce=np.zeros((len(QV)-1,len(QU)-1))

        #I[ll,nn,mm]=I[hw,V,U]の順番でリスト

        for nn in range(len(QV)-1):
            for mm in range(len(QU)-1):
                n_nanind = (list(zip(*np.where(~np.isnan(I[Ind_e,nn,mm])))))
                N_nanind = list(np.ravel(n_nanind)[::1])
                if N_nanind:
                    I_ce[nn,mm] = np.nansum(I[Ind_e,nn,mm])/(len(N_nanind))
                    Ierr_ce[nn,mm] = ((np.nansum(np.multiply(Ierr[Ind_e,nn,mm],Ierr[Ind_e,nn,mm])))**(1/2))/(len(N_nanind))
                else:
                    I_ce[nn,mm] = np.nan
                    Ierr_ce[nn,mm] = np.nan
                 
        #図を出力する
        #intensityの範囲
        #fig, ax = plt.figure()
        #axにカラーバーを表示
        fig4, ax = plt.subplots()
        #plt.subplots_adjust(left=0.15, bottom=0.2)
        plt.subplots_adjust(left=0.30, right=0.75, bottom=0.2)  # マージンを調整してグラフを中央に配置
        # アスペクト比を変更
        ax.set_aspect(NV1/NU1)
        # グリッド線を引く
        gt=gridtype.get()
        if gt == 0:
            #ax.set_axisbelow(True)  # グリッド線を背面に配置
            ax.grid(False)
        elif gt == 1:
            ax.grid(True)
        #im=plt.pcolormesh(QU, QV, I_ce, cmap='jet', vmin=z_min, vmax=z_max)
        at=axistype.get()
        if at==0:
            im=plt.pcolormesh(QU, QV, I_ce, cmap='jet', vmin=z_min, vmax=z_max)
            
        elif at==1:
            if z_min==0:
                z_min=np.nanmin(I[I != 0])
                im=plt.pcolormesh(QU, QV, I_ce, cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
            else:
                im=plt.pcolormesh(QU, QV, I_ce, cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
        #sb4=z_max#初期値を一応セット
        cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
        # カラーバーのタイトルを設定
        cbar.set_label('Intenisty (a.u.)')
        ax.text(0.1,1.1,f'ℏω = %.3f ± %.3f meV' %(Ec,Epm), transform=ax.transAxes)
        ax.set_xlabel(str(Ulabel))
        ax.set_ylabel(str(Vlabel))
        ax.set_xlim(Ulim_min,Ulim_max)
        ax.set_ylim(Vlim_min,Vlim_max)
        #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
        #plt.axis('tight')
        
        global Erange_2d_VvsU,Vrange_2d_VvsU,Urange_2d_VvsU
        Erange_2d_VvsU = [Ec - Epm,Ec + Epm]
        Urange_2d_VvsU = [float(txt9.get())*QU2,float(txt10.get())*QU2,float(txt11.get())*QU2]
        Vrange_2d_VvsU = [float(txt12.get())*QV2,float(txt13.get())*QV2,float(txt14.get())*QV2]
        
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_xmin = round(Ulim_min, 3)
        default_xmax = round(Ulim_max, 3)

        default_ymin = round(Vlim_min, 3)
        default_ymax = round(Vlim_max, 3)
        
        default_zmin = round(z_min, 3)
        default_zmax = round(z_max, 3)

        # テキストボックスを作成して最小値と最大値を設定
        xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
        xmax_box = TextBox(plt.axes([0.6, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
        zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                xmin_val = float(xmin_box.text)
                xmax_val = float(xmax_box.text)
                ax.set_xlim(xmin_val, xmax_val)
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax.set_ylim(ymin_val, ymax_val)
                zmin_val = float(zmin_box.text)
                zmax_val = float(zmax_box.text)
                cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
                fig4.canvas.draw_idle()
            except ValueError:
                pass

        xmin_box.on_submit(update_axis_range)
        xmax_box.on_submit(update_axis_range)
        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        zmin_box.on_submit(update_axis_range)
        zmax_box.on_submit(update_axis_range)
        
        plt.show()
    else:
        pass     

#constant E mapファイルの読み込みのボタンの作成
button8 = ttk.Button(tab_2d,command=constEmap,width=12,textvariable=constE_buttom)
button8.grid(row=2, column=0,columnspan=2,sticky="NSEW")

# V方向のconstant Q mapの表示の定義
def constQmap_V():
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Vmin_txt.get()=="":
        Vlim_min=round(np.min(QV),2)
    else:
        Vlim_min=float(scale_s_Vmin_txt.get())
    if scale_s_Vmax_txt.get()=="":
        Vlim_max=round(np.max(QV),2)
    else:
        Vlim_max=float(scale_s_Vmax_txt.get())

    if scale_s_Emin_txt.get()=="":
        Elim_min=round(float(energylist[0]), 2)
    else:
        Elim_min=float(scale_s_Emin_txt.get())
    if scale_s_Emax_txt.get()=="":
        Elim_max=float(round(energylist[-1],2))
    else:
        Elim_max=float(scale_s_Emax_txt.get())

    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=0
    else:
        z_max=float(scale_s_Imax_txt.get())
        
    Uc=float(txt_2d_1v.get())
    Upm=float(txt_2d_2v.get())
    # 変数　QU, QV, QU2, QV2, I ,Ierr
    hw_num = int(len(energylist)+1)
    global hwlist4
    hwlist4=np.zeros(hw_num)
    #hwが1つのときの例外処理として装置分解能の範囲を出力するようにする
    if hw_num==2:
        hwlist4[0] = float(energylist[0]-(ef_tol+0.005))
        hwlist4[1] = float(energylist[-1]+(ef_tol+0.005))
    else:
        hwlist4[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist4[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))
        for ne in range(hw_num-2):
            hwlist4[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2
    if Upm==0:
        Ind_cQV = [np.abs(QU2 - Uc).argmin()]
    else:
        ind_cQV = list(zip(*np.where((Uc - Upm <= QU2 ) & (QU2 <= Uc + Upm))))
        Ind_cQV = list(np.ravel(ind_cQV))
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_cQV)!=0:
        global I_hwV,Ierr_hwV
        #I_hwV = np.nanmean(I[:,:,ind_cQV],axis = 2)
        #Ierr_hwV = ((np.nansum(Ierr[:,:,ind_cQV]*Ierr[:,:,ind_cQV],axis = 2))**(1/2))/len(ind_cQV)

        # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
        I_hwV=np.zeros((len(energylist),len(QV)-1))
        Ierr_hwV=np.zeros((len(energylist),len(QV)-1))
        for ll in range(len(energylist)):
            for nn in range(len(QV)-1):
                n_nanind = (list(zip(*np.where(~np.isnan(I[ll,nn,Ind_cQV])))))
                N_nanind = list(np.ravel(n_nanind)[::1])
                if N_nanind:
                    I_hwV[ll,nn] = np.nansum(I[ll,nn,Ind_cQV])/(len(N_nanind))     
                    Ierr_hwV[ll,nn] = ((np.nansum(np.multiply(Ierr[ll,nn,Ind_cQV],Ierr[ll,nn,Ind_cQV])))**(1/2))/(len(N_nanind))
                else:
                    I_hwV[ll,nn] = np.nan
                    Ierr_hwV[ll,nn] = np.nan
                    
        # 図のラベルを作成
        if float(txt12.get())==0:
            if float(txt9.get())==0:
                vl1 = str('0')
            else:
                vl1 = str(float(txt9.get())*Uc)
        elif float(txt12.get())==1:
            if float(txt9.get())==0:
                vl1 = str(txt_vl.get())
            else:
                vl1 = str(float(txt9.get())*Uc)+str('+')+str(txt_vl.get())
        elif float(txt12.get())==-1:
            if float(txt9.get())==0:
                vl1 = str('-')+str(txt_vl.get())
            else:
                vl1 = str(float(txt9.get())*Uc)+str('-')+str(txt_vl.get())
        else:
            try:
                number1 = float(txt12.get())
                if number1.is_integer():#整数である
                    if number1<0:#Vベクトルの値が負であった場合
                        vl1 = str(float(txt9.get())*Uc)+str('-')+str(int(np.abs(float(txt12.get()))))+str(txt_vl.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        vl1 = str(float(txt9.get())*Uc)+str('+')+str(int(float(txt12.get())))+str(txt_vl.get())
                else:#整数でない
                    if number1<0:#Vベクトルの値が負であった場合
                        vl1 = str(float(txt9.get())*Uc)+str('-')+str(np.abs(float(txt12.get())))+str(txt_vl.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        vl1 = str(float(txt9.get())*Uc)+str('+')+str(float(txt12.get()))+str(txt_vl.get())
            except ValueError:#整数でない
                pass
                
        if float(txt13.get())==0:
            if float(txt10.get())==0:
                vl2 = str('0')
            else:
                vl2 = str(float(txt10.get())*Uc)
        elif float(txt13.get())==1:
            if float(txt10.get())==0:
                vl2 = str(txt_vl.get())
            else:
                vl2 = str(float(txt10.get())*Uc)+str('+')+str(txt_vl.get())
        elif float(txt13.get())==-1:
            if float(txt10.get())==0:
                vl2 = str('-')+str(txt_vl.get())
            else:
                vl2 = str(float(txt10.get())*Uc)+str('-')+str(txt_vl.get())
        else:
            try:
                number2 = float(txt13.get())
                if number2.is_integer():#整数である
                    if number2<0:#Vベクトルの値が負であった場合
                        vl2 = str(float(txt10.get())*Uc)+str('-')+str(int(np.abs(float(txt13.get()))))+str(txt_vl.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        vl2 = str(float(txt10.get())*Uc)+str('+')+str(int(float(txt13.get())))+str(txt_vl.get())
                else:#整数でない
                    if number2<0:#Vベクトルの値が負であった場合
                        vl2 = str(float(txt10.get())*Uc)+str('-')+str(np.abs(float(txt13.get())))+str(txt_vl.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        vl2 = str(float(txt10.get())*Uc)+str('+')+str(float(txt13.get()))+str(txt_vl.get())
            except ValueError:#整数でない
                pass
            
        if float(txt14.get())==0:
            if float(txt11.get())==0:
                vl3 = str('0')
            else:
                vl3 = str(float(txt11.get())*Uc)
        elif float(txt14.get())==1:
            if float(txt11.get())==0:
                vl3 = str(txt_vl.get())
            else:
                vl3 = str(float(txt11.get())*Uc)+str('+')+str(txt_vl.get())
        elif float(txt14.get())==-1:
            if float(txt11.get())==0:
                vl3 = str('-')+str(txt_vl.get())
            else:
                vl3 = str(float(txt11.get())*Uc)+str('-')+str(txt_vl.get())
        else:
            try:
                number3 = float(txt14.get())
                if number3.is_integer():#整数である
                    if number3<0:#Vベクトルの値が負であった場合
                        vl3 = str(float(txt11.get())*Uc)+str('-')+str(int(np.abs(float(txt14.get()))))+str(txt_vl.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        vl3 = str(float(txt11.get())*Uc)+str('+')+str(int(float(txt14.get())))+str(txt_vl.get())
                else:#整数でない
                    if number3<0:#Vベクトルの値が負であった場合
                        vl3 = str(float(txt11.get())*Uc)+str('-')+str(np.abs(float(txt14.get())))+str(txt_vl.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        vl3 = str(float(txt11.get())*Uc)+str('+')+str(float(txt14.get()))+str(txt_vl.get())
            except ValueError:#整数でない
                pass
        
        Vlabel2 = (f"({vl1},{vl2},{vl3})")
        
        #図を出力する
        #intensityの範囲
        fig5=plt.figure()
        fig5.subplots_adjust(left=0.30, right=0.75, bottom=0.2)
        ax = fig5.add_subplot(111)
        ax.set_xlabel(str(Vlabel2))
        ax.set_ylabel("ℏω (meV)")
        ax.set_xlim(Vlim_min,Vlim_max)
        ax.set_ylim(Elim_min,Elim_max)
        #im=plt.pcolormesh(QV, hwlist4, I_hwV, cmap='jet', vmin=z_min, vmax=z_max)
        at=axistype.get()
        # グリッド線を引く
        gt=gridtype.get()
        if gt == 0:
            #ax.set_axisbelow(True)  # グリッド線を背面に配置
            ax.grid(False)
        elif gt == 1:
            ax.grid(True)
        if at==0:
            im=plt.pcolormesh(QV, hwlist4, I_hwV, cmap='jet', vmin=z_min, vmax=z_max)
        elif at==1:
            if z_min==0:
                z_min=np.nanmin(I[I != 0])
                im=plt.pcolormesh(QV, hwlist4, I_hwV, cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
            else:
                im=plt.pcolormesh(QV, hwlist4, I_hwV, cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
        cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
        # カラーバーのタイトルを設定
        cbar.set_label('Intenisty (a.u.)')
        ax.text(0.1,1.1,f'{txt_ul.get()} = %.3f ± %.3f r.l.u.' %(Uc,Upm), transform=ax.transAxes)
        
        global Erange_2d_VvsE,Urange_2d_VvsE,Vrange_2d_VvsE
        Erange_2d_VvsE = energylist
        Urange_2d_VvsE = [[float(txt9.get())*(Uc - Upm),float(txt9.get())*(Uc + Upm)],[float(txt10.get())*(Uc - Upm),float(txt10.get())*(Uc + Upm)],[float(txt11.get())*(Uc - Upm),float(txt11.get())*(Uc + Upm)]]
        Vrange_2d_VvsE = [float(txt12.get())*QV2,float(txt13.get())*QV2,float(txt14.get())*QV2]
        
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_xmin = round(Vlim_min, 3)
        default_xmax = round(Vlim_max, 3)

        default_ymin = round(Elim_min, 3)
        default_ymax = round(Elim_max, 3)
        
        default_zmin = round(z_min, 3)
        default_zmax = round(z_max, 3)

        # テキストボックスを作成して最小値と最大値を設定
        xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
        xmax_box = TextBox(plt.axes([0.6, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
        zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                xmin_val = float(xmin_box.text)
                xmax_val = float(xmax_box.text)
                ax.set_xlim(xmin_val, xmax_val)
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax.set_ylim(ymin_val, ymax_val)
                zmin_val = float(zmin_box.text)
                zmax_val = float(zmax_box.text)
                cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
                fig5.canvas.draw_idle()
            except ValueError:
                pass

        xmin_box.on_submit(update_axis_range)
        xmax_box.on_submit(update_axis_range)
        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        zmin_box.on_submit(update_axis_range)
        zmax_box.on_submit(update_axis_range)
        
        plt.show()

    else:
        # 何もしない
        pass

# V方向にconstantQカットした図を表示するボタン
button11 = ttk.Button(tab_2d,command=constQmap_V,textvariable=constV_buttom,width=12)
button11.grid(row=2, column=2,columnspan=2,sticky="NSEW")

# U方向のconstant Q mapの表示の定義
def constQmap_U():
    # 軸設定。空欄の場合は範囲マックスを表示するようにする
    if scale_s_Umin_txt.get()=="":
        Ulim_min=round(np.min(QU),2)
    else:
        Ulim_min=float(scale_s_Umin_txt.get())
    if scale_s_Umax_txt.get()=="":
        Ulim_max=round(np.max(QU),2)
    else:
        Ulim_max=float(scale_s_Umax_txt.get())

    if scale_s_Emin_txt.get()=="":
        Elim_min=round(float(energylist[0]), 2)
    else:
        Elim_min=float(scale_s_Emin_txt.get())
    if scale_s_Emax_txt.get()=="":
        Elim_max=float(round(energylist[-1],2))
    else:
        Elim_max=float(scale_s_Emax_txt.get())

        
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_s_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_s_Imin_txt.get())
        
    if scale_s_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=0
    else:
        z_max=float(scale_s_Imax_txt.get())
    
    Vc=float(txt_2d_1u.get())
    Vpm=float(txt_2d_2u.get())
    # 変数　QU, QV, QU2, QV2, I ,Ierr
    hw_num = int(len(energylist)+1)
    global hwlist5
    hwlist5=np.zeros(hw_num)
    #hwが1つのときの例外処理として装置分解能の範囲を出力するようにする
    if hw_num==2:
        hwlist5[0] = float(energylist[0]-(ef_tol+0.005))
        hwlist5[1] = float(energylist[-1]+(ef_tol+0.005))
    else:
        hwlist5[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist5[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        #hwlist4[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        #hwlist4[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        for ne in range(hw_num-2):
            hwlist5[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2
    if Vpm==0:
        Ind_cQU = [np.abs(QV2 - Vc).argmin()]
    else:
        ind_cQU = list(zip(*np.where((Vc - Vpm <= QV2 ) & (QV2 <= Vc + Vpm))))
        Ind_cQU = list(np.ravel(ind_cQU))
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_cQU)!=0:
        global I_hwU,Ierr_hwU
        #I_hwU = np.nanmean(I[:,ind_cQU,:],axis = 1)
        #Ierr_hwU = ((np.nansum(Ierr[:,ind_cQU,:]*Ierr[:,ind_cQU,:],axis = 1))**(1/2))/len(ind_cQU)

        # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
        I_hwU=np.zeros((len(energylist),len(QU)-1))
        Ierr_hwU=np.zeros((len(energylist),len(QU)-1))
        for ll in range(len(energylist)):
            for mm in range(len(QU)-1):
                n_nanind = (list(zip(*np.where(~np.isnan(I[ll,Ind_cQU,mm])))))
                N_nanind = list(np.ravel(n_nanind)[::1])
                if N_nanind:
                    I_hwU[ll,mm] = np.nansum(I[ll,Ind_cQU,mm])/(len(N_nanind))   
                    Ierr_hwU[ll,mm] = ((np.nansum(np.multiply(Ierr[ll,Ind_cQU,mm],Ierr[ll,Ind_cQU,mm])))**(1/2))/(len(N_nanind))
                else:
                    I_hwU[ll,mm] = np.nan
                    Ierr_hwU[ll,mm] = np.nan
                    
        # 図のラベルを作成
        if float(txt9.get())==0:
            if float(txt12.get())==0:
                ul1 = str('0')
            else:
                ul1 = str(float(txt12.get())*Vc)
        elif float(txt9.get())==1:
            if float(txt12.get())==0:
                ul1 = str(txt_ul.get())
            else:
                ul1 = str(float(txt12.get())*Vc)+str('+')+str(txt_ul.get())
        elif float(txt9.get())==-1:
            if float(txt12.get())==0:
                ul1 = str('-')+str(txt_ul.get())
            else:
                ul1 = str(float(txt12.get())*Vc)+str('-')+str(txt_ul.get())
        else:
            try:
                number1 = float(txt9.get())
                if number1.is_integer():#整数である
                    if number1<0:#Vベクトルの値が負であった場合
                        ul1 = str(float(txt12.get())*Vc)+str('-')+str(int(np.abs(float(txt9.get()))))+str(txt_ul.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        ul1 = str(float(txt12.get())*Vc)+str('+')+str(int(float(txt9.get())))+str(txt_ul.get())
                else:#整数でない
                    if number1<0:#Vベクトルの値が負であった場合
                        ul1 = str(float(txt12.get())*Vc)+str('-')+str(np.abs(float(txt9.get())))+str(txt_ul.get())
                    elif number1>0:#Vベクトルの値が正であった場合
                        ul1 = str(float(txt12.get())*Vc)+str('+')+str(float(txt9.get()))+str(txt_ul.get())
            except ValueError:#整数でない
                pass
            
        if float(txt10.get())==0:
            if float(txt13.get())==0:
                ul2 = str('0')
            else:
                ul2 = str(float(txt13.get())*Vc)
        elif float(txt10.get())==1:
            if float(txt13.get())==0:
                ul2 = str(txt_ul.get())
            else:
                ul2 = str(float(txt13.get())*Vc)+str('+')+str(txt_ul.get())
        elif float(txt10.get())==-1:
            if float(txt13.get())==0:
                ul2 = str('-')+str(txt_ul.get())
            else:
                ul2 = str(float(txt13.get())*Vc)+str('-')+str(txt_ul.get())
        else:
            try:
                number2 = float(txt10.get())
                if number2.is_integer():#整数である
                    if number2<0:#Vベクトルの値が負であった場合
                        ul2 = str(float(txt13.get())*Vc)+str('-')+str(int(np.abs(float(txt10.get()))))+str(txt_ul.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        ul2 = str(float(txt13.get())*Vc)+str('+')+str(int(float(txt10.get())))+str(txt_ul.get())
                else:#整数でない
                    if number2<0:#Vベクトルの値が負であった場合
                        ul2 = str(float(txt13.get())*Vc)+str('-')+str(np.abs(float(txt10.get())))+str(txt_ul.get())
                    elif number2>0:#Vベクトルの値が正であった場合
                        ul2 = str(float(txt13.get())*Vc)+str('+')+str(float(txt10.get()))+str(txt_ul.get())
            except ValueError:#整数でない
                pass
            
            
        if float(txt11.get())==0:
            if float(txt14.get())==0:
                ul3 = str('0')
            else:
                ul3 = str(float(txt14.get())*Vc)
        elif float(txt11.get())==1:
            if float(txt14.get())==0:
                ul3 = str(txt_ul.get())
            else:
                ul3 = str(float(txt14.get())*Vc)+str('+')+str(txt_ul.get())
        elif float(txt11.get())==-1:
            if float(txt14.get())==0:
                ul3 = str('-')+str(txt_ul.get())
            else:
                ul3 = str(float(txt14.get())*Vc)+str('-')+str(txt_ul.get())
        else:
            try:
                number3 = float(txt11.get())
                if number3.is_integer():#整数である
                    if number3<0:#Vベクトルの値が負であった場合
                        ul3 = str(float(txt14.get())*Vc)+str('-')+str(int(np.abs(float(txt11.get()))))+str(txt_ul.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        ul3 = str(float(txt14.get())*Vc)+str('+')+str(int(float(txt11.get())))+str(txt_ul.get())
                else:#整数でない
                    if number3<0:#Vベクトルの値が負であった場合
                        ul3 = str(float(txt14.get())*Vc)+str('-')+str(np.abs(float(txt11.get())))+str(txt_ul.get())
                    elif number3>0:#Vベクトルの値が正であった場合
                        ul3 = str(float(txt14.get())*Vc)+str('+')+str(float(txt11.get()))+str(txt_ul.get())
            except ValueError:#整数でない
                pass
        
        Ulabel2 = (f"({ul1},{ul2},{ul3})")
        
        #図を出力する
        #intensityの範囲
        fig6=plt.figure()
        fig6.subplots_adjust(left=0.30, right=0.75, bottom=0.2)
        ax = fig6.add_subplot(111)
        # グリッド線を引く
        gt=gridtype.get()
        if gt == 0:
            #ax.set_axisbelow(True)  # グリッド線を背面に配置
            ax.grid(False)
        elif gt == 1:
            ax.grid(True)
        #im=plt.pcolormesh(QU, hwlist5, I_hwU, cmap='jet', vmin=z_min, vmax=z_max)
        at=axistype.get()
        if at==0:
            im=plt.pcolormesh(QU, hwlist5, I_hwU, cmap='jet', vmin=z_min, vmax=z_max)
        elif at==1:
            if z_min==0:
                z_min=np.nanmin(I[I != 0])
                im=plt.pcolormesh(QU, hwlist5, I_hwU, cmap='jet', norm = LogNorm(vmin=np.nanmin(I[I != 0]), vmax=z_max))
            else:
                im=plt.pcolormesh(QU, hwlist5, I_hwU, cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
        cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
        # カラーバーのタイトルを設定
        cbar.set_label('Intenisty (a.u.)')
        ax.text(0.1,1.1,f'{txt_vl.get()} = %.3f ± %.3f r.l.u.' %(Vc,Vpm), transform=ax.transAxes)
        ax.set_xlabel(str(Ulabel2))
        ax.set_ylabel("ℏω (meV)")
        ax.set_xlim(Ulim_min,Ulim_max)
        ax.set_ylim(Elim_min,Elim_max)
        #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
        #plt.axis('tight')
        
        global Erange_2d_UvsE,Urange_2d_UvsE,Vrange_2d_UvsE
        Erange_2d_UvsE = energylist
        Urange_2d_UvsE = [float(txt9.get())*QU2,float(txt10.get())*QU2,float(txt11.get())*QU2]
        Vrange_2d_UvsE = [[float(txt12.get())*(Vc - Vpm),float(txt12.get())*(Vc + Vpm)],[float(txt13.get())*(Vc - Vpm),float(txt13.get())*(Vc + Vpm)],[float(txt14.get())*(Vc - Vpm),float(txt14.get())*(Vc + Vpm)]]
        
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_xmin = round(Ulim_min, 3)
        default_xmax = round(Ulim_max, 3)

        default_ymin = round(Elim_min, 3)
        default_ymax = round(Elim_max, 3)
        
        default_zmin = round(z_min, 3)
        default_zmax = round(z_max, 3)

        # テキストボックスを作成して最小値と最大値を設定
        xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
        xmax_box = TextBox(plt.axes([0.6, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
        zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                xmin_val = float(xmin_box.text)
                xmax_val = float(xmax_box.text)
                ax.set_xlim(xmin_val, xmax_val)
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax.set_ylim(ymin_val, ymax_val)
                zmin_val = float(zmin_box.text)
                zmax_val = float(zmax_box.text)
                cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
                fig6.canvas.draw_idle()
            except ValueError:
                pass

        xmin_box.on_submit(update_axis_range)
        xmax_box.on_submit(update_axis_range)
        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        zmin_box.on_submit(update_axis_range)
        zmax_box.on_submit(update_axis_range)
        
        plt.show()
    else:
        pass

# U方向にconstantQカットした図を表示するボタン
button12 = ttk.Button(tab_2d,command=constQmap_U,textvariable=constU_buttom,width=12)
button12.grid(row=2, column=4,columnspan=2,sticky="NSEW")

################################################
# 1d view
# 1Dカットしたい範囲を指定するboxを作成
lbl_1d_1 = tk.Label(tab_1d,text='ℏω',width=6)
lbl_1d_1.grid(row=0, column=0,sticky="NSEW")
lbl_1d_2 = tk.Label(tab_1d,text='±ℏω',width=6)
lbl_1d_2.grid(row=0, column=1,sticky="NSEW")
txt_1d_1 = ttk.Entry(tab_1d,width=6)
txt_1d_1.insert(0,'0')
txt_1d_1.grid(row=1, column=0,sticky="NSEW")
txt_1d_2 = ttk.Entry(tab_1d,width=6)
txt_1d_2.insert(0,'0.1')
txt_1d_2.grid(row=1, column=1,sticky="NSEW")

lbl_1d_3 = tk.Label(tab_1d,width=6,textvariable=U_lavel)
lbl_1d_3.grid(row=0, column=2,sticky="NSEW")
lbl_1d_4 = tk.Label(tab_1d,width=6,textvariable=pmU_lavel)
lbl_1d_4.grid(row=0, column=3,sticky="NSEW")
txt_1d_3 = ttk.Entry(tab_1d,width=6)
txt_1d_3.insert(0,'0')
txt_1d_3.grid(row=1, column=2,sticky="NSEW")
txt_1d_4 = ttk.Entry(tab_1d,width=6)
txt_1d_4.insert(0,'0.1')
txt_1d_4.grid(row=1, column=3,sticky="NSEW")

lbl_1d_5 = tk.Label(tab_1d,width=6,textvariable=V_lavel)
lbl_1d_5.grid(row=0, column=4,sticky="NSEW")
lbl_1d_6 = tk.Label(tab_1d,width=6,textvariable=pmV_lavel)
lbl_1d_6.grid(row=0, column=5,sticky="NSEW")
txt_1d_5 = ttk.Entry(tab_1d,width=6)
txt_1d_5.insert(0,'0')
txt_1d_5.grid(row=1, column=4,sticky="NSEW")
txt_1d_6 = ttk.Entry(tab_1d,width=6)
txt_1d_6.insert(0,'0.1')
txt_1d_6.grid(row=1, column=5,sticky="NSEW")

# UとVの範囲を指定してE方向への1次元カットをする。
def constQmap_1D():    
    #既に記入しているUとVの範囲を読み出し。
    Uc=float(txt_1d_3.get())
    Upm=float(txt_1d_4.get())
    Vc=float(txt_1d_5.get())
    Vpm=float(txt_1d_6.get())
    # 変数　QU, QV, QU2, QV2, I ,Ierr
    hw_num = int(len(energylist)+1)
    hwlist6=np.zeros(hw_num)
    #hwが1つのときの例外処理として装置分解能の範囲を出力するようにする
    if hw_num==2:
        hwlist6[0] = float(energylist[0]-(ef_tol+0.005))
        hwlist6[1] = float(energylist[-1]+(ef_tol+0.005))
    else:
        hwlist6[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist6[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        #hwlist5[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        #hwlist5[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        for ne in range(hw_num-2):
            hwlist6[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2
    
    if Upm==0:
        Ind_1dE_U = [np.abs(QU2 - Uc).argmin()]
    else:
        ind_1dE_U = list(zip(*np.where((Uc - Upm <= QU2 ) & (QU2 <= Uc + Upm))))
        Ind_1dE_U = list(np.ravel(ind_1dE_U))
    
    if Vpm==0:
        Ind_1dE_V = [np.abs(QV2 - Vc).argmin()]
    else:
        ind_1dE_V = list(zip(*np.where((Vc - Vpm <= QV2 ) & (QV2 <= Vc + Vpm))))
        Ind_1dE_V = list(np.ravel(ind_1dE_V))

    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_1dE_U)!=0 and len(Ind_1dE_V)!=0:
        #旧コード
        #I_hw1d1 = np.nanmean(I[:,ind_1dE_V,:],axis = 1)
        #Ierr_hw1d1 = ((np.nansum(Ierr[:,ind_1dE_V,:]*Ierr[:,ind_1dE_V,:],axis = 1))**(1/2))/len(ind_1dE_V)
        # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
        """
        I_hw1d1=np.zeros((len(energylist),len(QV)-1))
        Ierr_hw1d1=np.zeros((len(energylist),len(QV)-1))
        for ll in range(len(energylist)):
            for nn in range(len(QV)-1):
                n_nanind0 = (list(zip(*np.where(~np.isnan(I[ll,nn,Ind_1dE_U])))))
                N_nanind0 = list(np.ravel(n_nanind0)[::1])
                if N_nanind0:
                    I_hw1d1[ll,nn] = np.nansum(I[ll,nn,Ind_1dE_U])/(len(N_nanind0))
                    Ierr_hw1d1[ll,nn] = ((np.nansum(np.multiply(Ierr[ll,nn,Ind_1dE_U],Ierr[ll,nn,Ind_1dE_U])))**(1/2))/(len(N_nanind0))
                else:
                    I_hw1d1[ll,nn] = np.nan
                    Ierr_hw1d1[ll,nn] = np.nan

        global I_hw1d2,Ierr_hw1d2
        #I_hw1d2 = np.nanmean(I_hw1d1[:,:,ind_1dE_U],axis = 2)
        #Ierr_hw1d2 = ((np.nansum(Ierr_hw1d1[:,:,ind_1dE_U]*Ierr_hw1d1[:,:,ind_1dE_U],axis = 2))**(1/2))/len(ind_1dE_U)
        I_hw1d2 = np.zeros(len(energylist))
        Ierr_hw1d2 = np.zeros(len(energylist))
        for ll in range(len(energylist)):
            n_nanind = (list(zip(*np.where(~np.isnan(I_hw1d1[ll,Ind_1dE_V])))))
            N_nanind = list(np.ravel(n_nanind)[::1])
            if N_nanind:
                #I_1DU[mm]=np.sum(I_ce[ind_cE1dV,mm][~np.isnan(I_ce[ind_cE1dV,ll])])/(len(I_ce[n_nanind[0]]))
                I_hw1d2[ll] = (np.nansum(I_hw1d1[ll,Ind_1dE_V]))/(len(N_nanind))
                Ierr_hw1d2[ll] = ((np.nansum(np.multiply(Ierr_hw1d1[ll,Ind_1dE_V],Ierr_hw1d1[ll,Ind_1dE_V])))**(1/2))/(len(N_nanind))
            else:
                I_hw1d2[ll] = np.nan
                Ierr_hw1d2[ll] = np.nan
        """
        
        global I_hw1d2,Ierr_hw1d2
        I_hw1d2 = np.zeros(len(energylist))
        Ierr_hw1d2 = np.zeros(len(energylist))
        
        for ll in range(len(energylist)):
            n_nanind = (list(zip(*np.where(~np.isnan(I[ll, Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_hw1d2[ll] = np.nansum(I[ll,Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1])/(len(N_nanind))
            Ierr_hw1d2[ll] = ((np.nansum(np.multiply(Ierr[ll,Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1],Ierr[ll,Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1])))**(1/2))/(len(N_nanind))

                        
        # 例外処理
        if len(list(zip(*np.where(~np.isnan(I_hw1d2)))))!=0:
            # グラフの軸設定
            if scale_s_Emin_txt.get()=="":
                xlim_min=round(float(energylist[0]), 2)
            else:
                xlim_min=float(scale_s_Emin_txt.get())
            if scale_s_Emax_txt.get()=="":
                xlim_max=float(round(energylist[-1],2))
            else:
                xlim_max=float(scale_s_Emax_txt.get())
            
            if scale_s_Imin_txt.get()=="":
                if np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2) >= 0:
                    ylim_min=0
                elif np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2) < 0:
                    ylim_min=np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2)
            else:
                ylim_min=float(scale_s_Imin_txt.get())
                
            if scale_s_Imax_txt.get()=="":
                if np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2) >= 0:
                    ylim_max=np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2)
                elif np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2) < 0:
                    ylim_max=np.abs(np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2))
            else:
                ylim_max=float(scale_s_Imax_txt.get())
            
            global oneDE
            # エラーバーのグラフを作成
            fig9=plt.figure()
            
            # グラフ内に表示範囲を決定するボックス
            # 最小値と最大値の初期値
            default_xmin = round(xlim_min, 2)
            default_xmax = round(xlim_max, 2)

            default_ymin = round(ylim_min, 2)
            default_ymax = round(ylim_max, 2)

            # テキストボックスを作成して最小値と最大値を設定
            xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
            xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
            ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
            ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
            
            # 最小値と最大値が変更されたときに呼び出される関数
            def update_axis_range(text):
                try:
                    xmin_val = float(xmin_box.text)
                    xmax_val = float(xmax_box.text)
                    ax9.set_xlim(xmin_val, xmax_val)
                    ymin_val = float(ymin_box.text)
                    ymax_val = float(ymax_box.text)
                    ax9.set_ylim(ymin_val, ymax_val)
                    fig9.canvas.draw_idle()
                except ValueError:
                    pass

            xmin_box.on_submit(update_axis_range)
            xmax_box.on_submit(update_axis_range)
            ymin_box.on_submit(update_axis_range)
            ymax_box.on_submit(update_axis_range)
            
            # 現在のFigure番号を取得
            oneDE = plt.gcf().number
            fig9.subplots_adjust(left=0.30, bottom=0.2)
            ax9 = fig9.add_subplot(111)
            #plt.text(0.1,1.1,f'{txt_vl.get()} = %.3f' %Vc, transform=ax.transAxes)
            #plt.text(0.3,1.1,' ± %.3f r.l.u.' %Vpm, transform=ax.transAxes)
            #plt.text(0.1,1.05,f'{txt_ul.get()} = %.3f' %Uc, transform=ax.transAxes)
            #plt.text(0.3,1.05,' ± %.3f r.l.u.' %Upm, transform=ax.transAxes)
            plt.xlabel("ℏω (meV)")
            plt.ylabel("Intensity (a. u.)")
            ax9.errorbar(energylist, I_hw1d2, yerr=Ierr_hw1d2, capsize=10,label=f'{txt_ul.get()}='+str(Uc)+'±'+str(Upm)+'(r.l.u.) ,'f'{txt_vl.get()}='+str(Vc)+'±'+str(Vpm)+'(r.l.u.)')
            
            global Erange_1d_Ivshw,Urange_1d_Ivshw,Vrange_1d_Ivshw
            Erange_1d_Ivshw = energylist
            Urange_1d_Ivshw = [[float(txt9.get())*(Uc - Upm),float(txt9.get())*(Uc + Upm)],[float(txt10.get())*(Uc - Upm),float(txt10.get())*(Uc + Upm)],[float(txt11.get())*(Uc - Upm),float(txt11.get())*(Uc + Upm)]]
            Vrange_1d_Ivshw = [[float(txt12.get())*(Vc - Vpm),float(txt12.get())*(Vc + Vpm)],[float(txt13.get())*(Vc - Vpm),float(txt13.get())*(Vc + Vpm)],[float(txt14.get())*(Vc - Vpm),float(txt14.get())*(Vc + Vpm)]]

            at=axistype.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(I_hw1d2)-np.nanmax(Ierr_hw1d2)
            ax9.legend()
            ax9.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            ax9.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            #plt.tick_params(labelsize=20)
            plt.grid()
            plt.show()
            
    else:
        pass

# UとVの範囲を指定して１次元カットしグラフを重ね書きするボタンの設定。
button13 = ttk.Button(tab_1d,text="I vs ℏω",command=constQmap_1D,width=12)
button13.grid(row=2, column=0,columnspan=2,sticky="NSEW")

# 追加で1Dcutを重ね書きする機能の定義
def constQmap_1D2():
    # 図番号が存在するかどうかの確認
    if plt.fignum_exists(oneDE)==True:
        Uc=float(txt_1d_3.get())
        Upm=float(txt_1d_4.get())
        Vc=float(txt_1d_5.get())
        Vpm=float(txt_1d_6.get())
        # 変数　QU, QV, QU2, QV2, I ,Ierr
        hw_num = int(len(energylist)+1)
        hwlist6=np.zeros(hw_num)
        hwlist6[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist6[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        #hwlist5[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        #hwlist5[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        for ne in range(hw_num-2):
            hwlist6[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2
        
        if Upm==0:
            Ind_1dE_U = [np.abs(QU2 - Uc).argmin()]
        else:
            ind_1dE_U = list(zip(*np.where((Uc - Upm <= QU2 ) & (QU2 <= Uc + Upm))))
            Ind_1dE_U = list(np.ravel(ind_1dE_U))
        
        if Vpm==0:
            Ind_1dE_V = [np.abs(QV2 - Vc).argmin()]
        else:
            ind_1dE_V = list(zip(*np.where((Vc - Vpm <= QV2 ) & (QV2 <= Vc + Vpm))))
            Ind_1dE_V = list(np.ravel(ind_1dE_V))

        # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
        if len(Ind_1dE_U)!=0 and len(Ind_1dE_V)!=0:
            #旧コード
            #I_hw1d1 = np.nanmean(I[:,ind_1dE_V,:],axis = 1)
            #Ierr_hw1d1 = ((np.nansum(Ierr[:,ind_1dE_V,:]*Ierr[:,ind_1dE_V,:],axis = 1))**(1/2))/len(ind_1dE_V)
            # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
            global I_hw1d2,Ierr_hw1d2
            I_hw1d2 = np.zeros(len(energylist))
            Ierr_hw1d2 = np.zeros(len(energylist))
            
            for ll in range(len(energylist)):
                n_nanind = (list(zip(*np.where(~np.isnan(I[ll, Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1])))))
                N_nanind = list(np.ravel(n_nanind)[::2])
                I_hw1d2[ll] = np.nansum(I[ll,Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1])/(len(N_nanind))
                Ierr_hw1d2[ll] = ((np.nansum(np.multiply(Ierr[ll,Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1],Ierr[ll,Ind_1dE_V[0]:Ind_1dE_V[-1]+1, Ind_1dE_U[0]:Ind_1dE_U[-1]+1])))**(1/2))/(len(N_nanind))

            # 例外処理
            if len(list(zip(*np.where(~np.isnan(I_hw1d2)))))!=0:
                # グラフの軸設定
                #xlim_min=energylist[0]
                #xlim_max=energylist[-1]
                
                #ylim_min=0
                #ylim_max=np.nanmax(I_hw1d2)+np.nanmax(Ierr_hw1d2)
                    
                # 図番号に対応するaxオブジェクトにアクセス
                fig9 = plt.figure(oneDE)
                ax9 = fig9.gca()
                ax9.errorbar(energylist, I_hw1d2, yerr=Ierr_hw1d2, capsize=10,label=f'{txt_ul.get()}='+str(Uc)+'±'+str(Upm)+'(r.l.u.) ,'f'{txt_vl.get()}='+str(Vc)+'±'+str(Vpm)+'(r.l.u.)')
                
                global Erange_1d_Ivshw,Urange_1d_Ivshw,Vrange_1d_Ivshw
                Erange_1d_Ivshw = energylist
                Urange_1d_Ivshw = [[float(txt9.get())*(Uc - Upm),float(txt9.get())*(Uc + Upm)],[float(txt10.get())*(Uc - Upm),float(txt10.get())*(Uc + Upm)],[float(txt11.get())*(Uc - Upm),float(txt11.get())*(Uc + Upm)]]
                Vrange_1d_Ivshw = [[float(txt12.get())*(Vc - Vpm),float(txt12.get())*(Vc + Vpm)],[float(txt13.get())*(Vc - Vpm),float(txt13.get())*(Vc + Vpm)],[float(txt14.get())*(Vc - Vpm),float(txt14.get())*(Vc + Vpm)]]

                at=axistype.get()
                if at==1:
                    plt.yscale('log')
                    #if ylim_min==0:
                    #    ylim_min=np.nanmin(I_hw1d2)-np.nanmax(Ierr_hw1d2)
                ax9.legend()
                #ax9.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
                #ax9.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
                plt.draw()

# UとVの範囲を指定した１次元カットを重ね書きするボタンの設定。
button13_2 = ttk.Button(tab_1d,text="add I vs ℏω",command=constQmap_1D2,width=12)
button13_2.grid(row=3, column=0,columnspan=2,sticky="NSEW")

def constE_1D_U():
    # いきなりこちらのボタンを押しても1Dカットができるように
    Ind_e = None
    hwlist3 = None
    Ec=float(txt_1d_1.get())
    Epm=float(txt_1d_2.get())
    Vc=float(txt_1d_5.get())
    Vpm=float(txt_1d_6.get())
    hwlist3=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist3[ne] = float(energylist[ne])

    if Epm==0:
        Ind_e = [np.abs(hwlist3 - Ec).argmin()]
    else:
        ind_e = list(zip(*np.where(( Ec - Epm <=  hwlist3 ) & (  hwlist3 <= Ec + Epm ))))
        Ind_e = list(np.ravel(ind_e))
    
    if Vpm==0:
        Ind_cE1dV = [np.abs(QV2 - Vc).argmin()]
    else:
        ind_cE1dV = list(zip(*np.where((Vc - Vpm <= QV2 ) & (QV2 <= Vc + Vpm))))
        Ind_cE1dV = list(np.ravel(ind_cE1dV))
    
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_e)!=0 and len(Ind_cE1dV)!=0:
        # 強度はNan値を省いて足し、Nan値を省いた値の個数で割る。誤差に関してはNan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る
        global I_1DU,Ierr_1DU
        I_1DU = np.zeros(len(QU)-1)
        Ierr_1DU = np.zeros(len(QU)-1)
        
        for mm in range(len(QU)-1):
            n_nanind = (list(zip(*np.where(~np.isnan(I[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1DU[mm] = np.nansum(I[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm])/(len(N_nanind))
            Ierr_1DU[mm] = ((np.nansum(np.multiply(Ierr[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm],Ierr[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm])))**(1/2))/(len(N_nanind))
            
        #例外処理
        if len(list(zip(*np.where(~np.isnan(I_1DU)))))!=0:
            # グラフの軸設定
            if scale_s_Umin_txt.get()=="":
                xlim_min=round(np.min(QU),2)
            else:
                xlim_min=float(scale_s_Umin_txt.get())
            if scale_s_Umax_txt.get()=="":
                xlim_max=round(np.max(QU),2)
            else:
                xlim_max=float(scale_s_Umax_txt.get())
            
            if scale_s_Imin_txt.get()=="":
                if np.nanmax(I_1DU)+np.nanmax(Ierr_1DU) >= 0:
                    ylim_min=0
                elif np.nanmax(I_1DU)+np.nanmax(Ierr_1DU) < 0:
                    ylim_min=np.nanmax(I_1DU)+np.nanmax(Ierr_1DU)
            else:
                ylim_min=float(scale_s_Imin_txt.get())
                
            if scale_s_Imax_txt.get()=="":
                if np.nanmax(I_1DU)+np.nanmax(Ierr_1DU) >= 0:
                    ylim_max=np.nanmax(I_1DU)+np.nanmax(Ierr_1DU)
                elif np.nanmax(I_1DU)+np.nanmax(Ierr_1DU) < 0:
                    ylim_max=np.abs(np.nanmax(I_1DU)+np.nanmax(Ierr_1DU))
            else:
                ylim_max=float(scale_s_Imax_txt.get())
                
            # エラーバーのグラフを作成
            global oneDU
            fig8=plt.figure()
            
            # グラフ内に表示範囲を決定するボックス
            # 最小値と最大値の初期値
            default_xmin = round(xlim_min, 2)
            default_xmax = round(xlim_max, 2)

            default_ymin = round(ylim_min, 2)
            default_ymax = round(ylim_max, 2)

            # テキストボックスを作成して最小値と最大値を設定
            xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
            xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
            ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
            ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
            
            # 最小値と最大値が変更されたときに呼び出される関数
            def update_axis_range(text):
                try:
                    xmin_val = float(xmin_box.text)
                    xmax_val = float(xmax_box.text)
                    ax8.set_xlim(xmin_val, xmax_val)
                    ymin_val = float(ymin_box.text)
                    ymax_val = float(ymax_box.text)
                    ax8.set_ylim(ymin_val, ymax_val)
                    fig8.canvas.draw_idle()
                except ValueError:
                    pass

            xmin_box.on_submit(update_axis_range)
            xmax_box.on_submit(update_axis_range)
            ymin_box.on_submit(update_axis_range)
            ymax_box.on_submit(update_axis_range)
            
            # 現在のFigure番号を取得
            oneDU = plt.gcf().number
            fig8.subplots_adjust(left=0.30, bottom=0.2)
            ax8 = fig8.add_subplot(111)
            #ax.text(0.1,1.1,f'{txt_vl.get()} = %.3f' %Vc, transform=ax.transAxes)
            #ax.text(0.3,1.1,' ± %.3f r.l.u.' %Vpm, transform=ax.transAxes)
            #plt.text(0.1,1.05,'E = %.3f' %Ec, transform=ax.transAxes)
            #plt.text(0.3,1.05,' ± %.3f meV' %Epm, transform=ax.transAxes)
            plt.xlabel(str(Ulabel))
            plt.ylabel("Intensity (a. u.)")
            ax8.errorbar(QU2, I_1DU, yerr=Ierr_1DU, capsize=10,label=f'E={Ec}±{Epm}meV, {txt_vl.get()}={Vc}±{Vpm}(r.l.u.)')
            
            global Erange_1d_IvsU,Urange_1d_IvsU,Vrange_1d_IvsU
            Erange_1d_IvsU = [Ec - Epm,Ec + Epm]
            Urange_1d_IvsU = [float(txt9.get())*QU2,float(txt10.get())*QU2,float(txt11.get())*QU2]
            Vrange_1d_IvsU = [[float(txt12.get())*(Vc - Vpm),float(txt12.get())*(Vc + Vpm)],[float(txt13.get())*(Vc - Vpm),float(txt13.get())*(Vc + Vpm)],[float(txt14.get())*(Vc - Vpm),float(txt14.get())*(Vc + Vpm)]]
            
            at=axistype.get()
            if at==1:
                plt.yscale('log')
                #if ylim_min==0:
                #    ylim_min=np.nanmin(I_1DU)-np.nanmax(Ierr_1DU)
            ax8.legend()
            ax8.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            ax8.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            #plt.tick_params(labelsize=20)
            plt.grid()
            plt.show()            
    else:
        # 何もしない
        pass

# V方向に１次元カットした図を表示するボタン
button10 = ttk.Button(tab_1d,command=constE_1D_U,width=12,textvariable=IvsU_buttom)
button10.grid(row=2, column=2,columnspan=2,sticky="NSEW")

#　１次元カットのグラフを追加する機能
def constE_1D_U2():
    # 追加の1Dカットをプロットする。
    Ind_e = None
    hwlist3 = None
    Ec=float(txt_1d_1.get())
    Epm=float(txt_1d_2.get())
    Vc=float(txt_1d_5.get())
    Vpm=float(txt_1d_6.get())
    hwlist3=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist3[ne] = float(energylist[ne])

    if Epm==0:
        Ind_e = [np.abs(hwlist3 - Ec).argmin()]
    else:
        ind_e = list(zip(*np.where(( Ec - Epm <=  hwlist3 ) & (  hwlist3 <= Ec + Epm ))))
        Ind_e = list(np.ravel(ind_e))
    
    if Vpm==0:
        Ind_cE1dV = [np.abs(QV2 - Vc).argmin()]
    else:
        ind_cE1dV = list(zip(*np.where((Vc - Vpm <= QV2 ) & (QV2 <= Vc + Vpm))))
        Ind_cE1dV = list(np.ravel(ind_cE1dV))

    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_e)!=0 and len(Ind_cE1dV)!=0:
        global I_1DU,Ierr_1DU
        I_1DU = np.zeros(len(QU)-1)
        Ierr_1DU = np.zeros(len(QU)-1)
        for mm in range(len(QU)-1):
            n_nanind = (list(zip(*np.where(~np.isnan(I[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1DU[mm] = np.nansum(I[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm])/(len(N_nanind))
            Ierr_1DU[mm] = ((np.nansum(np.multiply(Ierr[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm],Ierr[Ind_e[0]:Ind_e[-1]+1,Ind_cE1dV[0]:Ind_cE1dV[-1]+1,mm])))**(1/2))/(len(N_nanind))
            
        #例外処理
        if len(list(zip(*np.where(~np.isnan(I_1DU)))))!=0:
            #xlim_min=round(np.min(QU),2)
            #xlim_max=round(np.max(QU),2)
            
            #ylim_min=0
            #ylim_max=np.nanmax(I_1DU)+np.nanmax(Ierr_1DU)
            
            # 図番号に対応するaxオブジェクトにアクセス
            fig8 = plt.figure(oneDU)
            ax8 = fig8.gca()
            ax8.errorbar(QU2, I_1DU, yerr=Ierr_1DU, capsize=10,label=f'E={Ec}±{Epm}meV, {txt_vl.get()}={Vc}±{Vpm}(r.l.u.)')
            
            global Erange_1d_IvsU,Urange_1d_IvsU,Vrange_1d_IvsU
            Erange_1d_IvsU = [Ec - Epm,Ec + Epm]
            Urange_1d_IvsU = [float(txt9.get())*QU2,float(txt10.get())*QU2,float(txt11.get())*QU2]
            Vrange_1d_IvsU = [[float(txt12.get())*(Vc - Vpm),float(txt12.get())*(Vc + Vpm)],[float(txt13.get())*(Vc - Vpm),float(txt13.get())*(Vc + Vpm)],[float(txt14.get())*(Vc - Vpm),float(txt14.get())*(Vc + Vpm)]]

            
            at=axistype.get()
            if at==1:
                plt.yscale('log')
                #if ylim_min==0:
                #    ylim_min=np.nanmin(I_1DU)-np.nanmax(Ierr_1DU)
            ax8.legend()
            #ax8.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            #ax8.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            plt.draw()
            
# V方向に１次元カットした図を重ねするボタン
button10_2 = ttk.Button(tab_1d,command=constE_1D_U2,width=12,textvariable=addIvsU_buttom)
button10_2.grid(row=3, column=2,columnspan=2,sticky="NSEW")

# V方向への１次元カットボタンの定義
def constE_1D_V():  
    # いきなりこちらのボタンを押しても1Dカットができるように
    Ind_e = None
    hwlist2 = None
    Ec=float(txt_1d_1.get())
    Epm=float(txt_1d_2.get())
    Uc=float(txt_1d_3.get())
    Upm=float(txt_1d_4.get())
    if Epm < 0:
        return
    hwlist2=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist2[ne] = float(energylist[ne])

    if Epm==0:
        Ind_e = [np.abs(hwlist2 - Ec).argmin()]
    else:
        ind_e = list(zip(*np.where(( Ec - Epm <=  hwlist2 ) & (  hwlist2 <= Ec + Epm ))))
        Ind_e = list(np.ravel(ind_e))
    
    if Upm==0:
        Ind_cE1dU = [np.abs(QU2 - Uc).argmin()]
    else:
        ind_cE1dU = list(zip(*np.where((Uc - Upm <= QU2 ) & (QU2 <= Uc + Upm))))
        Ind_cE1dU = list(np.ravel(ind_cE1dU))
    
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_e)!=0 and len(Ind_cE1dU)!=0:
        # Nan値を省いて２乗和を取り、平方根を取ってから、NaN値を省いた値の個数で割る          
        global I_1DV,Ierr_1DV
        I_1DV = np.zeros(len(QV)-1)
        Ierr_1DV = np.zeros(len(QV)-1)
        for nn in range(len(QV)-1):
            n_nanind = (list(zip(*np.where(~np.isnan(I[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1DV[nn] = np.nansum(I[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1])/(len(N_nanind))
            Ierr_1DV[nn] = ((np.nansum(np.multiply(Ierr[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1],Ierr[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1])))**(1/2))/(len(N_nanind))

        #例外処理
        if len(list(zip(*np.where(~np.isnan(I_1DV)))))!=0:
            # グラフの軸設定
            if scale_s_Vmin_txt.get()=="":
                xlim_min=round(np.min(QV),2)
            else:
                xlim_min=float(scale_s_Vmin_txt.get())
            if scale_s_Vmax_txt.get()=="":
                xlim_max=round(np.max(QV),2)
            else:
                xlim_max=float(scale_s_Vmax_txt.get())
            
            if scale_s_Imin_txt.get()=="":
                if np.nanmax(I_1DV)+np.nanmax(Ierr_1DV) >= 0:
                    ylim_min=0
                elif np.nanmax(I_1DV)+np.nanmax(Ierr_1DV) < 0:
                    ylim_min=np.nanmax(I_1DV)+np.nanmax(Ierr_1DV)
            else:
                ylim_min=float(scale_s_Imin_txt.get())
                
            if scale_s_Imax_txt.get()=="":
                if np.nanmax(I_1DV)+np.nanmax(Ierr_1DV) >= 0:
                    ylim_max=np.nanmax(I_1DV)+np.nanmax(Ierr_1DV)
                elif np.nanmax(I_1DV)+np.nanmax(Ierr_1DV) < 0:
                    ylim_max=np.abs(np.nanmax(I_1DV)+np.nanmax(Ierr_1DV))
            else:
                ylim_max=float(scale_s_Imax_txt.get())
            
            # エラーバーのグラフを作成
            global oneDV
            fig7=plt.figure()
            
            # グラフ内に表示範囲を決定するボックス
            # 最小値と最大値の初期値
            default_xmin = round(xlim_min, 2)
            default_xmax = round(xlim_max, 2)

            default_ymin = round(ylim_min, 2)
            default_ymax = round(ylim_max, 2)

            # テキストボックスを作成して最小値と最大値を設定
            xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
            xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
            ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
            ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
            
            # 最小値と最大値が変更されたときに呼び出される関数
            def update_axis_range(text):
                try:
                    xmin_val = float(xmin_box.text)
                    xmax_val = float(xmax_box.text)
                    ax7.set_xlim(xmin_val, xmax_val)
                    ymin_val = float(ymin_box.text)
                    ymax_val = float(ymax_box.text)
                    ax7.set_ylim(ymin_val, ymax_val)
                    fig7.canvas.draw_idle()
                except ValueError:
                    pass

            xmin_box.on_submit(update_axis_range)
            xmax_box.on_submit(update_axis_range)
            ymin_box.on_submit(update_axis_range)
            ymax_box.on_submit(update_axis_range)
            
            # 現在のFigure番号を取得
            oneDV = plt.gcf().number
            fig7.subplots_adjust(left=0.30,bottom=0.2)
            ax7 = fig7.add_subplot(111)
            #plt.text(0.1,1.1,f'{txt_ul.get()} = %.3f' %Uc, transform=ax.transAxes)
            #plt.text(0.3,1.1,' ± %.3f r.l.u.' %Upm, transform=ax.transAxes)
            #plt.text(0.1,1.05,'E = %.3f' %Ec, transform=ax.transAxes)
            #plt.text(0.3,1.05,' ± %.3f meV' %Epm, transform=ax.transAxes)
            plt.xlabel(str(Vlabel))
            plt.ylabel("Intensity (a. u.)")
            ax7.errorbar(QV2, I_1DV, yerr=Ierr_1DV, capsize=10,label=f'E={Ec}±{Epm}meV, {txt_ul.get()}={Uc}±{Upm}(r.l.u.)')

            global Erange_1d_IvsV,Urange_1d_IvsV,Vrange_1d_IvsV
            Erange_1d_IvsV = [Ec - Epm,Ec + Epm]
            Urange_1d_IvsV = [[float(txt9.get())*(Uc - Upm),float(txt9.get())*(Uc + Upm)],[float(txt10.get())*(Uc - Upm),float(txt10.get())*(Uc + Upm)],[float(txt11.get())*(Uc - Upm),float(txt11.get())*(Uc + Upm)]]
            Vrange_1d_IvsV = [float(txt12.get())*QV2,float(txt13.get())*QV2,float(txt14.get())*QV2]
            
            at=axistype.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(I_1DV)-np.nanmax(Ierr_1DV)
            ax7.legend()
            ax7.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            ax7.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            #plt.tick_params(labelsize=20)
            plt.grid()
            plt.show()
                        
    else:
        pass

# V方向に１次元カットした図を追加表示するボタン
button9 = ttk.Button(tab_1d,command=constE_1D_V,width=12,textvariable=IvsV_buttom)
button9.grid(row=2, column=4,columnspan=2,sticky="NSEW")

def constE_1D_V2():
    # 追加の1Dカットをプロットする。
    Ind_e = None
    hwlist2 = None
    Ec=float(txt_1d_1.get())
    Epm=float(txt_1d_2.get())
    Uc=float(txt_1d_3.get())
    Upm=float(txt_1d_4.get())
    if Epm < 0:
        return
    hwlist2=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist2[ne] = float(energylist[ne])

    if Epm==0:
        Ind_e = [np.abs(hwlist2 - Ec).argmin()]
    else:
        ind_e = list(zip(*np.where(( Ec - Epm <=  hwlist2 ) & (  hwlist2 <= Ec + Epm ))))
        Ind_e = list(np.ravel(ind_e))
    
    if Upm==0:
        Ind_cE1dU = [np.abs(QU2 - Uc).argmin()]
    else:
        ind_cE1dU = list(zip(*np.where((Uc - Upm <= QU2 ) & (QU2 <= Uc + Upm))))
        Ind_cE1dU = list(np.ravel(ind_cE1dU))
        
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Ind_e)!=0 and len(Ind_cE1dU)!=0:
        global I_1DV,Ierr_1DV
        I_1DV = np.zeros(len(QV)-1)
        Ierr_1DV = np.zeros(len(QV)-1)
        for nn in range(len(QV)-1):
            n_nanind = (list(zip(*np.where(~np.isnan(I[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1])))))
            N_nanind = list(np.ravel(n_nanind)[::2])
            I_1DV[nn] = np.nansum(I[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1])/(len(N_nanind))
            Ierr_1DV[nn] = ((np.nansum(np.multiply(Ierr[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1],Ierr[Ind_e[0]:Ind_e[-1]+1,nn,Ind_cE1dU[0]:Ind_cE1dU[-1]+1])))**(1/2))/(len(N_nanind))

        #例外処理
        if len(list(zip(*np.where(~np.isnan(I_1DV)))))!=0:
            #xlim_min=round(np.min(QV),2)
            #xlim_max=round(np.max(QV),2)
            
            #ylim_min=0
            #ylim_max=np.nanmax(I_1DV)+np.nanmax(Ierr_1DV)
                 
            # 図番号に対応するaxオブジェクトにアクセス
            fig7 = plt.figure(oneDV)
            ax7 = fig7.gca()
            ax7.errorbar(QV2, I_1DV, yerr=Ierr_1DV, capsize=10,label=f'E={Ec}±{Epm}meV, {txt_ul.get()}={Uc}±{Upm}(r.l.u.)')
            
            global Erange_1d_IvsV,Urange_1d_IvsV,Vrange_1d_IvsV
            Erange_1d_IvsV = [Ec - Epm,Ec + Epm]
            Urange_1d_IvsV = [[float(txt9.get())*(Uc - Upm),float(txt9.get())*(Uc + Upm)],[float(txt10.get())*(Uc - Upm),float(txt10.get())*(Uc + Upm)],[float(txt11.get())*(Uc - Upm),float(txt11.get())*(Uc + Upm)]]
            Vrange_1d_IvsV = [float(txt12.get())*QV2,float(txt13.get())*QV2,float(txt14.get())*QV2]
            
            at=axistype.get()
            if at==1:
                plt.yscale('log')
                #if ylim_min==0:
                #    ylim_min=np.nanmin(I_1DV)-np.nanmax(Ierr_1DV)
            ax7.legend()
            #ax7.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            #ax7.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            plt.draw()

# U方向に１次元カットした図を重ねするボタン
button9_2 = ttk.Button(tab_1d,command=constE_1D_V2,width=12,textvariable=addIvsV_buttom)
button9_2.grid(row=3, column=4,columnspan=2,sticky="NSEW")

#########################################################################
# TAS modeで測定した場合のデータ表示
   
# 読み込めなかった時はデータ形式がおかしい。(例えば最終の行だけ列数が少ないとか)
# データ表示ボタンが押された時の定義
def xaxis_select():    
    # まずデータを読み込む
    #特定の行を読み込む
    with open(file_paths[0],"r", encoding="utf-8") as f:
        line = f.readlines()
        data = line[31]
        data2 = data.split()
        if "Pt." in data2:
            pass
        else:
            data = line[32]
            data2 = data.split()
    No_Pt=data2.index('Pt.')
    No_c2=data2.index('c2')
    No_a2=data2.index('a2')
    No_timeact=data2.index('time-act')
    #mcuがない場合は読み込まない。
    if data.find('mcu')!=-1:
        No_mcu=data2.index('mcu')
    else :
        pass
    No_e=data2.index('e')
    No_q=data2.index('q')
    No_h=data2.index('h')
    No_k=data2.index('k')
    No_l=data2.index('l')
    No_tsample=data2.index('tsample')
    No_D01=data2.index('D01')
    No_D02=data2.index('D02')
    No_D03=data2.index('D03')
    No_D04=data2.index('D04')
    No_D05=data2.index('D05')
    No_D06=data2.index('D06')
    No_D07=data2.index('D07')
    No_D08=data2.index('D08')
    No_D09=data2.index('D09')
    No_D10=data2.index('D10')
    No_D11=data2.index('D11')
    No_D12=data2.index('D12')
    No_D13=data2.index('D13')
    No_D14=data2.index('D14')
    No_D15=data2.index('D15')
    No_D16=data2.index('D16')
    No_D17=data2.index('D17')
    No_D18=data2.index('D18')
    No_D19=data2.index('D19')
    No_D20=data2.index('D20')
    No_D21=data2.index('D21')
    No_D22=data2.index('D22')
    No_D23=data2.index('D23')
    No_D24=data2.index('D24')
    """
    No_1l=data2.index('1l')
    No_1r=data2.index('1r')
    No_1t=data2.index('1t')
    No_1b=data2.index('1b')
    """

    #ファイルの数値を全て読み込む
    #tt = np.loadtxt(file_paths[0], usecols = 0, delimiter=" ")
    pt = np.loadtxt(file_paths[0], comments='#', usecols = No_Pt-1)
    c2 = np.loadtxt(file_paths[0], comments='#', usecols = No_c2-1)
    a2 = np.loadtxt(file_paths[0], comments='#', usecols = No_a2-1)
    #mcuがない場合は読み込まない。強制的にmcuが0となる。しかし、このモードではカウント値しか読み込まないため問題ない。
    if data.find('mcu')!=-1:
        mcu = np.loadtxt(file_paths[0], comments='#', usecols = No_mcu-1)
    else :
        #mcu = np.zeros((len(c2)))
        pass
    t_a = np.loadtxt(file_paths[0], comments='#', usecols = No_timeact-1)
    e = np.loadtxt(file_paths[0], comments='#', usecols = No_e-1)
    D01 = np.loadtxt(file_paths[0], comments='#', usecols = No_D01-1)
    D02 = np.loadtxt(file_paths[0], comments='#', usecols = No_D02-1)
    D03 = np.loadtxt(file_paths[0], comments='#', usecols = No_D03-1)
    D04 = np.loadtxt(file_paths[0], comments='#', usecols = No_D04-1)
    D05 = np.loadtxt(file_paths[0], comments='#', usecols = No_D05-1)
    D06 = np.loadtxt(file_paths[0], comments='#', usecols = No_D06-1)
    D07 = np.loadtxt(file_paths[0], comments='#', usecols = No_D07-1)
    D08 = np.loadtxt(file_paths[0], comments='#', usecols = No_D08-1)
    D09 = np.loadtxt(file_paths[0], comments='#', usecols = No_D09-1)
    D10 = np.loadtxt(file_paths[0], comments='#', usecols = No_D10-1)
    D11 = np.loadtxt(file_paths[0], comments='#', usecols = No_D11-1)
    D12 = np.loadtxt(file_paths[0], comments='#', usecols = No_D12-1)
    D13 = np.loadtxt(file_paths[0], comments='#', usecols = No_D13-1)
    D14 = np.loadtxt(file_paths[0], comments='#', usecols = No_D14-1)
    D15 = np.loadtxt(file_paths[0], comments='#', usecols = No_D15-1)
    D16 = np.loadtxt(file_paths[0], comments='#', usecols = No_D16-1)
    D17 = np.loadtxt(file_paths[0], comments='#', usecols = No_D17-1)
    D18 = np.loadtxt(file_paths[0], comments='#', usecols = No_D18-1)
    D19 = np.loadtxt(file_paths[0], comments='#', usecols = No_D19-1)
    D20 = np.loadtxt(file_paths[0], comments='#', usecols = No_D20-1)
    D21 = np.loadtxt(file_paths[0], comments='#', usecols = No_D21-1)
    D22 = np.loadtxt(file_paths[0], comments='#', usecols = No_D22-1)
    D23 = np.loadtxt(file_paths[0], comments='#', usecols = No_D23-1)
    D24 = np.loadtxt(file_paths[0], comments='#', usecols = No_D24-1)

    q = np.loadtxt(file_paths[0], comments='#', usecols = No_q-1)
    h = np.loadtxt(file_paths[0], comments='#', usecols = No_h-1)
    k = np.loadtxt(file_paths[0], comments='#', usecols = No_k-1)
    l = np.loadtxt(file_paths[0], comments='#', usecols = No_l-1)
    T = np.loadtxt(file_paths[0], comments='#', usecols = No_tsample-1)
    """
    l1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1l-1)
    r1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1r-1)
    b1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1b-1)
    t1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1t-1)
    """

    # X軸の項目を1つの行列にする。
    xbox=np.vstack([pt,c2,a2,q,h,k,l,e,T])

    # selectされたindexを読み込む
    x_select = cbs.current()
    
    #Y軸の項目を1つの行列にする。
    ybox=np.vstack([D01,D02,D03,D04,D05,D06,D07,D08,D09,D10,D11,D12,D13,D14,D15,D16,D17,D18,D19,D20,D21,D22,D23,D24])
    
    # selectされたindexを読み込む
    y_select = cb_ds.current()
    
    xlim_min=np.nanmin(xbox[x_select,:])
    xlim_max=np.nanmax(xbox[x_select,:])

    ylim_min=0
    ylim_max=np.nanmax(ybox[y_select,:])
    
    # エラーバーのグラフを作成
    fig10=plt.figure()
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(xlim_min, 2)
    default_xmax = round(xlim_max, 2)

    default_ymin = round(ylim_min, 2)
    default_ymax = round(ylim_max, 2)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax10.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax10.set_ylim(ymin_val, ymax_val)
            fig10.canvas.draw_idle()
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    
    global fig_tas
    # 現在のFigure番号を取得
    fig_tas = plt.gcf().number
    fig10.subplots_adjust(left=0.30,bottom=0.2)
    ax10 = fig10.add_subplot(111)
    xlist =['Pt','c2 (deg)', 'a2 (deg)', 'q (Å^-1)' ,'h (r.l.u.)', 'k (r.l.u.)', 'l (r.l.u.)', 'e (meV)', 'T (K)']
    plt.xlabel(xlist[x_select])
    plt.ylabel("Intensity (count)")
    ax10.errorbar(xbox[x_select,:], ybox[y_select,:], yerr=ybox[y_select,:]**(1/2), capsize=10, label='Detector'+str(y_select+1))
    at=axistype.get()
    if at==1:
        plt.yscale('log')
        if ylim_min==0:
            ylim_min=np.nanmin(ybox[y_select,:])-np.nanmax(ybox[y_select,:])
    ax10.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
    ax10.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
    #plt.tick_params(labelsize=20)
    ax10.legend()
    plt.grid()
    plt.show()

#グラフを表示するボタンを設置
v_btn = ttk.Button(tab_4, text='view data', command=xaxis_select,width=12)
v_btn.grid(row=1, column=2,sticky="NSEW")

# Xコンボボックスのリスト
xlist =["Pt","c2", "a2", "q" ,"h", "k", "l", "e", "T"]

# Yコンボボックスのリスト
ylist =["D01","D02","D03","D04","D05","D06","D07","D08","D09","D10","D11","D12","D13","D14","D15","D16","D17","D18","D19","D20","D21","D22","D23","D24"]

# Xコンボボックスのラベル
lbl4_1 = tk.Label(tab_4,text='x-axis',width=6)
lbl4_1.grid(row=0, column=0,sticky="NSEW")

# ダミーのラベル
lbl4_d1 = tk.Label(tab_4,text='',width=6)
lbl4_d1.grid(row=2, column=0,sticky="NSEW",pady=1)
lbl4_d2 = tk.Label(tab_4,text='',width=6)
lbl4_d2.grid(row=3, column=0,sticky="NSEW",pady=1)

# Xコンボボックスを設置
cbs = ttk.Combobox(tab_4, values = xlist, width=6)
cbs.grid(row=1, column=0,sticky="NSEW")

#コンボボックスのリストの先頭を表示
cbs.set(xlist[0])

# Yコンボボックスのラベル
lbl4_2 = tk.Label(tab_4,text='detector',width=6)
lbl4_2.grid(row=0, column=1,sticky="NSEW")

# Yコンボボックスを設置
cb_ds = ttk.Combobox(tab_4, values = ylist, width=6)
cb_ds.grid(row=1, column=1,sticky="NSEW")

#コンボボックスのリストの先頭を表示
cb_ds.set(ylist[11])

#追加でグラフを表示するボタンの定義
def add_axis_select(): 
    # データを読み込む
    #特定の行を読み込む
    with open(file_paths[0],"r", encoding="utf-8") as f:
        line = f.readlines()
        data = line[31]
        data2 = data.split()
        if "Pt." in data2:
            pass
        else:
            data = line[32]
            data2 = data.split()
    No_Pt=data2.index('Pt.')
    No_c2=data2.index('c2')
    No_a2=data2.index('a2')
    No_timeact=data2.index('time-act')
    #mcuがない場合は読み込まない。
    if data.find('mcu')!=-1:
        No_mcu=data2.index('mcu')
    else :
        pass
    No_e=data2.index('e')
    No_q=data2.index('q')
    No_h=data2.index('h')
    No_k=data2.index('k')
    No_l=data2.index('l')
    No_tsample=data2.index('tsample')
    No_D01=data2.index('D01')
    No_D02=data2.index('D02')
    No_D03=data2.index('D03')
    No_D04=data2.index('D04')
    No_D05=data2.index('D05')
    No_D06=data2.index('D06')
    No_D07=data2.index('D07')
    No_D08=data2.index('D08')
    No_D09=data2.index('D09')
    No_D10=data2.index('D10')
    No_D11=data2.index('D11')
    No_D12=data2.index('D12')
    No_D13=data2.index('D13')
    No_D14=data2.index('D14')
    No_D15=data2.index('D15')
    No_D16=data2.index('D16')
    No_D17=data2.index('D17')
    No_D18=data2.index('D18')
    No_D19=data2.index('D19')
    No_D20=data2.index('D20')
    No_D21=data2.index('D21')
    No_D22=data2.index('D22')
    No_D23=data2.index('D23')
    No_D24=data2.index('D24')
    """
    No_1l=data2.index('1l')
    No_1r=data2.index('1r')
    No_1t=data2.index('1t')
    No_1b=data2.index('1b')
    """

    #ファイルの数値を全て読み込む
    #tt = np.loadtxt(file_paths[0], usecols = 0, delimiter=" ")
    pt = np.loadtxt(file_paths[0], comments='#', usecols = No_Pt-1)
    c2 = np.loadtxt(file_paths[0], comments='#', usecols = No_c2-1)
    a2 = np.loadtxt(file_paths[0], comments='#', usecols = No_a2-1)
    #mcuがない場合は読み込まない。強制的にmcuが0となる。しかし、このモードではカウント値しか読み込まないため問題ない。
    if data.find('mcu')!=-1:
        mcu = np.loadtxt(file_paths[0], comments='#', usecols = No_mcu-1)
    else :
        #mcu = np.zeros((len(c2)))
        pass
    t_a = np.loadtxt(file_paths[0], comments='#', usecols = No_timeact-1)
    e = np.loadtxt(file_paths[0], comments='#', usecols = No_e-1)
    D01 = np.loadtxt(file_paths[0], comments='#', usecols = No_D01-1)
    D02 = np.loadtxt(file_paths[0], comments='#', usecols = No_D02-1)
    D03 = np.loadtxt(file_paths[0], comments='#', usecols = No_D03-1)
    D04 = np.loadtxt(file_paths[0], comments='#', usecols = No_D04-1)
    D05 = np.loadtxt(file_paths[0], comments='#', usecols = No_D05-1)
    D06 = np.loadtxt(file_paths[0], comments='#', usecols = No_D06-1)
    D07 = np.loadtxt(file_paths[0], comments='#', usecols = No_D07-1)
    D08 = np.loadtxt(file_paths[0], comments='#', usecols = No_D08-1)
    D09 = np.loadtxt(file_paths[0], comments='#', usecols = No_D09-1)
    D10 = np.loadtxt(file_paths[0], comments='#', usecols = No_D10-1)
    D11 = np.loadtxt(file_paths[0], comments='#', usecols = No_D11-1)
    D12 = np.loadtxt(file_paths[0], comments='#', usecols = No_D12-1)
    D13 = np.loadtxt(file_paths[0], comments='#', usecols = No_D13-1)
    D14 = np.loadtxt(file_paths[0], comments='#', usecols = No_D14-1)
    D15 = np.loadtxt(file_paths[0], comments='#', usecols = No_D15-1)
    D16 = np.loadtxt(file_paths[0], comments='#', usecols = No_D16-1)
    D17 = np.loadtxt(file_paths[0], comments='#', usecols = No_D17-1)
    D18 = np.loadtxt(file_paths[0], comments='#', usecols = No_D18-1)
    D19 = np.loadtxt(file_paths[0], comments='#', usecols = No_D19-1)
    D20 = np.loadtxt(file_paths[0], comments='#', usecols = No_D20-1)
    D21 = np.loadtxt(file_paths[0], comments='#', usecols = No_D21-1)
    D22 = np.loadtxt(file_paths[0], comments='#', usecols = No_D22-1)
    D23 = np.loadtxt(file_paths[0], comments='#', usecols = No_D23-1)
    D24 = np.loadtxt(file_paths[0], comments='#', usecols = No_D24-1)

    q = np.loadtxt(file_paths[0], comments='#', usecols = No_q-1)
    h = np.loadtxt(file_paths[0], comments='#', usecols = No_h-1)
    k = np.loadtxt(file_paths[0], comments='#', usecols = No_k-1)
    l = np.loadtxt(file_paths[0], comments='#', usecols = No_l-1)
    T = np.loadtxt(file_paths[0], comments='#', usecols = No_tsample-1)
    """
    l1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1l-1)
    r1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1r-1)
    b1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1b-1)
    t1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1t-1)
    """

    # X軸の項目を1つの行列にする。
    xbox=np.vstack([pt,c2,a2,q,h,k,l,e,T])

    # selectされたindexを読み込む
    x_select = cbs.current()
    
    #Y軸の項目を1つの行列にする。
    ybox=np.vstack([D01,D02,D03,D04,D05,D06,D07,D08,D09,D10,D11,D12,D13,D14,D15,D16,D17,D18,D19,D20,D21,D22,D23,D24])
    
    # selectされたindexを読み込む
    y_select = cb_ds.current()
    
    #xlim_min=np.nanmin(xbox[x_select,:])
    #xlim_max=np.nanmax(xbox[x_select,:])

    #ylim_min=0
    #ylim_max=np.nanmax(ybox[y_select,:])
    
    # エラーバーのグラフを作成   
    fig10=plt.figure(fig_tas)
    ax10 = fig10.gca()
    ax10.errorbar(xbox[x_select,:], ybox[y_select,:], yerr=ybox[y_select,:]**(1/2), capsize=10, label='Detector'+str(y_select+1))
    at=axistype.get()
    if at==1:
        plt.yscale('log')
        #if ylim_min==0:
        #    ylim_min=np.nanmin(ybox[y_select,:])-np.nanmax(ybox[y_select,:])
    #ax10.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
    #ax10.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
    #plt.tick_params(labelsize=20)
    ax10.legend()
    plt.show()

#追加でグラフを表示するボタンを設置
v_btn = ttk.Button(tab_4, text='add data', command=add_axis_select,width=12)
v_btn.grid(row=1, column=3,sticky="NSEW")

###############################################################################
#powderの項目
# データボックスを作成するボタン周りのフレーム作成。
frame1p = ttk.Labelframe(tab_02, text= "data construction")
frame1p.grid(row = 0, column = 0,columnspan=2,sticky="NSEW")
#frame1p.grid_propagate(True)

frame1p.columnconfigure(0, weight=1)
frame1p.columnconfigure(1, weight=1)
frame1p.columnconfigure(2, weight=1)
frame1p.columnconfigure(3, weight=1)
frame1p.columnconfigure(4, weight=1)
frame1p.columnconfigure(5, weight=1)
frame1p.columnconfigure(6, weight=1)
frame1p.columnconfigure(7, weight=1)
frame1p.columnconfigure(8, weight=1)
frame1p.rowconfigure(0, weight=1)
frame1p.rowconfigure(1, weight=1)
frame1p.rowconfigure(2, weight=1)

# hw範囲とQ範囲とbin sizeの入力欄
lbl04_p = tk.Label(frame1p,text='min ℏω',width=6)
lbl04_p.grid(row=0, column=0,sticky="NSEW")
txt04_p = ttk.Entry(frame1p,width=6)
txt04_p.grid(row=1, column=0,sticky="NSEW")

lbl05_p = tk.Label(frame1p,text='max ℏω',width=6)
lbl05_p.grid(row=0, column=1,sticky="NSEW")
txt05_p = ttk.Entry(frame1p,width=6)
txt05_p.grid(row=1, column=1,sticky="NSEW")

lbl06_p = tk.Label(frame1p,text='bin ℏω',width=6)
lbl06_p.grid(row=0, column=2,sticky="NSEW")
txt06_p = ttk.Entry(frame1p,width=6)
txt06_p.grid(row=1, column=2,sticky="NSEW")

lbl01_p = tk.Label(frame1p,text='min Q',width=6)
lbl01_p.grid(row=0, column=3,sticky="NSEW")
txt01_p = ttk.Entry(frame1p,width=6)
txt01_p.grid(row=1, column=3,sticky="NSEW")

lbl02_p = tk.Label(frame1p,text='max Q',width=6)
lbl02_p.grid(row=0, column=4,sticky="NSEW")
txt02_p = ttk.Entry(frame1p,width=6)
txt02_p.grid(row=1, column=4,sticky="NSEW")

lbl03_p = tk.Label(frame1p,text='bin Q',width=6)
lbl03_p.grid(row=0, column=5,sticky="NSEW")
txt03_p = ttk.Entry(frame1p,width=6)
txt03_p.grid(row=1, column=5,sticky="NSEW")
#txt03_p.insert(0,'0.05')

"""
# 大きさをそろえるためのダミーの入力欄
lblp_d = tk.Label(frame1p,text='     ',width=6)
lblp_d.grid(row=1, column=6,sticky="NSEW")
lblp_d = tk.Label(frame1p,text='     ',width=6)
lblp_d.grid(row=1, column=7,sticky="NSEW")
lblp_d = tk.Label(frame1p,text='     ',width=6)
lblp_d.grid(row=1, column=8,sticky="NSEW")
"""

# 空のプログレスバーの表示
pb3 = ttk.Progressbar(frame1p,orient='horizontal',mode='determinate')
pb3.grid(row=2, column=6, columnspan=3,sticky="NSEW")

def pow_data_box():
    #energyの異なる値を取り出す(重複した数値を消してリスト化する)
    global energylist
    if hwp_nan.get()==0:
        if fgt_txt1.get()=='':
            E_T = round(ef_tol+0.005,3)
        else:
            E_T = float(fgt_txt1.get())
        dEfg = 0 # energy方向のsmoothing
        dEbg = 0 # energy方向のsmoothing
        # もとのコード
        energylist=(list(set(databox[3,:])))
        # さらにソートする(元のリストを書き換え)
        energylist.sort()
        # さらにエネルギートランスファーのトレランスを考慮して±E_TmeV以内は同じ数値にする。
        Energylist = [energylist[0]]  # 初めて値を代入

        for i in range(1, (len(energylist)-1)):
            if Energylist[-1] <= energylist[i] and energylist[i] < Energylist[-1] + 2*E_T:
                pass
            else:
                Energylist.append(energylist[i+1])
        # 最後の範囲が記録されないので最後に付け足す。
        if Energylist[-1] == energylist[-1]:
            pass
        else:
            Energylist.append(energylist[-1])
        # energylistを再構成
        energylist=list(set(Energylist))
        energylist.sort()
    
    if hwp_nan.get()==1:
        Emin = float(txt04_p.get())
        Emax = float(txt05_p.get())
        Ebin = float(txt06_p.get())
        E_T = Ebin/2
        if fgt_txt1.get()=="":
            dEfg=0
        else:
            dEfg = (float(fgt_txt1.get())-Ebin)/2 # energy方向のsmoothing
            
        if bgt_txt1.get()=="":
            dEbg=0
        else:
            dEbg = (float(bgt_txt1.get())-Ebin)/2 # energy方向のsmoothing

        Ne=round((Emax-Emin)/Ebin+1)
        if Ne==1:
            Energylist_cal = [Emin,Emax]
            #ind_e = (list(zip(*np.where(((Energylist_cal[0]) <= databox[3,:]) & (databox[3,:] < (Energylist_cal[-1]))))))
            energylist = [(Energylist_cal[i] + Energylist_cal[i+1])/2]
        else:
            Energylist_cal=np.zeros((Ne))
            energylist=np.zeros((Ne-1))
            for i in range(Ne):
                Energylist_cal[i] = Emin + Ebin * i
            for i in range(Ne-1):
                #ind_e = (list(zip(*np.where(((Energylist_cal[i]) <= databox[3,:]) & (databox[3,:] < (Energylist_cal[i+1]))))))
                energylist[i] = (Energylist_cal[i] + Energylist_cal[i+1])/2
    
    global pb3
    var3 = 0 # プログレスバーの変数
    pb3["maximum"] = len(energylist) # プログレスバーの最大値
    pb3["value"] = 0
    pb3.update()

    #qとhwのメッシュを用意する
    qmin = float(txt01_p.get())
    qmax = float(txt02_p.get())
    qbin = float(txt03_p.get())
    # smoothing
    if fgt_txt4.get()=="":
        dQ = 0
        #fgt_txt4.insert(0,qbin)
    else:
        dQ = (float(fgt_txt4.get())-qbin)/2
        
    if bgt_txt6.get()=="":
        sb_dQ = 0
    else:
        sb_dQ = (float(bgt_txt6.get())-qbin)/2
    
    if qmin > qmax:
        return
    elif qmin > qmax:
        return
    elif qbin < 0:
        return
    global nq
    nq=round((qmax-qmin)/qbin+1)
    
    global Q
    Q=np.zeros((nq))
    for i in range(nq):
        Q[i] = qmin + qbin * i

    hw_num = int(len(energylist)+1)
    global hwlist_p
    hwlist_p=np.zeros(hw_num)
    #hwが1つのときの例外処理として装置分解能の範囲を出力するようにする
    if hw_num==2:
        hwlist_p[0] = float(energylist[0]-(ef_tol+0.005))
        hwlist_p[1] = float(energylist[-1]+(ef_tol+0.005))
    else:
        hwlist_p[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        hwlist_p[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        #hwlist4[0] = float(energylist[0])-(float(energylist[1])-float(energylist[0]))
        #hwlist4[-1] = float(energylist[-1])+(float(energylist[-1])-float(energylist[-2]))

        for ne in range(hw_num-2):
            hwlist_p[ne+1] = (float(energylist[ne])+float(energylist[ne+1]))/2

    # 強度とエラーバーのセルを用意する。2次元の行列
    global Ipow,Ipow_err,sb_Ipow,sb_Ipow_err
    Ipow = None
    Ipow_err = None
    sb_Ipow = None
    sb_Ipow_err = None
    Ipow=np.zeros((len(energylist),nq-1))
    Ipow_err=np.zeros((len(energylist),nq-1))
    sb_Ipow=np.zeros((len(energylist),nq-1))
    sb_Ipow_err=np.zeros((len(energylist),nq-1))

    global Q2
    Q2=np.zeros(nq-1)
    
    # メッシュの中にデータを入れていく。
    # S(q,w)の場合
    if CSX.get()==1:# S(q,w), kf/ki
        ssf1=1
        ssf2=float(sb_txt1.get())
        if len(sbfile_paths)>0:
            for ne in range(len(energylist)):
                # エネルギートランスファーのトレランスを読み込む。
                # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す
                Databox_kari = None
                sb_Databox_kari=None
                ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                sb_ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEbg) <= sb_databox[3,:]) & (sb_databox[3,:] < (energylist[ne]+E_T+dEbg))))))
                if not ind_e:
                    energylist[ne] = energylist[ne]
                else:
                    energylist[ne] = np.mean(databox[3,ind_e])
                
                Ind_e = list(np.ravel(ind_e))
                Databox_kari = databox[:,Ind_e]
                sb_Ind_e = list(np.ravel(sb_ind_e))
                sb_Databox_kari = sb_databox[:,sb_Ind_e]
                
                for npow in range(nq-1):
                    Q2[npow] = (Q[npow]+Q[npow+1])/2
                    #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                    #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                    # Qセルの条件を満たすインデックスを取得。
                    ind_q = (list(zip(*np.where(( Q[npow]-dQ < Databox_kari[2,:] ) & (Databox_kari[2,:] <= Q[npow+1]+dQ)))))
                    sb_ind_q = (list(zip(*np.where(( Q[npow]-sb_dQ < sb_Databox_kari[2,:] ) & (sb_Databox_kari[2,:] <= Q[npow+1]+sb_dQ)))))
                    
                    # ind_qが何もない場合はnan値として出力されるから良し
                    # ind_qを1次元化して0の要素を省く。そしてリスト型にして取り出す
                    Ind_q = list(np.ravel(ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    Ipow[ne,npow]=(np.nanmean(Databox_kari[4,:][Ind_q]))*ssf1
                    Ipow_err[ne,npow]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_q],Databox_kari[5,:][Ind_q])))**(1/2))/(len(Ind_q))*ssf1
                    sb_Ind_q = list(np.ravel(sb_ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    sb_Ipow[ne,npow]=(np.nanmean(sb_Databox_kari[4,:][sb_Ind_q]))*ssf2
                    sb_Ipow_err[ne,npow]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_q],sb_Databox_kari[5,:][sb_Ind_q])))**(1/2))/(len(sb_Ind_q))*ssf2
                        
                Ipow = np.where(np.isfinite(Ipow), Ipow, np.nan)
                Ipow_err = np.where(np.isfinite(Ipow_err), Ipow_err, np.nan)
                sb_Ipow = np.where(np.isfinite(sb_Ipow), sb_Ipow, np.nan)
                sb_Ipow_err = np.where(np.isfinite(sb_Ipow_err), sb_Ipow_err, np.nan)
                # プログレスバー (確定的)。エネルギー毎にステータスが進む
                var3=var3+1
                pb3["value"] = var3
                pb3.update()
            # nanから数値を引くことはできない。nanを0にする
            Ipow_trans=np.nan_to_num(Ipow, nan=0)-np.nan_to_num(sb_Ipow, nan=0)
            # nanから数値を引くことはできない。nanを0にする
            Ipow_err_trans=np.sqrt(np.square(np.nan_to_num(Ipow_err, nan=0))+np.square(np.nan_to_num(sb_Ipow_err, nan=0)))
            
            if sbtype2.get()==0:
                # 差し引き後に両方の要素でnan値であった部分をnan値にする。
                Ipow_trans[np.isnan(Ipow) & np.isnan(sb_Ipow)] = np.nan
                Ipow_err_trans[np.isnan(Ipow_err) & np.isnan(sb_Ipow_err)] = np.nan
            elif sbtype2.get()==1:
                # 差し引き後にFGもしくはBGの要素でnan値であった部分をnan値にする。
                Ipow_trans[np.isnan(Ipow) | np.isnan(sb_Ipow)] = np.nan
                Ipow_err_trans[np.isnan(Ipow_err) | np.isnan(sb_Ipow_err)] = np.nan
            
            Ipow=Ipow_trans
            Ipow_err=Ipow_err_trans

        else:# バックグラウンドファイルが無い場合
            for ne in range(len(energylist)):
                # エネルギートランスファーのトレランスを読み込む。
                # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す
                Databox_kari = None
                ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                if not ind_e:
                    energylist[ne] = energylist[ne]
                else:
                    energylist[ne] = np.mean(databox[3,ind_e])
                Ind_e = list(np.ravel(ind_e))
                
                Databox_kari = databox[:,Ind_e]
                for npow in range(nq-1):
                    Q2[npow] = (Q[npow]+Q[npow+1])/2
                    #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                    #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                    # Qセルの条件を満たすインデックスを取得。
                    ind_q = (list(zip(*np.where(( Q[npow]-dQ < Databox_kari[2,:] ) & (Databox_kari[2,:] <= Q[npow+1]+dQ)))))
                    # ind_qが何もない場合はnan値として出力されるから良し
                    # ind_qを1次元化して0の要素を省く。そしてリスト型にして取り出す
                    Ind_q = list(np.ravel(ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    Ipow[ne,npow]=(np.nanmean(Databox_kari[4,:][Ind_q]))*ssf1
                    Ipow_err[ne,npow]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_q],Databox_kari[5,:][Ind_q])))**(1/2))/(len(Ind_q))*ssf1
                    #sb_Ind_q = list(np.ravel(sb_ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    #sb_Ipow[ne,npow]=(np.nanmean(sb_Databox_kari[4,:][sb_Ind_q]))
                    #sb_Ipow_err[ne,npow]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_q],sb_Databox_kari[5,:][sb_Ind_q])))**(1/2))/(len(sb_Ind_q))
                        
                #Ipow = np.where(np.isfinite(Ipow), Ipow, np.nan)
                #Ipow_err = np.where(np.isfinite(Ipow_err), Ipow_err, np.nan)
                #sb_Ipow = np.where(np.isfinite(sb_Ipow), sb_Ipow, np.nan)
                #sb_Ipow_err = np.where(np.isfinite(sb_Ipow_err), sb_Ipow_err, np.nan)
                # プログレスバー (確定的)。エネルギー毎にステータスが進む
                var3=var3+1
                pb3["value"] = var3
                pb3.update()
    elif CSX.get()==2:# χ(q,w), kf/ki
        if len(sbfile_paths)>0:
            for ne in range(len(energylist)):
                # エネルギートランスファーのトレランスを読み込む。
                # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す
                Databox_kari = None
                sb_Databox_kari=None
                ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                sb_ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEbg) <= sb_databox[3,:]) & (sb_databox[3,:] < (energylist[ne]+E_T+dEbg))))))
                if not ind_e:
                    energylist[ne] = energylist[ne]
                else:
                    energylist[ne] = np.mean(databox[3,ind_e])
                if energylist[ne]>=0:
                    ssf1=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt2.get())))
                    ssf2=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt3.get())))
                else:
                    ssf1=(math.exp(11.60497*-(energylist[ne])/float(sb_txt2.get()))-1)
                    ssf2=(math.exp(11.60497*-(energylist[ne])/float(sb_txt3.get()))-1)
                
                Ind_e = list(np.ravel(ind_e))
                Databox_kari = databox[:,Ind_e]
                sb_Ind_e = list(np.ravel(sb_ind_e))
                sb_Databox_kari = sb_databox[:,sb_Ind_e]
                
                for npow in range(nq-1):
                    Q2[npow] = (Q[npow]+Q[npow+1])/2
                    #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                    #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                    # Qセルの条件を満たすインデックスを取得。
                    ind_q = (list(zip(*np.where(( Q[npow]-dQ < Databox_kari[2,:] ) & (Databox_kari[2,:] <= Q[npow+1]+dQ)))))
                    sb_ind_q = (list(zip(*np.where(( Q[npow]-sb_dQ < sb_Databox_kari[2,:] ) & (sb_Databox_kari[2,:] <= Q[npow+1]+sb_dQ)))))
                    
                    # ind_qが何もない場合はnan値として出力されるから良し
                    # ind_qを1次元化して0の要素を省く。そしてリスト型にして取り出す
                    Ind_q = list(np.ravel(ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    Ipow[ne,npow]=(np.nanmean(Databox_kari[4,:][Ind_q]))*ssf1
                    Ipow_err[ne,npow]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_q],Databox_kari[5,:][Ind_q])))**(1/2))/(len(Ind_q))*ssf1
                    sb_Ind_q = list(np.ravel(sb_ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    sb_Ipow[ne,npow]=(np.nanmean(sb_Databox_kari[4,:][sb_Ind_q]))*ssf2
                    sb_Ipow_err[ne,npow]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_q],sb_Databox_kari[5,:][sb_Ind_q])))**(1/2))/(len(sb_Ind_q))*ssf2
                        
                Ipow = np.where(np.isfinite(Ipow), Ipow, np.nan)
                Ipow_err = np.where(np.isfinite(Ipow_err), Ipow_err, np.nan)
                sb_Ipow = np.where(np.isfinite(sb_Ipow), sb_Ipow, np.nan)
                sb_Ipow_err = np.where(np.isfinite(sb_Ipow_err), sb_Ipow_err, np.nan)
                # プログレスバー (確定的)。エネルギー毎にステータスが進む
                var3=var3+1
                pb3["value"] = var3
                pb3.update()
            # nanから数値を引くことはできない。nanを0にする
            Ipow_trans=np.nan_to_num(Ipow, nan=0)-np.nan_to_num(sb_Ipow, nan=0)
            # nanから数値を引くことはできない。nanを0にする
            Ipow_err_trans=np.sqrt(np.square(np.nan_to_num(Ipow_err, nan=0))+np.square(np.nan_to_num(sb_Ipow_err, nan=0)))
            
            if sbtype2.get()==0:
                # 差し引き後に両方の要素でnan値であった部分をnan値にする。
                Ipow_trans[np.isnan(Ipow) & np.isnan(sb_Ipow)] = np.nan
                Ipow_err_trans[np.isnan(Ipow_err) & np.isnan(sb_Ipow_err)] = np.nan
            elif sbtype2.get()==1:
                # 差し引き後にFGもしくはBGの要素でnan値であった部分をnan値にする。
                Ipow_trans[np.isnan(Ipow) | np.isnan(sb_Ipow)] = np.nan
                Ipow_err_trans[np.isnan(Ipow_err) | np.isnan(sb_Ipow_err)] = np.nan
            
            Ipow=Ipow_trans
            Ipow_err=Ipow_err_trans

        else:# バックグラウンドファイルが無い場合
            for ne in range(len(energylist)):
                # エネルギートランスファーのトレランスを読み込む。
                # 条件を満たすインデックスを取得。まずエネルギーが一致している部分を取り出す
                Databox_kari = None
                ind_e = (list(zip(*np.where(((energylist[ne]-E_T-dEfg) <= databox[3,:]) & (databox[3,:] < (energylist[ne]+E_T+dEfg))))))
                if not ind_e:
                    energylist[ne] = energylist[ne]
                else:
                    energylist[ne] = np.mean(databox[3,ind_e])
                if energylist[ne]>=0:
                    ssf1=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt2.get())))
                    ssf2=(1-math.exp(-11.60497*(energylist[ne])/float(sb_txt3.get())))
                else:
                    ssf1=(math.exp(11.60497*-(energylist[ne])/float(sb_txt2.get()))-1)
                    ssf2=(math.exp(11.60497*-(energylist[ne])/float(sb_txt3.get()))-1)
                
                Ind_e = list(np.ravel(ind_e))
                Databox_kari = databox[:,Ind_e]
                for npow in range(nq-1):
                    Q2[npow] = (Q[npow]+Q[npow+1])/2
                    #pixeld_data=Qvector[0,:][ ( QU[nx] < Qvector[0,:] ) & (Qvector[0,:] <= QU[nx])]
                    #pixeld_data2=Qvector[1,:][ ( QV[ny] < Qvector[1,:] ) & (Qvector[1,:] <= QV[ny])]
                    # Qセルの条件を満たすインデックスを取得。
                    ind_q = (list(zip(*np.where(( Q[npow]-dQ < Databox_kari[2,:] ) & (Databox_kari[2,:] <= Q[npow+1]+dQ)))))
                    # ind_qが何もない場合はnan値として出力されるから良し
                    # ind_qを1次元化して0の要素を省く。そしてリスト型にして取り出す
                    Ind_q = list(np.ravel(ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    Ipow[ne,npow]=(np.nanmean(Databox_kari[4,:][Ind_q]))*ssf1
                    Ipow_err[ne,npow]=((np.nansum(np.multiply(Databox_kari[5,:][Ind_q],Databox_kari[5,:][Ind_q])))**(1/2))/(len(Ind_q))*ssf1
                    #sb_Ind_q = list(np.ravel(sb_ind_q)[::1])
                    # ind_xが何もない場合はnan値として出力されるから良し
                    #sb_Ipow[ne,npow]=(np.nanmean(sb_Databox_kari[4,:][sb_Ind_q]))
                    #sb_Ipow_err[ne,npow]=((np.nansum(np.multiply(sb_Databox_kari[5,:][sb_Ind_q],sb_Databox_kari[5,:][sb_Ind_q])))**(1/2))/(len(sb_Ind_q))
                        
                #Ipow = np.where(np.isfinite(Ipow), Ipow, np.nan)
                #Ipow_err = np.where(np.isfinite(Ipow_err), Ipow_err, np.nan)
                #sb_Ipow = np.where(np.isfinite(sb_Ipow), sb_Ipow, np.nan)
                #sb_Ipow_err = np.where(np.isfinite(sb_Ipow_err), sb_Ipow_err, np.nan)
                # プログレスバー (確定的)。エネルギー毎にステータスが進む
                var3=var3+1
                pb3["value"] = var3
                pb3.update()

def p_set_range():
    # 小数点第３位を四捨五入。float(format(a, '.2f'))±0.01
    txt04_p.delete(0,tk.END)
    txt05_p.delete(0,tk.END)
    txt06_p.delete(0,tk.END)
    
    txt04_p.insert(0, round(np.nanmin(databox[3, :]), 3))
    txt05_p.insert(0, round(np.nanmax(databox[3, :]), 3))
    
    E_T = round(ef_tol+0.005,3)
    # もとのコード
    energylist=(list(set(databox[3,:])))
    # さらにソートする(元のリストを書き換え)
    energylist.sort()
    # さらにエネルギートランスファーのトレランスを考慮して±E_TmeV以内は同じ数値にする。
    Energylist = [energylist[0]]  # 初めて値を代入

    for i in range(1, (len(energylist)-1)):
        if Energylist[-1] <= energylist[i] and energylist[i] < Energylist[-1] + 2*E_T:
            pass
        else:
            Energylist.append(energylist[i+1])
    # 最後の範囲が記録されないので最後に付け足す。
    if Energylist[-1] == energylist[-1]:
        pass
    else:
        Energylist.append(energylist[-1])
    # energylistを再構成
    energylist=list(set(Energylist))
    energylist.sort()
    
    # 差分の平均値を計算
    estep = np.nanmean(np.diff(energylist))
    
    txt06_p.insert(0, round(estep+0.005, 3))
    
    txt01_p.delete(0,tk.END)
    txt02_p.delete(0,tk.END)
    if 'sb_databox' in globals():
        if np.nanmin(databox[2, :])<=np.nanmin(sb_databox[2, :]):
            txt01_p.insert(0, round(np.nanmin(databox[2, :]) - 0.01, 2))
        else:
            txt01_p.insert(0, round(np.nanmin(sb_databox[2, :]) - 0.01, 2))
        if np.nanmax(databox[2, :])<=np.nanmax(sb_databox[2, :]):
            txt02_p.insert(0, round(np.nanmax(sb_databox[2, :]) + 0.01, 2))
        else:
            txt02_p.insert(0, round(np.nanmax(databox[2, :]) + 0.01, 2))
    else:
        txt01_p.insert(0, round(np.nanmin(databox[2, :]) - 0.01, 2))
        txt02_p.insert(0, round(np.nanmax(databox[2, :]) + 0.01, 2))
        
    # 差を求める。
    # hwの最大値からq間隔の最大値を求める。
    ki_norm=((3.635+11)/2.072)**(1/2)
    kf_norm=((3.635)/2.072)**(1/2)
    q_1=(ki_norm**2+kf_norm**2-2*ki_norm*kf_norm*math.cos(math.radians(54)))**(1/2)
    q_2=(ki_norm**2+kf_norm**2-2*ki_norm*kf_norm*math.cos(math.radians(56)))**(1/2)
    dq=format(float(abs(q_2-q_1)), '.2f')
    txt03_p.delete(0,tk.END)
    txt03_p.insert(0,dq)

# hwに関するoptionボタン
# チェック有無変数
hwp_nan = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
hwp_nan.set(0)

hwp_nan_op = tk.Checkbutton(frame1p, variable=hwp_nan, text='ℏω cell')
hwp_nan_op.grid(row=2, column=0, columnspan=2,sticky="NSEW")

def toggle_entry_hwpcell():
    if hwp_nan.get()==0:
        txt04_p.config(state=tk.DISABLED) # min hw 
        txt05_p.config(state=tk.DISABLED) # max hw
        txt06_p.config(state=tk.DISABLED) # bin hw
        #fgt_txt1.config(state=tk.NORMAL) # tolerance ±δhw (FG)
        #bgt_txt1.config(state=tk.NORMAL) # tolerance ±δhw (BG)
    elif  hwp_nan.get()==1:#ユーザーがhw cellを指定したい場合
        txt04_p.config(state=tk.NORMAL) # min hw 
        txt05_p.config(state=tk.NORMAL) # max hw
        txt06_p.config(state=tk.NORMAL) # bin hw
        #fgt_txt1.config(state=tk.DISABLED) # tolerance ±δhw (FG)
        #bgt_txt1.config(state=tk.DISABLED) # tolerance ±δhw (BG)

# プログラム開始時に一度だけtoggle_entryを呼び出す
toggle_entry_hwpcell()

# Radiobutton選択状態の変更時にtoggle_entry関数を呼び出す
hwp_nan.trace('w', lambda *args: toggle_entry_hwpcell())
    
# 自動でボックスのサイズを決めてくれるボタン
button1_p_0 = ttk.Button(frame1p,text="auto bin",command=p_set_range,width=12)
button1_p_0.grid(row=2, column=2, columnspan=2,sticky="NSEW")

# 指定した範囲とbinサイズの箱にデータを詰めるボタン
button1_p = ttk.Button(frame1p,text="re-bin",command=pow_data_box,width=12)
button1_p.grid(row=2, column=4, columnspan=2,sticky="NSEW")

# powderデータを見たり、1Dカットしたりするボタン周りのフレーム作成。
frame2p = ttk.Labelframe(tab_02, text= "create figure")
frame2p.grid(row = 1, column = 0,sticky="NSEW")
#frame2p.grid_propagate(True)

# Notebookウィジェットの作成
notebookp = ttk.Notebook(frame2p,style="example.TNotebook")

# タブの作成
tab_2dp = tk.Frame(notebookp)
tab_1dp = tk.Frame(notebookp)
tab_ptas = tk.Frame(notebookp)

# notebookにタブを追加
notebookp.add(tab_2dp, text="2D view")# 2D mapの表示
notebookp.add(tab_1dp, text="1D view")# 1D mapの表示
notebookp.add(tab_ptas, text="TAS mode")# TAS modeの表示

tab_2dp.columnconfigure(0, weight=1)
tab_2dp.rowconfigure(1, weight=1)
tab_2dp.rowconfigure(2, weight=1)
tab_2dp.rowconfigure(3, weight=1)

tab_1dp.columnconfigure(0, weight=1)
tab_1dp.columnconfigure(1, weight=1)
tab_1dp.columnconfigure(2, weight=1)
tab_1dp.columnconfigure(3, weight=1)
tab_1dp.rowconfigure(0, weight=1)
tab_1dp.rowconfigure(1, weight=1)
tab_1dp.rowconfigure(2, weight=1)
tab_1dp.rowconfigure(3, weight=1)

tab_ptas.columnconfigure(0, weight=1)
tab_ptas.columnconfigure(1, weight=1)
tab_ptas.columnconfigure(2, weight=1)
tab_ptas.columnconfigure(3, weight=1)
tab_ptas.rowconfigure(0, weight=1)
tab_ptas.rowconfigure(1, weight=1)
tab_ptas.rowconfigure(2, weight=1)
tab_ptas.rowconfigure(3, weight=1)

# ウィジェットの配置
notebookp.pack(expand=True, fill='both')

################################################
# グラフオプションの定義

# graph opetionを表示するボタン周りのフレーム作成。
frame3p = ttk.Labelframe(tab_02, text= "option")
frame3p.grid(row = 0, column = 2, sticky="NSEW")
#frame3p.grid_propagate(True)

frame3p.columnconfigure(0, weight=1)
frame3p.rowconfigure(0, weight=1)
frame3p.rowconfigure(1, weight=1)
frame3p.rowconfigure(2, weight=1)

# チェック有無変数
axistypep = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
axistypep.set(0)

# ラジオボタン作成
#rdolbl = tk.Label(frameGL, text='axis type',width=7)
#rdolbl.grid(row=0,column=6,columnspan=2)

# powder option
#at=axistype.get()で線形スケールかログスケールを選択
rdo_at1p = tk.Radiobutton(frame3p, value=0, variable=axistypep, text='linear')#もともとframeGL
rdo_at1p.grid(row=0,column=0,sticky="NSEW")

rdo_at2p = tk.Radiobutton(frame3p, value=1, variable=axistypep, text='log')#もともとframeGL
rdo_at2p.grid(row=1,column=0,sticky="NSEW")

# チェック有無変数
gridtypep = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
gridtypep.set(1)

#gt=gridtype.get()でグリッドをonかoffかを選択
# チェック有無変数
gridtypep = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
gridtypep.set(1)

rdo_gtp = tk.Checkbutton(frame3p, variable=gridtypep, text='grid')
rdo_gtp.grid(row=2, column=0,sticky="NSEW")

################################################
# graph scaleの定義

# graph scaleを表示するボタン周りのフレーム作成。
frameGSp = ttk.Labelframe(tab_02, text= "graph scale")
frameGSp.grid(row = 1, column = 1,columnspan=2,sticky="NSEW")
#frameGSp.grid_propagate(True)

frameGSp.columnconfigure(0, weight=1)
frameGSp.columnconfigure(1, weight=1)
frameGSp.columnconfigure(2, weight=1)
frameGSp.rowconfigure(0, weight=1)
frameGSp.rowconfigure(1, weight=1)
frameGSp.rowconfigure(2, weight=1)
frameGSp.rowconfigure(3, weight=1)
frameGSp.rowconfigure(4, weight=1)

graph_scale_lbl0 = tk.Label(frameGSp,text='min',width=6)
graph_scale_lbl0.grid(row=0, column=1,sticky="NSEW")
graph_scale_lbl1 = tk.Label(frameGSp,text='max',width=6)
graph_scale_lbl1.grid(row=0, column=2,sticky="NSEW")

scale_p_Emin_lbl = tk.Label(frameGSp,text='ℏω',width=6)
scale_p_Emin_lbl.grid(row=1, column=0,sticky="NSEW")
scale_p_Emin_txt = ttk.Entry(frameGSp,width=6)
scale_p_Emin_txt.grid(row=1, column=1,sticky="NSEW")
scale_p_Emax_txt = ttk.Entry(frameGSp,width=6)
scale_p_Emax_txt.grid(row=1, column=2,sticky="NSEW")

scale_p_Qmin_lbl = tk.Label(frameGSp,text='Q',width=6)
scale_p_Qmin_lbl.grid(row=2, column=0,sticky="NSEW")
scale_p_Qmin_txt = ttk.Entry(frameGSp,width=6)
scale_p_Qmin_txt.grid(row=2, column=1,sticky="NSEW")
scale_p_Qmax_txt = ttk.Entry(frameGSp,width=6)
scale_p_Qmax_txt.grid(row=2, column=2,sticky="NSEW")

scale_p_Imin_lbl = tk.Label(frameGSp,text='I',width=6)
scale_p_Imin_lbl.grid(row=3, column=0,sticky="NSEW")
scale_p_Imin_txt = ttk.Entry(frameGSp,width=6)
scale_p_Imin_txt.grid(row=3, column=1,sticky="NSEW")
scale_p_Imax_txt = ttk.Entry(frameGSp,width=6)
scale_p_Imax_txt.grid(row=3, column=2,sticky="NSEW")

def gsp_clear():
    scale_p_Emin_txt.delete(0,tk.END)
    scale_p_Emax_txt.delete(0,tk.END)
    scale_p_Qmin_txt.delete(0,tk.END)
    scale_p_Qmax_txt.delete(0,tk.END)
    scale_p_Imin_txt.delete(0,tk.END)
    scale_p_Imax_txt.delete(0,tk.END)

gsp_clear = ttk.Button(frameGSp,text="clear",command=gsp_clear,width=6)
gsp_clear.grid(row=0, column=0,sticky="NSEW")

def gsp_auto():
    scale_p_Emin_txt.delete(0,tk.END)
    scale_p_Emax_txt.delete(0,tk.END)
    if round(energylist[0], 2) == round(energylist[-1], 2):
        scale_p_Emin_txt.insert(0, round(energylist[0]-(ef_tol), 2))
        scale_p_Emax_txt.insert(0, round(energylist[-1]+(ef_tol), 2))
    else:
        scale_p_Emin_txt.insert(0, round(energylist[0], 2))
        scale_p_Emax_txt.insert(0, round(energylist[-1], 2))
    scale_p_Qmin_txt.delete(0,tk.END)
    scale_p_Qmin_txt.insert(0, round(np.min(Q),2))
    scale_p_Qmax_txt.delete(0,tk.END)
    scale_p_Qmax_txt.insert(0, round(np.max(Q),2))
    scale_p_Imin_txt.delete(0,tk.END)
    scale_p_Imax_txt.delete(0,tk.END)
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if np.nanmean(Ipow) >= 0:
        scale_p_Imax_txt.insert(0,round(np.nanmean(Ipow),1))
        scale_p_Imin_txt.insert(0,0)
    elif np.nanmean(Ipow) < 0:
        scale_p_Imin_txt.insert(0,round(np.nanmean(Ipow),1))
        scale_p_Imax_txt.insert(0,np.abs(round(np.nanmean(Ipow),1)))

gsp_auto = ttk.Button(frameGSp,text="auto scale",command=gsp_auto)
gsp_auto.grid(row=4, column=0, columnspan=3,sticky="NSEW")


################################################
# 2d view

# powderデータを表示するボタンの定義
def show_powderEmap():
    #図を出力する
    # グラフの出力範囲を指定する。
    if scale_p_Qmin_txt.get()=="":
        Qlim_min=round(np.min(Q),2)
    else:
        Qlim_min=float(scale_p_Qmin_txt.get())
    if scale_p_Qmax_txt.get()=="":
        Qlim_max=round(np.max(Q),2)
    else:
        Qlim_max=float(scale_p_Qmax_txt.get())
    if scale_p_Emin_txt.get()=="":
        Elim_min=energylist[0]
    else:
        Elim_min=float(scale_p_Emin_txt.get())
    if scale_p_Emax_txt.get()=="":
        Elim_max=energylist[-1]
    else:
        Elim_max=float(scale_p_Emax_txt.get())
        
    #intensityの範囲
    # カラーバースケール。空欄の場合は平均値を出力するようにする。
    if scale_p_Imin_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_min=0
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_min=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
    else:
        z_min=float(scale_p_Imin_txt.get())
    if scale_p_Imax_txt.get()=="":
        if np.mean(databox[4,:])+np.mean(databox[5,:]) >= 0:
            z_max=round(np.mean(databox[4,:])+np.mean(databox[5,:]),1)
        elif np.mean(databox[4,:])+np.mean(databox[5,:]) < 0:
            z_max=round(np.abs(np.mean(databox[4,:])+np.mean(databox[5,:])),1)
    else:
        z_max=float(scale_p_Imax_txt.get())
    
    #fig, ax = plt.figure()
    #axにカラーバーを表示
    fig11, ax = plt.subplots()
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.2)
    # グリッド線を引く
    gt=gridtypep.get()
    if gt == 0:
        #ax.set_axisbelow(True)  # グリッド線を背面に配置
        ax.grid(False)
    elif gt == 1:
        ax.grid(True)
    #im=plt.pcolormesh(Q, hwlist_p , Ipow, cmap='jet', vmin=z_min, vmax=z_max)
    at=axistypep.get()
    if at==0:
        im=plt.pcolormesh(Q, hwlist_p , Ipow, cmap='jet', vmin=z_min, vmax=z_max)
    elif at==1:
        if z_min==0:
            z_min=np.nanmin(Ipow[Ipow != 0])
            im=plt.pcolormesh(Q, hwlist_p , Ipow, cmap='jet', norm = LogNorm(vmin=np.nanmin(Ipow[Ipow != 0]), vmax=z_max))
        else:
            im=plt.pcolormesh(Q, hwlist_p , Ipow, cmap='jet', norm = LogNorm(vmin=z_min, vmax=z_max))
    cbar=plt.colorbar(im,ticks=mticker.LinearLocator(numticks=3))
    # カラーバーのタイトルを設定
    cbar.set_label('Intenisty (a.u.)')
    ax.set_xlabel("Q (Å^-1)")
    ax.set_ylabel("ℏω (meV)")
    #, cmap="jet", extend='both',ticks=np.linspace(vmin, vmax, 5)
    #plt.axis('tight')
    #横スライドでエネルギートランスファーを変更、縦スライドで強度の最大値を変更
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(Qlim_min, 3)
    default_xmax = round(Qlim_max, 3)

    default_ymin = round(Elim_min, 3)
    default_ymax = round(Elim_max, 3)
    
    default_zmin = round(z_min, 3)
    default_zmax = round(z_max, 3)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.6, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    zmin_box = TextBox(plt.axes([0.9, 0.2, 0.08, 0.05]), 'zMin:', initial=str(default_zmin))
    zmax_box = TextBox(plt.axes([0.9, 0.83, 0.08, 0.05]), 'zMax:', initial=str(default_zmax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            zmin_val = float(zmin_box.text)
            zmax_val = float(zmax_box.text)
            cbar.mappable.set_clim(vmin=zmin_val, vmax=zmax_val)
            fig11.canvas.draw_idle()
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    zmin_box.on_submit(update_axis_range)
    zmax_box.on_submit(update_axis_range)
    
    plt.show()

# powderのmapを表示するボタン
button2_p = ttk.Button(tab_2dp,text="powder map",command=show_powderEmap,width=12)
button2_p.grid(row=2, column=0,sticky="NSEW")

# ダミーのラベル
lbl2_p1 = tk.Label(tab_2dp,text='',width=6)
lbl2_p1.grid(row=0, column=0,sticky="NSEW")
lbl2_p1 = tk.Label(tab_2dp,text='',width=6)
lbl2_p1.grid(row=1, column=0,sticky="NSEW")
lbl2_p1 = tk.Label(tab_2dp,text='',width=6)
lbl2_p1.grid(row=3, column=0,sticky="NSEW")

####################################################
# 1D view

# 1次元カット用の入力欄
# Q範囲指定
lbl11_p = tk.Label(tab_1dp,text='Q',width=6)
lbl11_p.grid(row=0, column=0,sticky="NSEW")
lbl12_p = tk.Label(tab_1dp,text='±Q',width=6)
lbl12_p.grid(row=0, column=1,sticky="NSEW")

txt11_p = ttk.Entry(tab_1dp,width=6)
txt11_p.insert(0,'0')
txt11_p.grid(row=1, column=0,sticky="NSEW")
txt12_p = ttk.Entry(tab_1dp,width=6)
txt12_p.insert(0,'0.1')
txt12_p.grid(row=1, column=1,sticky="NSEW")

# E範囲指定
lbl13_p = tk.Label(tab_1dp,text='ℏω',width=6)
lbl13_p.grid(row=0, column=2,sticky="NSEW")
lbl14_p = tk.Label(tab_1dp,text='±ℏω',width=6)
lbl14_p.grid(row=0, column=3,sticky="NSEW")

txt13_p = ttk.Entry(tab_1dp,width=6)
txt13_p.insert(0,'0')
txt13_p.grid(row=1, column=2,sticky="NSEW")
txt14_p = ttk.Entry(tab_1dp,width=6)
txt14_p.insert(0,'0.1')
txt14_p.grid(row=1, column=3,sticky="NSEW")

# エネルギー方向の1次元カット
def show_1D_EvsI():
    #既に記入しているUとVの範囲を読み出し。
    Qc=float(txt11_p.get())
    Qpm=float(txt12_p.get())
    global Ipow_1dei,Ipowerr_1dei
    Ipow_1dei = np.zeros(len(energylist))
    Ipowerr_1dei = np.zeros(len(energylist))
    # 条件を満たすインデックスを取得。
    if Qpm==0:
        Pow1D_Q = [np.abs(Q2 - Qc).argmin()]
    else:
        pow1D_Q = list(zip(*np.where((Qc - Qpm <= Q2) & (Q2 <= Qc + Qpm))))
        Pow1D_Q = list(np.ravel(pow1D_Q))
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Pow1D_Q)!=0:
        for ll in range(len(energylist)):
            n_nanind = (list(zip(*np.where(~np.isnan(Ipow[ll,Pow1D_Q])))))
            N_nanind = list(np.ravel(n_nanind)[::1])
            if N_nanind:
                #I_1DU[mm]=np.sum(I_ce[ind_cE1dV,mm][~np.isnan(I_ce[ind_cE1dV,ll])])/(len(I_ce[n_nanind[0]]))
                Ipow_1dei[ll] = (np.nansum(Ipow[ll,Pow1D_Q]))/(len(N_nanind))
                Ipowerr_1dei[ll] = ((np.nansum(np.multiply(Ipow_err[ll,Pow1D_Q],Ipow_err[ll,Pow1D_Q])))**(1/2))/(len(N_nanind))
            else:
                Ipow_1dei[ll] = np.nan
                Ipowerr_1dei[ll] = np.nan

        # 例外処理
        if len(list(zip(*np.where(~np.isnan(Ipow_1dei)))))!=0:
            if scale_p_Emin_txt.get()=="":
                xlim_min=energylist[0]
            else:
                xlim_min=float(scale_p_Emin_txt.get())
                
            if scale_p_Emax_txt.get()=="":
                xlim_max=energylist[-1]
            else:
                xlim_max=float(scale_p_Emax_txt.get())
                
            if scale_p_Imin_txt.get()=="":
                if np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei) >= 0:
                    ylim_min=0
                elif np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei) < 0:
                    ylim_min=round(np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei),1)
            else:
                ylim_min=float(scale_p_Imin_txt.get())
            if scale_p_Imax_txt.get()=="":
                if np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei) >= 0:
                    ylim_max=round(np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei),1)
                elif np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei) < 0:
                    ylim_max=round(np.abs(np.nanmax(Ipow_1dei)+np.nanmax(Ipowerr_1dei)),1)
            else:
                ylim_max=float(scale_p_Imax_txt.get())
                        
            # エラーバーのグラフを作成
            global oneDPE
            fig12=plt.figure()
            
            # グラフ内に表示範囲を決定するボックス
            # 最小値と最大値の初期値
            default_xmin = round(xlim_min, 2)
            default_xmax = round(xlim_max, 2)

            default_ymin = round(ylim_min, 2)
            default_ymax = round(ylim_max, 2)

            # テキストボックスを作成して最小値と最大値を設定
            xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
            xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
            ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
            ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
            
            # 最小値と最大値が変更されたときに呼び出される関数
            def update_axis_range(text):
                try:
                    xmin_val = float(xmin_box.text)
                    xmax_val = float(xmax_box.text)
                    ax12.set_xlim(xmin_val, xmax_val)
                    ymin_val = float(ymin_box.text)
                    ymax_val = float(ymax_box.text)
                    ax12.set_ylim(ymin_val, ymax_val)
                    fig12.canvas.draw_idle()
                except ValueError:
                    pass

            xmin_box.on_submit(update_axis_range)
            xmax_box.on_submit(update_axis_range)
            ymin_box.on_submit(update_axis_range)
            ymax_box.on_submit(update_axis_range)
            
            # 現在のFigure番号を取得
            oneDPE = plt.gcf().number
            fig12.subplots_adjust(left=0.30, bottom=0.2)
            ax12 = fig12.add_subplot(111)
            #plt.text(0.1,1.1,'Q = %.3f' %Qc, transform=ax.transAxes)
            #plt.text(0.3,1.1,' ± %.3f r.l.u.' %Qpm, transform=ax.transAxes)
            plt.xlabel("ℏω (meV)")
            plt.ylabel("Intensity (a. u.)")
            ax12.errorbar(energylist, Ipow_1dei, yerr=Ipowerr_1dei, capsize=10,label='Q='+str(Qc)+'±'+str(Qpm)+'(Å^-1)')
            at=axistypep.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(Ipow_1dei)-np.nanmax(Ipowerr_1dei)
            global elist,qlist
            elist = energylist
            qlist = [Qc-Qpm,Qc+Qpm]
            ax12.legend()
            ax12.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            ax12.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            #plt.tick_params(labelsize=20)
            plt.grid()
            plt.show()
            
    else:
        pass

# powderの1次元カットを表示するボタン
button3_p = ttk.Button(tab_1dp,text="I vs ℏω",command=show_1D_EvsI,width=12)
button3_p.grid(row=2, column=0,columnspan=2,sticky="NSEW")

# 追加の1Dカットを重ね書きする機能の定義
def btn_click_1DPE():
#既に記入しているUとVの範囲を読み出し。
    Qc=float(txt11_p.get())
    Qpm=float(txt12_p.get())
    global Ipow_1dei,Ipowerr_1dei
    Ipow_1dei = np.zeros(len(energylist))
    Ipowerr_1dei = np.zeros(len(energylist))
    # 条件を満たすインデックスを取得。
    if Qpm==0:
        Pow1D_Q = [np.abs(Q2 - Qc).argmin()]
    else:
        pow1D_Q = list(zip(*np.where((Qc - Qpm <= Q2) & (Q2 <= Qc + Qpm))))
        Pow1D_Q = list(np.ravel(pow1D_Q))
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Pow1D_Q)!=0:
        for ll in range(len(energylist)):
            n_nanind = (list(zip(*np.where(~np.isnan(Ipow[ll,Pow1D_Q])))))
            N_nanind = list(np.ravel(n_nanind)[::1])
            if N_nanind:
                #I_1DU[mm]=np.sum(I_ce[ind_cE1dV,mm][~np.isnan(I_ce[ind_cE1dV,ll])])/(len(I_ce[n_nanind[0]]))
                Ipow_1dei[ll] = (np.nansum(Ipow[ll,Pow1D_Q]))/(len(N_nanind))
                Ipowerr_1dei[ll] = ((np.nansum(np.multiply(Ipow_err[ll,Pow1D_Q],Ipow_err[ll,Pow1D_Q])))**(1/2))/(len(N_nanind))
            else:
                Ipow_1dei[ll] = np.nan
                Ipowerr_1dei[ll] = np.nan
            
        # 例外処理
        if len(list(zip(*np.where(~np.isnan(Ipow_1dei)))))!=0:         
            fig12 = plt.figure(oneDPE)
            ax12 = fig12.gca()
            ax12.errorbar(energylist, Ipow_1dei, yerr=Ipowerr_1dei, capsize=10,label='Q='+str(Qc)+'±'+str(Qpm)+'(Å^-1)')
            at=axistypep.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(Ipow_1dei)-np.nanmax(Ipowerr_1dei)
            global elist,qlist
            elist = energylist
            qlist = [Qc-Qpm,Qc+Qpm]
            ax12.legend()
            #ax12.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            #ax12.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            plt.draw()
            
# powderの1次元カットを追加表示するボタン
button3_pa = ttk.Button(tab_1dp,text="add I vs ℏω",command=btn_click_1DPE,width=12)
button3_pa.grid(row=3, column=0,columnspan=2,sticky="NSEW")

# Q方向の1次元カット
def show_1D_QvsI():
    #既に記入しているUとVの範囲を読み出し。
    Ec=float(txt13_p.get())
    Epm=float(txt14_p.get())
    global Ipow_1dqi,Ipowerr_1dqi
    Ipow_1dqi = np.zeros(len(Q2))
    Ipowerr_1dqi = np.zeros(len(Q2))
    # エネルギーリストをフロートに変換
    hwlist_p2=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist_p2[ne] = float(energylist[ne])
    # 条件を満たすインデックスを取得。
    if Epm==0:
        Pow1D_E = [np.abs(hwlist_p2 - Ec).argmin()]
    else:
        pow1D_E = list(zip(*np.where((Ec - Epm <= hwlist_p2) & (hwlist_p2 <= Ec + Epm))))
        Pow1D_E = list(np.ravel(pow1D_E))
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Pow1D_E)!=0:
        for qq in range(len(Q2)):
            n_nanind = (list(zip(*np.where(~np.isnan(Ipow[Pow1D_E,qq])))))
            N_nanind = list(np.ravel(n_nanind)[::1])
            if N_nanind:
                #I_1DU[mm]=np.sum(I_ce[ind_cE1dV,mm][~np.isnan(I_ce[ind_cE1dV,ll])])/(len(I_ce[n_nanind[0]]))
                Ipow_1dqi[qq] = (np.nansum(Ipow[Pow1D_E,qq]))/(len(N_nanind))
                Ipowerr_1dqi[qq] = ((np.nansum(np.multiply(Ipow_err[Pow1D_E,qq],Ipow_err[Pow1D_E,qq])))**(1/2))/(len(N_nanind))
            else:
                Ipow_1dqi[qq] = np.nan
                Ipowerr_1dqi[qq] = np.nan
            
        # 例外処理
        if len(list(zip(*np.where(~np.isnan(Ipow_1dqi)))))!=0:
            # 軸の設定
            if scale_p_Qmin_txt.get()=="":
                xlim_min=energylist[0]
            else:
                xlim_min=float(scale_p_Qmin_txt.get())
                
            if scale_p_Qmax_txt.get()=="":
                xlim_max=energylist[-1]
            else:
                xlim_max=float(scale_p_Qmax_txt.get())
                
            if scale_p_Imin_txt.get()=="":
                if np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi) >= 0:
                    ylim_min=0
                elif np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi) < 0:
                    ylim_min=round(np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi),1)
            else:
                ylim_min=float(scale_p_Imin_txt.get())
            if scale_p_Imax_txt.get()=="":
                if np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi) >= 0:
                    ylim_max=round(np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi),1)
                elif np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi) < 0:
                    ylim_max=round(np.abs(np.nanmax(Ipow_1dqi)+np.nanmax(Ipowerr_1dqi)),1)
            else:
                ylim_max=float(scale_p_Imax_txt.get())
                
            # エラーバーのグラフを作成
            global oneDPQ
            fig13=plt.figure()
            
            # グラフ内に表示範囲を決定するボックス
            # 最小値と最大値の初期値
            default_xmin = round(xlim_min, 2)
            default_xmax = round(xlim_max, 2)

            default_ymin = round(ylim_min, 2)
            default_ymax = round(ylim_max, 2)

            # テキストボックスを作成して最小値と最大値を設定
            xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
            xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
            ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
            ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
            
            # 最小値と最大値が変更されたときに呼び出される関数
            def update_axis_range(text):
                try:
                    xmin_val = float(xmin_box.text)
                    xmax_val = float(xmax_box.text)
                    ax13.set_xlim(xmin_val, xmax_val)
                    ymin_val = float(ymin_box.text)
                    ymax_val = float(ymax_box.text)
                    ax13.set_ylim(ymin_val, ymax_val)
                    fig13.canvas.draw_idle()
                except ValueError:
                    pass

            xmin_box.on_submit(update_axis_range)
            xmax_box.on_submit(update_axis_range)
            ymin_box.on_submit(update_axis_range)
            ymax_box.on_submit(update_axis_range)
            
            # 現在のFigure番号を取得
            oneDPQ = plt.gcf().number
            fig13.subplots_adjust(left=0.30, bottom=0.2)
            ax13 = fig13.add_subplot(111)
            #plt.text(0.1,1.1,'E = %.3f' %Ec, transform=ax.transAxes)
            #plt.text(0.3,1.1,' ± %.3f r.l.u.' %Epm, transform=ax.transAxes)
            plt.xlabel("Q (Å^-1)")
            plt.ylabel("Intensity (a. u.)")
            ax13.errorbar(Q2, Ipow_1dqi, yerr=Ipowerr_1dqi, capsize=10,label='E='+str(Ec)+'±'+str(Epm)+'meV')
            global elist2,qlist2
            elist2 = [Ec-Epm,Ec+Epm]
            qlist2 = Q2
            at=axistypep.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(Ipow_1dqi)-np.nanmax(Ipowerr_1dqi)
            ax13.legend()
            ax13.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            ax13.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            #plt.tick_params(labelsize=20)
            
            plt.grid()
            plt.show()

    else:
        # 何もしない
        pass
    
button4_p = ttk.Button(tab_1dp,text="I vs Q",command=show_1D_QvsI,width=12)
button4_p.grid(row=2, column=2,columnspan=2,sticky="NSEW")

def btn_click_1DPQ():

    #既に記入しているUとVの範囲を読み出し。
    Ec=float(txt13_p.get())
    Epm=float(txt14_p.get())
    global Ipow_1dqi,Ipowerr_1dqi
    Ipow_1dqi = np.zeros(len(Q2))
    Ipowerr_1dqi = np.zeros(len(Q2))
    # エネルギーリストをフロートに変換
    hwlist_p2=np.zeros(len(energylist))
    for ne in range(len(energylist)):
        hwlist_p2[ne] = float(energylist[ne])
    # 条件を満たすインデックスを取得。
    if Epm==0:
        Pow1D_E = [np.abs(hwlist_p2 - Ec).argmin()]
    else:
        pow1D_E = list(zip(*np.where((Ec - Epm <= hwlist_p2) & (hwlist_p2 <= Ec + Epm))))
        Pow1D_E = list(np.ravel(pow1D_E))
    # ないリストを参照すると、次のグラフ表示の時、空白のグラフができる。これを回避するためにリストが空の時はグラフ表示しない分岐を作成
    if len(Pow1D_E)!=0:
        for qq in range(len(Q2)):
            n_nanind = (list(zip(*np.where(~np.isnan(Ipow[Pow1D_E,qq])))))
            N_nanind = list(np.ravel(n_nanind)[::1])
            if N_nanind:
                #I_1DU[mm]=np.sum(I_ce[ind_cE1dV,mm][~np.isnan(I_ce[ind_cE1dV,ll])])/(len(I_ce[n_nanind[0]]))
                Ipow_1dqi[qq] = (np.nansum(Ipow[Pow1D_E,qq]))/(len(N_nanind))
                Ipowerr_1dqi[qq] = ((np.nansum(np.multiply(Ipow_err[Pow1D_E,qq],Ipow_err[Pow1D_E,qq])))**(1/2))/(len(N_nanind))
            else:
                Ipow_1dqi[qq] = np.nan
                Ipowerr_1dqi[qq] = np.nan
            
        #例外処理
        if len(list(zip(*np.where(~np.isnan(Ipow_1dqi)))))!=0:
            fig13 = plt.figure(oneDPQ)
            ax13 = fig13.gca()
            ax13.errorbar(Q2, Ipow_1dqi, yerr=Ipowerr_1dqi, capsize=10,label='E='+str(Ec)+'±'+str(Epm)+'meV')
            at=axistypep.get()
            if at==1:
                plt.yscale('log')
                if ylim_min==0:
                    ylim_min=np.nanmin(Ipow_1dqi)-np.nanmax(Ipowerr_1dqi)
            global elist2,qlist2
            elist2 = [Ec-Epm,Ec+Epm]
            qlist2 = Q2
            ax13.legend()
            #ax13.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
            #ax13.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
            plt.draw()
            
button4_p2 = ttk.Button(tab_1dp,text="add I vs Q",command=btn_click_1DPQ,width=12)
button4_p2.grid(row=3, column=2,columnspan=2,sticky="NSEW")

###############################################################################
# TAS mode(単結晶と同じ。ただし。コンボボックスの値取得時に挙動がおかしくなるので変数を変えている。)
# TASモードで測定した場合のデータ表示

# 読み込めなかった時はデータ形式がおかしい。(例えば最終の行だけ列数が少ないとか)
# データ表示ボタンが押された時の定義
def xaxis_select():    
    # まずデータを読み込む
    #特定の行を読み込む
    with open(file_paths[0],"r", encoding="utf-8") as f:
        line = f.readlines()
        data = line[31]
        data2 = data.split()
        if "Pt." in data2:
            pass
        else:
            data = line[32]
            data2 = data.split()
    No_Pt=data2.index('Pt.')
    No_c2=data2.index('c2')
    No_a2=data2.index('a2')
    No_timeact=data2.index('time-act')
    #mcuがない場合は読み込まない。
    if data.find('mcu')!=-1:
        No_mcu=data2.index('mcu')
    else :
        pass
    No_e=data2.index('e')
    No_q=data2.index('q')
    No_h=data2.index('h')
    No_k=data2.index('k')
    No_l=data2.index('l')
    No_tsample=data2.index('tsample')
    No_D01=data2.index('D01')
    No_D02=data2.index('D02')
    No_D03=data2.index('D03')
    No_D04=data2.index('D04')
    No_D05=data2.index('D05')
    No_D06=data2.index('D06')
    No_D07=data2.index('D07')
    No_D08=data2.index('D08')
    No_D09=data2.index('D09')
    No_D10=data2.index('D10')
    No_D11=data2.index('D11')
    No_D12=data2.index('D12')
    No_D13=data2.index('D13')
    No_D14=data2.index('D14')
    No_D15=data2.index('D15')
    No_D16=data2.index('D16')
    No_D17=data2.index('D17')
    No_D18=data2.index('D18')
    No_D19=data2.index('D19')
    No_D20=data2.index('D20')
    No_D21=data2.index('D21')
    No_D22=data2.index('D22')
    No_D23=data2.index('D23')
    No_D24=data2.index('D24')
    """
    No_1l=data2.index('1l')
    No_1r=data2.index('1r')
    No_1t=data2.index('1t')
    No_1b=data2.index('1b')
    """

    #ファイルの数値を全て読み込む
    #tt = np.loadtxt(file_paths[0], usecols = 0, delimiter=" ")
    pt = np.loadtxt(file_paths[0], comments='#', usecols = No_Pt-1)
    c2 = np.loadtxt(file_paths[0], comments='#', usecols = No_c2-1)
    a2 = np.loadtxt(file_paths[0], comments='#', usecols = No_a2-1)
    #mcuがない場合は読み込まない。強制的にmcuが0となる。しかし、このモードではカウント値しか読み込まないため問題ない。
    if data.find('mcu')!=-1:
        mcu = np.loadtxt(file_paths[0], comments='#', usecols = No_mcu-1)
    else :
        #mcu = np.zeros((len(c2)))
        pass
    t_a = np.loadtxt(file_paths[0], comments='#', usecols = No_timeact-1)
    e = np.loadtxt(file_paths[0], comments='#', usecols = No_e-1)
    D01 = np.loadtxt(file_paths[0], comments='#', usecols = No_D01-1)
    D02 = np.loadtxt(file_paths[0], comments='#', usecols = No_D02-1)
    D03 = np.loadtxt(file_paths[0], comments='#', usecols = No_D03-1)
    D04 = np.loadtxt(file_paths[0], comments='#', usecols = No_D04-1)
    D05 = np.loadtxt(file_paths[0], comments='#', usecols = No_D05-1)
    D06 = np.loadtxt(file_paths[0], comments='#', usecols = No_D06-1)
    D07 = np.loadtxt(file_paths[0], comments='#', usecols = No_D07-1)
    D08 = np.loadtxt(file_paths[0], comments='#', usecols = No_D08-1)
    D09 = np.loadtxt(file_paths[0], comments='#', usecols = No_D09-1)
    D10 = np.loadtxt(file_paths[0], comments='#', usecols = No_D10-1)
    D11 = np.loadtxt(file_paths[0], comments='#', usecols = No_D11-1)
    D12 = np.loadtxt(file_paths[0], comments='#', usecols = No_D12-1)
    D13 = np.loadtxt(file_paths[0], comments='#', usecols = No_D13-1)
    D14 = np.loadtxt(file_paths[0], comments='#', usecols = No_D14-1)
    D15 = np.loadtxt(file_paths[0], comments='#', usecols = No_D15-1)
    D16 = np.loadtxt(file_paths[0], comments='#', usecols = No_D16-1)
    D17 = np.loadtxt(file_paths[0], comments='#', usecols = No_D17-1)
    D18 = np.loadtxt(file_paths[0], comments='#', usecols = No_D18-1)
    D19 = np.loadtxt(file_paths[0], comments='#', usecols = No_D19-1)
    D20 = np.loadtxt(file_paths[0], comments='#', usecols = No_D20-1)
    D21 = np.loadtxt(file_paths[0], comments='#', usecols = No_D21-1)
    D22 = np.loadtxt(file_paths[0], comments='#', usecols = No_D22-1)
    D23 = np.loadtxt(file_paths[0], comments='#', usecols = No_D23-1)
    D24 = np.loadtxt(file_paths[0], comments='#', usecols = No_D24-1)

    q = np.loadtxt(file_paths[0], comments='#', usecols = No_q-1)
    h = np.loadtxt(file_paths[0], comments='#', usecols = No_h-1)
    k = np.loadtxt(file_paths[0], comments='#', usecols = No_k-1)
    l = np.loadtxt(file_paths[0], comments='#', usecols = No_l-1)
    T = np.loadtxt(file_paths[0], comments='#', usecols = No_tsample-1)
    """
    l1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1l-1)
    r1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1r-1)
    b1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1b-1)
    t1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1t-1)
    """

    # X軸の項目を1つの行列にする。
    xbox=np.vstack([pt,c2,a2,q,h,k,l,e,T])

    # selectされたindexを読み込む
    x_select = cbp.current()
    
    #Y軸の項目を1つの行列にする。
    ybox=np.vstack([D01,D02,D03,D04,D05,D06,D07,D08,D09,D10,D11,D12,D13,D14,D15,D16,D17,D18,D19,D20,D21,D22,D23,D24])
    
    # selectされたindexを読み込む
    y_select = cb_dp.current()
    
    xlim_min=np.nanmin(xbox[x_select,:])
    xlim_max=np.nanmax(xbox[x_select,:])

    ylim_min=0
    ylim_max=np.nanmax(ybox[y_select,:])
    
    # エラーバーのグラフを作成
    fig10=plt.figure()
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(xlim_min, 2)
    default_xmax = round(xlim_max, 2)

    default_ymin = round(ylim_min, 2)
    default_ymax = round(ylim_max, 2)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))
    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax10.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax10.set_ylim(ymin_val, ymax_val)
            fig10.canvas.draw_idle()
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    
    global fig_tas
    # 現在のFigure番号を取得
    fig_tas = plt.gcf().number
    fig10.subplots_adjust(left=0.30,bottom=0.2)
    ax10 = fig10.add_subplot(111)
    xlist =['Pt','c2 (deg)', 'a2 (deg)', 'q (Å^-1)' ,'h (r.l.u.)', 'k (r.l.u.)', 'l (r.l.u.)', 'e (meV)', 'T (K)']
    plt.xlabel(xlist[x_select])
    plt.ylabel("Intensity (count)")
    ax10.errorbar(xbox[x_select,:], ybox[y_select,:], yerr=ybox[y_select,:]**(1/2), capsize=10, label='Detector'+str(y_select+1))
    at=axistypep.get()
    if at==1:
        plt.yscale('log')
        if ylim_min==0:
            ylim_min=np.nanmin(ybox[y_select,:])-np.nanmax(ybox[y_select,:])
    ax10.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
    ax10.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
    #plt.tick_params(labelsize=20)
    ax10.legend()
    plt.grid()
    plt.show()
    
# Xコンボボックスのリスト
xlist =['Pt','c2', 'a2', 'q' ,'h', 'k', 'l', 'e', 'T']

# Yコンボボックスのリスト
ylist =['D01','D02','D03','D04','D05','D06','D07','D08','D09','D10','D11','D12','D13','D14','D15','D16','D17','D18','D19','D20','D21','D22','D23','D24']

# Xコンボボックスのラベル
lbl4_1 = tk.Label(tab_ptas,text='x-axis',width=6)
lbl4_1.grid(row=0, column=0,sticky="NSEW")

# Xコンボボックスを設置
cbp = ttk.Combobox(tab_ptas, values = xlist, width=6)
cbp.grid(row=1, column=0,sticky="NSEW")

#コンボボックスのリストの先頭を表示
cbp.set(xlist[0])

# Yコンボボックスのラベル
lbl4_2 = tk.Label(tab_ptas,text='detector',width=6)
lbl4_2.grid(row=0, column=1,sticky="NSEW")

# Yコンボボックスを設置
cb_dp = ttk.Combobox(tab_ptas, values = ylist, width=6)
cb_dp.grid(row=1, column=1,sticky="NSEW")

#コンボボックスのリストの先頭を表示
cb_dp.set(ylist[11])

#グラフを表示するボタンを設置
v_btn = ttk.Button(tab_ptas, text='view data', command=xaxis_select, width=12)
v_btn.grid(row=1, column=2,sticky="NSEW")

# ダミーのラベル
lbl4_dp1 = tk.Label(tab_ptas,text='',width=6)
lbl4_dp1.grid(row=2, column=0,sticky="NSEW",pady=1)
lbl4_dp2 = tk.Label(tab_ptas,text='',width=6)
lbl4_dp2.grid(row=3, column=0,sticky="NSEW",pady=1)

#追加でグラフを表示するボタンの定義
def add_axis_select(): 
    # データを読み込む
    #特定の行を読み込む
    with open(file_paths[0],"r", encoding="utf-8") as f:
        line = f.readlines()
        data = line[31]
        data2 = data.split()
        if "Pt." in data2:
            pass
        else:
            data = line[32]
            data2 = data.split()
        
    No_Pt=data2.index('Pt.')
    No_c2=data2.index('c2')
    No_a2=data2.index('a2')
    No_timeact=data2.index('time-act')
    #mcuがない場合は読み込まない。
    if data.find('mcu')!=-1:
        No_mcu=data2.index('mcu')
    else :
        pass
    No_e=data2.index('e')
    No_q=data2.index('q')
    No_h=data2.index('h')
    No_k=data2.index('k')
    No_l=data2.index('l')
    No_tsample=data2.index('tsample')
    No_D01=data2.index('D01')
    No_D02=data2.index('D02')
    No_D03=data2.index('D03')
    No_D04=data2.index('D04')
    No_D05=data2.index('D05')
    No_D06=data2.index('D06')
    No_D07=data2.index('D07')
    No_D08=data2.index('D08')
    No_D09=data2.index('D09')
    No_D10=data2.index('D10')
    No_D11=data2.index('D11')
    No_D12=data2.index('D12')
    No_D13=data2.index('D13')
    No_D14=data2.index('D14')
    No_D15=data2.index('D15')
    No_D16=data2.index('D16')
    No_D17=data2.index('D17')
    No_D18=data2.index('D18')
    No_D19=data2.index('D19')
    No_D20=data2.index('D20')
    No_D21=data2.index('D21')
    No_D22=data2.index('D22')
    No_D23=data2.index('D23')
    No_D24=data2.index('D24')
    """
    No_1l=data2.index('1l')
    No_1r=data2.index('1r')
    No_1t=data2.index('1t')
    No_1b=data2.index('1b')
    """

    #ファイルの数値を全て読み込む
    #tt = np.loadtxt(file_paths[0], usecols = 0, delimiter=" ")
    pt = np.loadtxt(file_paths[0], comments='#', usecols = No_Pt-1)
    c2 = np.loadtxt(file_paths[0], comments='#', usecols = No_c2-1)
    a2 = np.loadtxt(file_paths[0], comments='#', usecols = No_a2-1)
    #mcuがない場合は読み込まない。強制的にmcuが0となる。しかし、このモードではカウント値しか読み込まないため問題ない。
    if data.find('mcu')!=-1:
        mcu = np.loadtxt(file_paths[0], comments='#', usecols = No_mcu-1)
    else :
        #mcu = np.zeros((len(c2)))
        pass
    t_a = np.loadtxt(file_paths[0], comments='#', usecols = No_timeact-1)
    e = np.loadtxt(file_paths[0], comments='#', usecols = No_e-1)
    D01 = np.loadtxt(file_paths[0], comments='#', usecols = No_D01-1)
    D02 = np.loadtxt(file_paths[0], comments='#', usecols = No_D02-1)
    D03 = np.loadtxt(file_paths[0], comments='#', usecols = No_D03-1)
    D04 = np.loadtxt(file_paths[0], comments='#', usecols = No_D04-1)
    D05 = np.loadtxt(file_paths[0], comments='#', usecols = No_D05-1)
    D06 = np.loadtxt(file_paths[0], comments='#', usecols = No_D06-1)
    D07 = np.loadtxt(file_paths[0], comments='#', usecols = No_D07-1)
    D08 = np.loadtxt(file_paths[0], comments='#', usecols = No_D08-1)
    D09 = np.loadtxt(file_paths[0], comments='#', usecols = No_D09-1)
    D10 = np.loadtxt(file_paths[0], comments='#', usecols = No_D10-1)
    D11 = np.loadtxt(file_paths[0], comments='#', usecols = No_D11-1)
    D12 = np.loadtxt(file_paths[0], comments='#', usecols = No_D12-1)
    D13 = np.loadtxt(file_paths[0], comments='#', usecols = No_D13-1)
    D14 = np.loadtxt(file_paths[0], comments='#', usecols = No_D14-1)
    D15 = np.loadtxt(file_paths[0], comments='#', usecols = No_D15-1)
    D16 = np.loadtxt(file_paths[0], comments='#', usecols = No_D16-1)
    D17 = np.loadtxt(file_paths[0], comments='#', usecols = No_D17-1)
    D18 = np.loadtxt(file_paths[0], comments='#', usecols = No_D18-1)
    D19 = np.loadtxt(file_paths[0], comments='#', usecols = No_D19-1)
    D20 = np.loadtxt(file_paths[0], comments='#', usecols = No_D20-1)
    D21 = np.loadtxt(file_paths[0], comments='#', usecols = No_D21-1)
    D22 = np.loadtxt(file_paths[0], comments='#', usecols = No_D22-1)
    D23 = np.loadtxt(file_paths[0], comments='#', usecols = No_D23-1)
    D24 = np.loadtxt(file_paths[0], comments='#', usecols = No_D24-1)

    q = np.loadtxt(file_paths[0], comments='#', usecols = No_q-1)
    h = np.loadtxt(file_paths[0], comments='#', usecols = No_h-1)
    k = np.loadtxt(file_paths[0], comments='#', usecols = No_k-1)
    l = np.loadtxt(file_paths[0], comments='#', usecols = No_l-1)
    T = np.loadtxt(file_paths[0], comments='#', usecols = No_tsample-1)
    """
    l1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1l-1)
    r1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1r-1)
    b1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1b-1)
    t1 = np.loadtxt(file_paths[0], comments='#', usecols = No_1t-1)
    """

    # X軸の項目を1つの行列にする。
    xbox=np.vstack([pt,c2,a2,q,h,k,l,e,T])

    # selectされたindexを読み込む
    x_select = cbp.current()
    
    #Y軸の項目を1つの行列にする。
    ybox=np.vstack([D01,D02,D03,D04,D05,D06,D07,D08,D09,D10,D11,D12,D13,D14,D15,D16,D17,D18,D19,D20,D21,D22,D23,D24])
    
    # selectされたindexを読み込む
    y_select = cb_dp.current()
    
    xlim_min=np.nanmin(xbox[x_select,:])
    xlim_max=np.nanmax(xbox[x_select,:])

    ylim_min=0
    ylim_max=np.nanmax(ybox[y_select,:])
    
    # エラーバーのグラフを作成   
    fig10=plt.figure(fig_tas)
    ax10 = fig10.gca()
    ax10.errorbar(xbox[x_select,:], ybox[y_select,:], yerr=ybox[y_select,:]**(1/2), capsize=10, label='Detector'+str(y_select+1))
    at=axistypep.get()
    if at==1:
        plt.yscale('log')
        if ylim_min==0:
            ylim_min=np.nanmin(ybox[y_select,:])-np.nanmax(ybox[y_select,:])
    ax10.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
    ax10.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
    #plt.tick_params(labelsize=20)
    ax10.legend()
    plt.show()

#追加でグラフを表示するボタンを設置
v_btn = ttk.Button(tab_ptas, text='add data', command=add_axis_select,width=12)
v_btn.grid(row=1, column=3,sticky="NSEW")

###############################################################################
# calculation の項目

# データボックスを作成するボタン周りのフレーム作成。
frameS = ttk.Labelframe(tab_03, text= "scan range simulation")
frameS.grid(row=0,column=0,sticky="NSEW")
#frameS.grid_propagate(True)

frameS.columnconfigure(0, weight=1)
frameS.columnconfigure(1, weight=1)
frameS.rowconfigure(0, weight=2)
frameS.rowconfigure(1, weight=1)

# 単結晶用のフレームを作成
frameS_SC = ttk.Labelframe(frameS, text= "single crystal")
frameS_SC.grid(row=0,column=0,rowspan=2,sticky="NSEW")
#frameS_SC.grid_propagate(True)

frameS_SC.columnconfigure(0, weight=1)
frameS_SC.columnconfigure(1, weight=1)
frameS_SC.columnconfigure(2, weight=1)
frameS_SC.rowconfigure(0, weight=1)
frameS_SC.rowconfigure(1, weight=1)
frameS_SC.rowconfigure(2, weight=1)
frameS_SC.rowconfigure(3, weight=1)
frameS_SC.rowconfigure(4, weight=1)
frameS_SC.rowconfigure(5, weight=1)
frameS_SC.rowconfigure(6, weight=1)
frameS_SC.rowconfigure(7, weight=1)
frameS_SC.rowconfigure(8, weight=1)

# a2とc2の範囲を指定
lbl_s1 = tk.Label(frameS_SC,text='a2 min',width=6)
lbl_s1.grid(row=0, column=0)
txt_s1 = ttk.Entry(frameS_SC,width=5)
txt_s1.insert(0,'34')
txt_s1.grid(row=1, column=0,sticky="NSEW")

lbl_s2 = tk.Label(frameS_SC,text='a2 inc',width=6)
lbl_s2.grid(row=0, column=1)
txt_s2 = ttk.Entry(frameS_SC,width=5)
txt_s2.insert(0,'1')
txt_s2.grid(row=1, column=1,sticky="NSEW")

lbl_s3 = tk.Label(frameS_SC,text='a2 max',width=6)
lbl_s3.grid(row=0, column=2)
txt_s3 = ttk.Entry(frameS_SC,width=5)
txt_s3.insert(0,'35')
txt_s3.grid(row=1, column=2,sticky="NSEW")

lbl_s4 = tk.Label(frameS_SC,text='c2 min',width=6)
lbl_s4.grid(row=2, column=0)
txt_s4 = ttk.Entry(frameS_SC,width=5)
txt_s4.insert(0,'0')
txt_s4.grid(row=3, column=0,sticky="NSEW")

lbl_s5 = tk.Label(frameS_SC,text='c2 inc',width=6)
lbl_s5.grid(row=2, column=1)
txt_s5 = ttk.Entry(frameS_SC,width=5)
txt_s5.insert(0,'2')
txt_s5.grid(row=3, column=1,sticky="NSEW")

lbl_s6 = tk.Label(frameS_SC,text='c2 max',width=6)
lbl_s6.grid(row=2, column=2)
txt_s6 = ttk.Entry(frameS_SC,width=5)
txt_s6.insert(0,'90')
txt_s6.grid(row=3, column=2,sticky="NSEW")

lbl_s7 = tk.Label(frameS_SC,text='ℏω min',width=6)
lbl_s7.grid(row=4, column=0)
txt_s7 = ttk.Entry(frameS_SC,width=5)
txt_s7.insert(0,'0')
txt_s7.grid(row=5, column=0,sticky="NSEW")

lbl_s8 = tk.Label(frameS_SC,text='ℏω inc',width=6)
lbl_s8.grid(row=4, column=1)
txt_s8 = ttk.Entry(frameS_SC,width=5)
txt_s8.insert(0,'0.1')
txt_s8.grid(row=5, column=1,sticky="NSEW")

lbl_s9 = tk.Label(frameS_SC,text='ℏω max',width=6)
lbl_s9.grid(row=4, column=2)
txt_s9 = ttk.Entry(frameS_SC,width=5)
txt_s9.insert(0,'3')
txt_s9.grid(row=5, column=2,sticky="NSEW")

lbl_s10 = tk.Label(frameS_SC,text='ℏω',width=6)
lbl_s10.grid(row=6, column=0)
txt_s10 = ttk.Entry(frameS_SC,width=5)
txt_s10.insert(0,'0')
txt_s10.grid(row=7, column=0,sticky="NSEW")

lbl_s11 = tk.Label(frameS_SC,width=6,textvariable=U_lavel)
lbl_s11.grid(row=6, column=1)
txt_s11 = ttk.Entry(frameS_SC,width=5)
txt_s11.insert(0,'0')
txt_s11.grid(row=7, column=1,sticky="NSEW")

lbl_s12 = tk.Label(frameS_SC,width=6,textvariable=V_lavel)
lbl_s12.grid(row=6, column=2)
txt_s12 = ttk.Entry(frameS_SC,width=5)
txt_s12.insert(0,'0')
txt_s12.grid(row=7, column=2,sticky="NSEW")

#constEのボタンを押した時の定義
def simu_sc_cE():
    # グラフ文字の取得
    if float(txt9.get())==0:
        ul1 = 0
    elif float(txt9.get())==1:
        ul1 = str(txt_ul.get())
    elif float(txt9.get())==-1:
        ul1 = str('-')+str(txt_ul.get())
    else:
        try:
            number0 = float(txt9.get())
            if number0.is_integer():#整数である
                ul1 = str(int(float(txt9.get())))+str(txt_ul.get())
            else:#整数でない
                ul1 = str(float(txt9.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
    
    if float(txt10.get())==0:
        ul2 = 0
    elif float(txt10.get())==1:
        ul2 = str(txt_ul.get())
    elif float(txt10.get())==-1:
        ul2 = str('-')+str(txt_ul.get())
    else:
        try:
            number1 = float(txt10.get())
            if number1.is_integer():#整数である
                ul2 = str(int(float(txt10.get())))+str(txt_ul.get())
            else:#整数でない
                ul2 = str(float(txt10.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
            
    if float(txt11.get())==0:
        ul3 = 0
    elif float(txt11.get())==1:
        ul3 = str(txt_ul.get())
    elif float(txt11.get())==-1:
        ul3 = str('-')+str(txt_ul.get())
    else:
        try:
            number2 = float(txt11.get())
            if number2.is_integer():#整数である
                ul3 = str(int(float(txt11.get())))+str(txt_ul.get())
            else:#整数でない
                ul3 = str(float(txt11.get()))+str(txt_ul.get())
        except ValueError:#整数でない
            pass
            
    if float(txt12.get())==0:
        vl1 = 0
    elif float(txt12.get())==1:
        vl1 = str(txt_vl.get())
    elif float(txt12.get())==-1:
        vl1 = str('-')+str(txt_vl.get())
    else:
        try:
            number3 = float(txt12.get())
            if number3.is_integer():#整数である
                vl1 = str(int(float(txt12.get())))+str(txt_vl.get())
            else:#整数でない
                vl1 = str(float(txt12.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
            
    if float(txt13.get())==0:
        vl2 = 0
    elif float(txt13.get())==1:
        vl2 = str(txt_vl.get())
    elif float(txt13.get())==-1:
        vl2 = str('-')+str(txt_vl.get())
    else:
        try:
            number4 = float(txt13.get())
            if number4.is_integer():#整数である
                vl2 = str(int(float(txt13.get())))+str(txt_vl.get())
            else:#整数でない
                vl2 = str(float(txt13.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
            
    if float(txt14.get())==0:
        vl3 = 0
    elif float(txt14.get())==1:
        vl3 = str(txt_vl.get())
    elif float(txt14.get())==-1:
        vl3 = str('-')+str(txt_vl.get())
    else:
        try:
            number5 = float(txt14.get())
            if number5.is_integer():#整数である
                vl3 = str(int(float(txt14.get())))+str(txt_vl.get())
            else:#整数でない
                vl3 = str(float(txt14.get()))+str(txt_vl.get())
        except ValueError:#整数でない
            pass
        
    #global Ulabel,Vlabel
    Ulabel = (f"({ul1},{ul2},{ul3})")
    Vlabel = (f"({vl1},{vl2},{vl3})")
            
    a2_min = float(txt_s1.get())
    a2_inc = float(txt_s2.get())
    a2_max = float(txt_s3.get())
    c2_min = float(txt_s4.get())
    c2_inc = float(txt_s5.get())
    c2_max = float(txt_s6.get())
    hw_min = float(txt_s7.get())
    hw_inc = float(txt_s8.get())
    hw_max = float(txt_s9.get())
    E_simu = float(txt_s10.get())
    #U_simu = float(txt_s11.get())
    #V_simu = float(txt_s12.get())

    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    c2_off=float(txt7.get())
    Vt=float(txt8.get())
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())

    #散乱面のベクトルを指定
    global u,v
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    vt = [v1*Vt,v2*Vt,v3*Vt]

    # ベクトルu,v,wを定義し、rluを自動で計算する
    U = [la*math.cos(math.radians(0)), 0, 0]
    V = [lb*math.cos(math.radians(lga)), lb*math.sin(math.radians(lga)), 0]
    W = [lc*math.cos(math.radians(lbe)), lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)), math.sqrt(lc**2-(lc*math.cos(math.radians(lbe)))**2-(lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)))**2)]
    astar = 2*3.141592*np.cross(V,W)/np.dot(U,np.cross(V,W))
    bstar = 2*3.141592*np.cross(W,U)/np.dot(V,np.cross(W,U))
    cstar = 2*3.141592*np.cross(U,V)/np.dot(W,np.cross(U,V))

    U1=u[0]*astar+u[1]*bstar+u[2]*cstar
    V1=v[0]*astar+v[1]*bstar+v[2]*cstar
    Vt1=vt[0]*astar+vt[1]*bstar+vt[2]*cstar

    #計算されたrlu
    global NU1,NV1
    NU1=np.linalg.norm(U1)
    NV1=np.linalg.norm(V1)
    NVt1=np.linalg.norm(Vt1)

    dhkl=2*math.pi/NVt1

    hacho=9.044/((3.635)**(1/2))
    tta=math.degrees(math.asin(hacho/(2*dhkl)))

    #入力した値から色々計算
    w_off = c2_off - tta
    
    # incの指定を0にしたら1つだけ計算するようにする
    if a2_inc == 0 and c2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_c2 = 1
        c2 = np.array([c2_min])
    
    elif a2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_c2=round((c2_max-c2_min)/c2_inc+1)
        c2=np.zeros((n_c2))
        for i in range(n_c2):
            c2[i] = c2_min + c2_inc * i
        
    elif c2_inc == 0:
        n_c2 = 1
        c2 = np.array([c2_min])
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        a2=np.zeros((n_a2))
        for j in range(n_a2):
            a2[j] = a2_min + a2_inc * j
        
    elif a2_inc != 0 and c2_inc != 0:
        # a2とc2のsimulationする数
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        n_c2=round((c2_max-c2_min)/c2_inc+1)
        a2=np.zeros((n_a2))
        c2=np.zeros((n_c2))
        for j in range(n_a2):
            a2[j] = a2_min + a2_inc * j
        for i in range(n_c2):
            c2[i] = c2_min + c2_inc * i
            
    if hw_inc == 0:
        n_hw = 1
        hw = np.array([hw_min])
    else:
        n_hw = round((hw_max-hw_min)/hw_inc+1)
        hw=np.zeros((n_hw))
        for k in range(n_hw):
            hw[k] = hw_min + hw_inc * k
    
    #検出器の角度
    d_angle=np.linspace(0, 46, 24)
    phi=-22;# offset angle of No.1
    #C2のオフセット
    C2=c2-w_off
    Qsimu_x = None
    Qsimu_y = None
    Qsimu_x=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu_y=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu_d12_x=np.zeros((n_hw,n_a2*n_c2*1))
    Qsimu_d12_y=np.zeros((n_hw,n_a2*n_c2*1))
    for k in range(n_hw):
        for n in range(n_c2):
            for m in range(n_a2):
                for l in range(24):
                    #A2の絶対値変換
                    A2=d_angle+phi+a2[m];# cover range
                    Qsimu_x[k,l+24*m+24*n_a2*n] =(math.sqrt((3.635+hw[k])/2.072)*math.cos(math.radians(-C2[n]))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[l]-C2[n])))/NU1
                    Qsimu_y[k,l+24*m+24*n_a2*n] =(-math.sqrt((3.635+hw[k])/2.072)*math.sin(math.radians(-C2[n]))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[l]-C2[n])))/NV1
                    # D12は再計算
                    Qsimu_d12_x[k,n+n_c2*m] =(math.sqrt((3.635+hw[k])/2.072)*math.cos(math.radians(-C2[n]))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[11]-C2[n])))/NU1
                    Qsimu_d12_y[k,n+n_c2*m] =(-math.sqrt((3.635+hw[k])/2.072)*math.sin(math.radians(-C2[n]))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[11]-C2[n])))/NV1
    
    # 一番近いhwの値を取り出す。浮動小数点数の精度の問題をクリア。
    ind_E = np.abs(hw - E_simu).argmin()
    
    # グラフスケールの定義
    xlim_min=np.nanmin(Qsimu_x)
    xlim_max=np.nanmax(Qsimu_x)

    ylim_min=np.nanmin(Qsimu_y)
    ylim_max=np.nanmax(Qsimu_y)
    
    # グラフを作成
    fig0,ax=plt.subplots()
    plt.subplots_adjust(bottom=0.25)
    # アスペクト比を変更
    ax.set_aspect(NV1/NU1)
    sa1=ind_E#初期値をセット
    if n_a2!=1:
        ax.text(0.0,1.1,'a2 = %.3f ~ %.3f deg (step %.3f deg)' % (a2_min,a2_max,a2_inc), transform=ax.transAxes)
    else:
        ax.text(0.0,1.1,'a2 = %.3f' %a2_min, transform=ax.transAxes)
    
    if n_c2!=1:
        ax.text(0.0,1.05,'c2 = %.3f ~ %.3f deg (step %.3f deg)' % (c2_min,c2_max,c2_inc), transform=ax.transAxes)
    else:
        ax.text(0.0,1.05,'c2 = %.3f' %c2_min, transform=ax.transAxes)
    ax.text(0.0,1.00,'ℏω = %.3f meV' %hw[ind_E], transform=ax.transAxes)
    ax.set_xlabel(str(Ulabel))
    ax.set_ylabel(str(Vlabel))
    ax.scatter(Qsimu_x[ind_E,:], Qsimu_y[ind_E,:],s=10, color = "blue", label="Other detectors")
    ax.scatter(Qsimu_d12_x[ind_E,:], Qsimu_d12_y[ind_E,:],s=10, color = "red", label="D12")
    ax.legend()
    ax.grid()
    ax.set_xlim(xlim_min,xlim_max) #x軸の範囲を指定
    ax.set_ylim(ylim_min,ylim_max) #y軸の範囲を指定
    plt.subplots_adjust(left=0.30, right=0.75, bottom=0.25)  # マージンを調整してグラフを中央に配置
    #plt.tick_params(labelsize=20)
    #横スライドでエネルギートランスファーを変更、縦スライドで強度の最大値を変更
    ax_a = plt.axes([0.3, 0.02, 0.45, 0.04]) #plt.axes([x, y, width, height] ) 
    sli_a1 = wg.Slider(ax_a, 'ℏω', 0, len(hw)-1, valinit=sa1,valstep=1, orientation='horizontal')
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(xlim_min, 2)
    default_xmax = round(xlim_max, 2)

    default_ymin = round(ylim_min, 2)
    default_ymax = round(ylim_max, 2)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.10, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.65, 0.10, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            fig0.canvas.draw_idle()
            return xmin_val,xmax_val,ymin_val,ymax_val
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)  
    
    def update1(val):
        ax.clear()
        
        xmin_val = float(xmin_box.text)
        xmax_val = float(xmax_box.text)
        ymin_val = float(ymin_box.text)
        ymax_val = float(ymax_box.text)
        
        # アスペクト比を変更
        ax.set_aspect(NV1/NU1)
        if n_a2!=1:
            ax.text(0.0,1.1,'a2 = %.3f ~ %.3f deg (step %.3f deg)' % (a2_min,a2_max,a2_inc), transform=ax.transAxes)
        else:
            ax.text(0.0,1.1,'a2 = %.3f' %a2_min, transform=ax.transAxes)
        
        if n_c2!=1:
            ax.text(0.0,1.05,'c2 = %.3f ~ %.3f deg (step %.3f deg)' % (c2_min,c2_max,c2_inc), transform=ax.transAxes)
        else:
            ax.text(0.0,1.05,'c2 = %.3f' %c2_min, transform=ax.transAxes)
        sa1 = sli_a1.val
        ax.text(0.0,1.00,'ℏω = %.3f meV' %hw[sa1], transform=ax.transAxes)
        ax.set_xlabel(str(Ulabel))
        ax.set_ylabel(str(Vlabel))
        ax.scatter(Qsimu_x[sa1,:], Qsimu_y[sa1,:],s=10, color = "blue", label="Other detectors")
        ax.scatter(Qsimu_d12_x[sa1,:], Qsimu_d12_y[sa1,:],s=10, color = "red", label="D12")
        ax.legend()
        ax.grid()
        ax.set_xlim(xmin_val,xmax_val) #x軸の範囲を指定
        ax.set_ylim(ymin_val,ymax_val) #y軸の範囲を指定
        plt.draw()
    # 矢印キーにスライダを対応。上限を超えて表示しないように設定。
    def on_key(event):
        if event.key == 'right':
            new_val_a = min(sli_a1.val + 1, sli_a1.valmax)
            sli_a1.set_val(new_val_a)
        elif event.key == 'left':
            new_val_a = max(sli_a1.val - 1, sli_a1.valmin)
            sli_a1.set_val(new_val_a)
    fig0.canvas.mpl_connect('key_press_event', on_key)
    
    sli_a1.on_changed(update1)
    plt.show()
    
#constVのボタンを押した時の定義
def simu_sc_cV():        
    # グラフ文字の取得    
    a2_min = float(txt_s1.get())
    a2_inc = float(txt_s2.get())
    a2_max = float(txt_s3.get())
    c2_min = float(txt_s4.get())
    c2_inc = float(txt_s5.get())
    c2_max = float(txt_s6.get())
    hw_min = float(txt_s7.get())
    hw_inc = float(txt_s8.get())
    hw_max = float(txt_s9.get())
    #E_simu = float(txt_s10.get())
    #U_simu = float(txt_s11.get())
    V_simu = float(txt_s12.get())
    
    # グラフラベルを作成
    if float(txt9.get())==0:
        if float(txt12.get())==0:
            ul1 = str('0')
        else:
            ul1 = str(float(txt12.get())*V_simu)
    elif float(txt9.get())==1:
        if float(txt12.get())==0:
            ul1 = str(txt_ul.get())
        else:
            ul1 = str(float(txt12.get())*V_simu) + str('+') + str(txt_ul.get())
    elif float(txt9.get())==-1:
        if float(txt12.get())==0:
            ul1 = str('-')+str(txt_ul.get())
        else:
            ul1 = str(float(txt12.get())*V_simu) + str('-') + str(txt_ul.get())
    else:
        try:
            number0 = float(txt9.get())
            if number0.is_integer():#整数である
                if number0 > 0:
                    ul1 = str(float(txt12.get())*V_simu) + str('+') + str(int(float(txt9.get()))) + str(txt_ul.get())
                elif number0 < 0:
                    ul1 = str(float(txt12.get())*V_simu) + str('-') + str(int(np.abs(float(txt9.get())))) + str(txt_ul.get())
            else:#整数でない
                if number0 > 0:
                    ul1 = str(float(txt12.get())*V_simu) + str('+') + str(float(txt9.get())) + str(txt_ul.get())
                elif number0 < 0:
                    ul1 = str(float(txt12.get())*V_simu) + str('-') + str(np.abs(float(txt9.get()))) + str(txt_ul.get())
        except ValueError:#整数でない
            pass
    
    if float(txt10.get())==0:
        if float(txt13.get())==0:
            ul2 = str('0')
        else:
            ul2 = str(float(txt13.get())*V_simu)
    elif float(txt10.get())==1:
        if float(txt13.get())==0:
            ul2 = str(txt_ul.get())
        else:
            ul2 = str(float(txt13.get())*V_simu) + str('+') + str(txt_ul.get())
    elif float(txt10.get())==-1:
        if float(txt13.get())==0:
            ul2 = str('-')+str(txt_ul.get())
        else:
            ul2 = str(float(txt13.get())*V_simu) + str('-') + str(txt_ul.get())
    else:
        try:
            number1 = float(txt10.get())
            if number1.is_integer():#整数である
                if number1 > 0:
                    ul2 = str(float(txt13.get())*V_simu) + str('+') + str(int(float(txt10.get()))) + str(txt_ul.get())
                elif number1 < 0:
                    ul2 = str(float(txt13.get())*V_simu) + str('-') + str(int(np.abs(float(txt10.get())))) + str(txt_ul.get())
            else:#整数でない
                if number1 > 0:
                    ul2 = str(float(txt13.get())*V_simu) + str('+') + str(float(txt10.get())) + str(txt_ul.get())
                elif number1 < 0:
                    ul2 = str(float(txt13.get())*V_simu) + str('-') + str(np.abs(float(txt10.get()))) + str(txt_ul.get())
        except ValueError:#整数でない
            pass
        
    if float(txt11.get())==0:
        if float(txt14.get())==0:
            ul3 = str('0')
        else:
            ul3 = str(float(txt14.get())*V_simu)
    elif float(txt11.get())==1:
        if float(txt14.get())==0:
            ul3 = str(txt_ul.get())
        else:
            ul3 = str(float(txt14.get())*V_simu) + str('+') + str(txt_ul.get())
    elif float(txt11.get())==-1:
        if float(txt14.get())==0:
            ul3 = str('-')+str(txt_ul.get())
        else:
            ul3 = str(float(txt14.get())*V_simu) + str('-') + str(txt_ul.get())
    else:
        try:
            number2 = float(txt11.get())
            if number2.is_integer():#整数である
                if number2 > 0:
                    ul3 = str(float(txt14.get())*V_simu) + str('+') + str(int(float(txt11.get()))) + str(txt_ul.get())
                elif number2 < 0:
                    ul3 = str(float(txt14.get())*V_simu) + str('-') + str(int(np.abs(float(txt11.get())))) + str(txt_ul.get())
            else:#整数でない
                if number2 > 0:
                    ul3 = str(float(txt14.get())*V_simu) + str('+') + str(float(txt11.get())) + str(txt_ul.get())
                elif number2 < 0:
                    ul3 = str(float(txt14.get())*V_simu) + str('-') + str(np.abs(float(txt11.get()))) + str(txt_ul.get())
        except ValueError:#整数でない
            pass
        
    Ulabel = (f"({ul1},{ul2},{ul3})")

    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    c2_off=float(txt7.get())
    Vt=float(txt8.get())
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())

    #散乱面のベクトルを指定
    global u,v
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    vt = [v1*Vt,v2*Vt,v3*Vt]

    # ベクトルu,v,wを定義し、rluを自動で計算する
    U = [la*math.cos(math.radians(0)), 0, 0]
    V = [lb*math.cos(math.radians(lga)), lb*math.sin(math.radians(lga)), 0]
    W = [lc*math.cos(math.radians(lbe)), lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)), math.sqrt(lc**2-(lc*math.cos(math.radians(lbe)))**2-(lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)))**2)]
    astar = 2*3.141592*np.cross(V,W)/np.dot(U,np.cross(V,W))
    bstar = 2*3.141592*np.cross(W,U)/np.dot(V,np.cross(W,U))
    cstar = 2*3.141592*np.cross(U,V)/np.dot(W,np.cross(U,V))

    U1=u[0]*astar+u[1]*bstar+u[2]*cstar
    V1=v[0]*astar+v[1]*bstar+v[2]*cstar
    Vt1=vt[0]*astar+vt[1]*bstar+vt[2]*cstar

    #計算されたrlu
    global NU1,NV1
    NU1=np.linalg.norm(U1)
    NV1=np.linalg.norm(V1)
    NVt1=np.linalg.norm(Vt1)

    dhkl=2*math.pi/NVt1

    hacho=9.044/((3.635)**(1/2))
    tta=math.degrees(math.asin(hacho/(2*dhkl)))

    #入力した値から色々計算
    w_off = c2_off - tta
    
    # incの指定を0にしたら1つだけ計算するようにする
    if a2_inc == 0 and c2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_c2 = 1
        c2 = np.array([c2_min])
    
    elif a2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_c2=round((c2_max-c2_min)/c2_inc+1)
        c2=np.zeros((n_c2))
        for i in range(n_c2):
            c2[i] = c2_min + c2_inc * i
        
    elif c2_inc == 0:
        n_c2 = 1
        c2 = np.array([c2_min])
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        a2=np.zeros((n_a2))
        for j in range(n_a2):
            a2[j] = a2_min + a2_inc * j
        
    elif a2_inc != 0 and c2_inc != 0:
        # a2とc2のsimulationする数
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        n_c2=round((c2_max-c2_min)/c2_inc+1)
        a2=np.zeros((n_a2))
        c2=np.zeros((n_c2))
        for j in range(n_a2):
            a2[j] = a2_min + a2_inc * j
        for i in range(n_c2):
            c2[i] = c2_min + c2_inc * i
            
    if hw_inc == 0:
        n_hw = 1
        hw = np.array([hw_min])
    else:
        n_hw = round((hw_max-hw_min)/hw_inc+1)
        hw=np.zeros((n_hw))
        for k in range(n_hw):
            hw[k] = hw_min + hw_inc * k

    #検出器の角度
    d_angle=np.linspace(0, 46, 24)
    phi=-22;# offset angle of No.1
    #C2のオフセット
    C2=c2-w_off
    Qsimu_x = None
    Qsimu_y = None
    Qsimu_x=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu_y=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu_d12_x=np.zeros((n_hw,n_a2*n_c2*1))
    Qsimu_d12_y=np.zeros((n_hw,n_a2*n_c2*1))
    for k in range(n_hw):
        for n in range(n_c2):
            for m in range(n_a2):
                for l in range(24):
                    #A2の絶対値変換
                    A2=d_angle+phi+a2[m];# cover range
                    Qsimu_x[k,l+24*m+24*n_a2*n] =(math.sqrt((3.635+hw[k])/2.072)*math.cos(math.radians(-C2[n]))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[l]-C2[n])))/NU1
                    Qsimu_y[k,l+24*m+24*n_a2*n] =(-math.sqrt((3.635+hw[k])/2.072)*math.sin(math.radians(-C2[n]))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[l]-C2[n])))/NV1
                    Qsimu[k,l+24*m+24*n_a2*n]=((NU1*Qsimu_x[k,l+24*m+24*n_a2*n])**2+(NV1*Qsimu_y[k,l+24*m+24*n_a2*n])**2)**(1/2)
                    # D12は再計算
                    Qsimu_d12_x[k,n+n_c2*m] =(math.sqrt((3.635+hw[k])/2.072)*math.cos(math.radians(-C2[n]))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[11]-C2[n])))/NU1
                    Qsimu_d12_y[k,n+n_c2*m] =(-math.sqrt((3.635+hw[k])/2.072)*math.sin(math.radians(-C2[n]))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[11]-C2[n])))/NV1
    
    #Vの指定範囲内にある点を探す。
    pmV_simu = (np.max(Qsimu)-np.min(Qsimu))/(24*n_a2)/NV1
    for k in range(n_hw):
        ind_V = np.where((V_simu-pmV_simu <= Qsimu_y[k,:]) & (Qsimu_y[k,:] <= V_simu+pmV_simu))
        ind_V12 = np.where((V_simu-pmV_simu <= Qsimu_d12_y[k,:]) & (Qsimu_d12_y[k,:] <= V_simu+pmV_simu))
        qsimu_x_cv = Qsimu_x[k,:][ind_V]
        qsimu_x_cv12 = Qsimu_d12_x[k,:][ind_V12]
        if k==0:
            ConstV = np.vstack((qsimu_x_cv, hw[k]*np.ones((1,len(qsimu_x_cv)))))
            ConstV12 = np.vstack((qsimu_x_cv12, hw[k]*np.ones((1,len(qsimu_x_cv12)))))
        else:
            ConstV = np.concatenate((ConstV, np.vstack((qsimu_x_cv, hw[k]*np.ones((1,len(qsimu_x_cv)))))), axis=1)
            ConstV12 = np.concatenate((ConstV12, np.vstack((qsimu_x_cv12, hw[k]*np.ones((1,len(qsimu_x_cv12)))))), axis=1)
    
    # エラー回避
    if len(ConstV[0]) > 0:
            
        # グラフスケールの定義
        xlim_min=np.nanmin(ConstV[0,:])
        xlim_max=np.nanmax(ConstV[0,:])
    
        ylim_min=np.nanmin(hw)
        ylim_max=np.nanmax(hw)
        
        # グラフを作成
        fig=plt.figure()
        fig.subplots_adjust(left=0.30, bottom=0.2)
        ax = fig.add_subplot(111)
        if n_a2!=1:
            plt.text(0.1,1.1,'a2 = %.3f ~ %.3f deg (step %.3f deg)' % (a2_min,a2_max,a2_inc), transform=ax.transAxes)
        else:
            plt.text(0.1,1.1,'a2 = %.3f' %a2_min, transform=ax.transAxes)
        
        if n_c2!=1:
            plt.text(0.1,1.05,'c2 = %.3f ~ %.3f deg (step %.3f deg)' % (c2_min,c2_max,c2_inc), transform=ax.transAxes)
        else:
            plt.text(0.1,1.05,'c2 = %.3f' %c2_min, transform=ax.transAxes)
        plt.text(0.1,1.00,f'{txt_vl.get()} = %.3f ± %.3f (r.l.u.)' % (V_simu,pmV_simu), transform=ax.transAxes)
        plt.xlabel(str(Ulabel))
        plt.ylabel("ℏω (meV)")
        plt.scatter(ConstV[0,:],ConstV[1,:],s=10, color = "blue", label="Other detectors")
        plt.scatter(ConstV12[0,:],ConstV12[1,:],s=10, color = "red", label="D12")
        plt.legend()
        plt.xlim(xlim_min,xlim_max) #x軸の範囲を指定
        plt.ylim(ylim_min,ylim_max) #y軸の範囲を指定
        #plt.tick_params(labelsize=20)
        plt.grid()
        
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_xmin = round(xlim_min, 2)
        default_xmax = round(xlim_max, 2)

        default_ymin = round(ylim_min, 2)
        default_ymax = round(ylim_max, 2)

        # テキストボックスを作成して最小値と最大値を設定
        xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
        xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                xmin_val = float(xmin_box.text)
                xmax_val = float(xmax_box.text)
                ax.set_xlim(xmin_val, xmax_val)
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax.set_ylim(ymin_val, ymax_val)
                fig.canvas.draw_idle()
            except ValueError:
                pass

        xmin_box.on_submit(update_axis_range)
        xmax_box.on_submit(update_axis_range)
        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        
        plt.show()
    else:
        pass
    
#constUのボタンを押した時の定義
def simu_sc_cU():        
    a2_min = float(txt_s1.get())
    a2_inc = float(txt_s2.get())
    a2_max = float(txt_s3.get())
    c2_min = float(txt_s4.get())
    c2_inc = float(txt_s5.get())
    c2_max = float(txt_s6.get())
    hw_min = float(txt_s7.get())
    hw_inc = float(txt_s8.get())
    hw_max = float(txt_s9.get())
    #E_simu = float(txt_s10.get())
    U_simu = float(txt_s11.get())
    #V_simu = float(txt_s12.get())
    
    if float(txt12.get())==0:
        if float(txt9.get())==0:
            vl1 = str('0')
        else:
            vl1 = str(float(txt9.get())*U_simu)
    elif float(txt12.get())==1:
        if float(txt9.get())==0:
            vl1 = str(txt_vl.get())
        else:
            vl1 = str(float(txt9.get())*U_simu) + str('+') + str(txt_vl.get())
    elif float(txt12.get())==-1:
        if float(txt9.get())==0:
            vl1 = str('-')+str(txt_vl.get())
        else:
            vl1 = str(float(txt9.get())*U_simu) + str('-') + str(txt_vl.get())
    else:
        try:
            number0 = float(txt12.get())
            if number0.is_integer():#整数である
                if number0 > 0:
                    vl1 = str(float(txt9.get())*U_simu) + str('+') + str(int(float(txt12.get()))) + str(txt_vl.get())
                elif number0 < 0:
                    vl1 = str(float(txt9.get())*U_simu) + str('-') + str(int(np.abs(float(txt12.get())))) + str(txt_vl.get())
            else:#整数でない
                if number0 > 0:
                    vl1 = str(float(txt9.get())*U_simu) + str('+') + str(float(txt12.get())) + str(txt_vl.get())
                elif number0 < 0:
                    vl1 = str(float(txt9.get())*U_simu) + str('-') + str(float(np.abs(txt12.get()))) + str(txt_vl.get())
        except ValueError:#数値でない
            pass
    
    if float(txt13.get())==0:
        if float(txt10.get())==0:
            vl2 = str('0')
        else:
            vl2 = str(float(txt10.get())*U_simu)
    elif float(txt13.get())==1:
        if float(txt10.get())==0:
            vl2 = str(txt_vl.get())
        else:
            vl2 = str(float(txt10.get())*U_simu) + str('+') + str(txt_vl.get())
    elif float(txt13.get())==-1:
        if float(txt10.get())==0:
            vl2 = str('-')+str(txt_vl.get())
        else:
            vl2 = str(float(txt10.get())*U_simu) + str('-') + str(txt_vl.get())
    else:
        try:
            number1 = float(txt13.get())
            if number1.is_integer():#整数である
                if number1 > 0:
                    vl2 = str(float(txt10.get())*U_simu) + str('+') + str(int(float(txt13.get()))) + str(txt_vl.get())
                elif number1 < 0:
                    vl2 = str(float(txt10.get())*U_simu) + str('-') + str(int(np.abs(float(txt13.get())))) + str(txt_vl.get())
            else:#整数でない
                if number1 > 0:
                    vl2 = str(float(txt10.get())*U_simu) + str('+') + str(float(txt13.get())) + str(txt_vl.get())
                elif number1 < 0:
                    vl2 = str(float(txt10.get())*U_simu) + str('-') + str(np.abs(float(txt13.get()))) + str(txt_vl.get())
        except ValueError:#数値でない
            pass
        
    if float(txt14.get())==0:
        if float(txt11.get())==0:
            vl3 = str('0')
        else:
            vl3 = str(float(txt11.get())*U_simu)
    elif float(txt14.get())==1:
        if float(txt11.get())==0:
            vl3 = str(txt_vl.get())
        else:
            vl3 = str(float(txt11.get())*U_simu) + str('+') + str(txt_vl.get())
    elif float(txt14.get())==-1:
        if float(txt11.get())==0:
            vl3 = str('-')+str(txt_vl.get())
        else:
            vl3 = str(float(txt11.get())*U_simu) + str('-') + str(txt_vl.get())
    else:
        try:
            number2 = float(txt14.get())
            if number2.is_integer():#整数である
                if number2 > 0:
                    vl3 = str(float(txt11.get())*U_simu) + str('+') + str(int(float(txt14.get()))) + str(txt_vl.get())
                elif number2 < 0:
                    vl3 = str(float(txt11.get())*U_simu) + str('-') + str(int(np.abs(float(txt14.get())))) + str(txt_vl.get())
            else:#整数でない
                if number2 > 0:
                    vl3 = str(float(txt11.get())*U_simu) + str('+') + str(float(txt14.get())) + str(txt_vl.get())
                elif number2 < 0:
                    vl3 = str(float(txt11.get())*U_simu) + str('-') + str(np.abs(float(txt14.get()))) + str(txt_vl.get())
        except ValueError:#整数でない
            pass
        
    Vlabel = (f"({vl1},{vl2},{vl3})")

    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    c2_off=float(txt7.get())
    Vt=float(txt8.get())
    u1=float(txt9.get())
    u2=float(txt10.get())
    u3=float(txt11.get())
    v1=float(txt12.get())
    v2=float(txt13.get())
    v3=float(txt14.get())

    #散乱面のベクトルを指定
    global u,v
    u = [u1,u2,u3]
    v = [v1,v2,v3]
    vt = [v1*Vt,v2*Vt,v3*Vt]

    # ベクトルu,v,wを定義し、rluを自動で計算する
    U = [la*math.cos(math.radians(0)), 0, 0]
    V = [lb*math.cos(math.radians(lga)), lb*math.sin(math.radians(lga)), 0]
    W = [lc*math.cos(math.radians(lbe)), lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)), math.sqrt(lc**2-(lc*math.cos(math.radians(lbe)))**2-(lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)))**2)]
    astar = 2*3.141592*np.cross(V,W)/np.dot(U,np.cross(V,W))
    bstar = 2*3.141592*np.cross(W,U)/np.dot(V,np.cross(W,U))
    cstar = 2*3.141592*np.cross(U,V)/np.dot(W,np.cross(U,V))

    U1=u[0]*astar+u[1]*bstar+u[2]*cstar
    V1=v[0]*astar+v[1]*bstar+v[2]*cstar
    Vt1=vt[0]*astar+vt[1]*bstar+vt[2]*cstar

    #計算されたrlu
    global NU1,NV1
    NU1=np.linalg.norm(U1)
    NV1=np.linalg.norm(V1)
    NVt1=np.linalg.norm(Vt1)

    dhkl=2*math.pi/NVt1

    hacho=9.044/((3.635)**(1/2))
    tta=math.degrees(math.asin(hacho/(2*dhkl)))

    #入力した値から色々計算
    w_off = c2_off - tta
    
    # incの指定を0にしたら1つだけ計算するようにする
    if a2_inc == 0 and c2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_c2 = 1
        c2 = np.array([c2_min])
    
    elif a2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_c2=round((c2_max-c2_min)/c2_inc+1)
        c2=np.zeros((n_c2))
        for i in range(n_c2):
            c2[i] = c2_min + c2_inc * i
        
    elif c2_inc == 0:
        n_c2 = 1
        c2 = np.array([c2_min])
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        a2=np.zeros((n_a2))
        for j in range(n_a2):
            a2[j] = a2_min + a2_inc * j
        
    elif a2_inc != 0 and c2_inc != 0:
        # a2とc2のsimulationする数
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        n_c2=round((c2_max-c2_min)/c2_inc+1)
        a2=np.zeros((n_a2))
        c2=np.zeros((n_c2))
        for j in range(n_a2):
            a2[j] = a2_min + a2_inc * j
        for i in range(n_c2):
            c2[i] = c2_min + c2_inc * i
            
    if hw_inc == 0:
        n_hw = 1
        hw = np.array([hw_min])
    else:
        n_hw = round((hw_max-hw_min)/hw_inc+1)
        hw=np.zeros((n_hw))
        for k in range(n_hw):
            hw[k] = hw_min + hw_inc * k
    
    #検出器の角度
    d_angle=np.linspace(0, 46, 24)
    phi=-22;# offset angle of No.1
    #C2のオフセット
    C2=c2-w_off
    Qsimu_x = None
    Qsimu_y = None
    Qsimu_x=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu_y=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu=np.zeros((n_hw,n_a2*n_c2*24))
    Qsimu_d12_x=np.zeros((n_hw,n_a2*n_c2*1))
    Qsimu_d12_y=np.zeros((n_hw,n_a2*n_c2*1))
    for k in range(n_hw):
        for n in range(n_c2):
            for m in range(n_a2):
                for l in range(24):
                    #A2の絶対値変換
                    A2=d_angle+phi+a2[m];# cover range
                    Qsimu_x[k,l+24*m+24*n_a2*n] =(math.sqrt((3.635+hw[k])/2.072)*math.cos(math.radians(-C2[n]))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[l]-C2[n])))/NU1
                    Qsimu_y[k,l+24*m+24*n_a2*n] =(-math.sqrt((3.635+hw[k])/2.072)*math.sin(math.radians(-C2[n]))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[l]-C2[n])))/NV1
                    Qsimu[k,l+24*m+24*n_a2*n]=((NU1*Qsimu_x[k,l+24*m+24*n_a2*n])**2+(NV1*Qsimu_y[k,l+24*m+24*n_a2*n])**2)**(1/2)
                    # D12は再計算
                    Qsimu_d12_x[k,n+n_c2*m] =(math.sqrt((3.635+hw[k])/2.072)*math.cos(math.radians(-C2[n]))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[11]-C2[n])))/NU1
                    Qsimu_d12_y[k,n+n_c2*m] =(-math.sqrt((3.635+hw[k])/2.072)*math.sin(math.radians(-C2[n]))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[11]-C2[n])))/NV1
    
    #Vの指定範囲内にある点を探す。
    pmU_simu = (np.max(Qsimu)-np.min(Qsimu))/(24*n_a2)/NU1
    for k in range(n_hw):
        ind_U = np.where((U_simu-pmU_simu <= Qsimu_x[k,:]) & (Qsimu_x[k,:] <= U_simu+pmU_simu))
        ind_U12 = np.where((U_simu-pmU_simu <= Qsimu_d12_x[k,:]) & (Qsimu_d12_x[k,:] <= U_simu+pmU_simu))
        qsimu_y_cv = Qsimu_y[k,:][ind_U]
        qsimu_y_cv12 = Qsimu_d12_y[k,:][ind_U12]
        if k==0:
            ConstU = np.vstack((qsimu_y_cv, hw[k]*np.ones((1,len(qsimu_y_cv)))))
            ConstU12 = np.vstack((qsimu_y_cv12, hw[k]*np.ones((1,len(qsimu_y_cv12)))))
        else:
            ConstU = np.concatenate((ConstU, np.vstack((qsimu_y_cv, hw[k]*np.ones((1,len(qsimu_y_cv)))))), axis=1)
            ConstU12 = np.concatenate((ConstU12, np.vstack((qsimu_y_cv12, hw[k]*np.ones((1,len(qsimu_y_cv12)))))), axis=1)
    
    # エラー回避
    if len(ConstU[0]) > 0:
                    
        # グラフスケールの定義
        xlim_min=np.nanmin(ConstU[0,:])
        xlim_max=np.nanmax(ConstU[0,:])
    
        ylim_min=np.nanmin(hw)
        ylim_max=np.nanmax(hw)
        
        # グラフを作成
        fig=plt.figure()
        fig.subplots_adjust(left=0.30, bottom=0.2)
        ax = fig.add_subplot(111)
        if n_a2!=1:
            plt.text(0.1,1.1,'a2 = %.3f ~ %.3f deg (step %.3f deg)' % (a2_min,a2_max,a2_inc), transform=ax.transAxes)
        else:
            plt.text(0.1,1.1,'a2 = %.3f' %a2_min, transform=ax.transAxes)
        
        if n_c2!=1:
            plt.text(0.1,1.05,'c2 = %.3f ~ %.3f deg (step %.3f deg)' % (c2_min,c2_max,c2_inc), transform=ax.transAxes)
        else:
            plt.text(0.1,1.05,'c2 = %.3f' %c2_min, transform=ax.transAxes)
        plt.text(0.1,1.00,f'{txt_ul.get()} = %.3f ± %.3f (r.l.u.)' % (U_simu,pmU_simu), transform=ax.transAxes)
        plt.xlabel(str(Vlabel))
        plt.ylabel("ℏω (meV)")
        plt.scatter(ConstU[0,:],ConstU[1,:],s=10, color = "blue", label="Other detectors")
        plt.scatter(ConstU12[0,:],ConstU12[1,:],s=10, color = "red", label="D12")
        plt.legend()
        plt.xlim(xlim_min,xlim_max) #x軸の範囲を指定
        plt.ylim(ylim_min,ylim_max) #y軸の範囲を指定
        plt.grid()
        #plt.tick_params(labelsize=20)
        
        # グラフ内に表示範囲を決定するボックス
        # 最小値と最大値の初期値
        default_xmin = round(xlim_min, 2)
        default_xmax = round(xlim_max, 2)

        default_ymin = round(ylim_min, 2)
        default_ymax = round(ylim_max, 2)

        # テキストボックスを作成して最小値と最大値を設定
        xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
        xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

        ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
        ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
        
        # 最小値と最大値が変更されたときに呼び出される関数
        def update_axis_range(text):
            try:
                xmin_val = float(xmin_box.text)
                xmax_val = float(xmax_box.text)
                ax.set_xlim(xmin_val, xmax_val)
                ymin_val = float(ymin_box.text)
                ymax_val = float(ymax_box.text)
                ax.set_ylim(ymin_val, ymax_val)
                fig.canvas.draw_idle()
            except ValueError:
                pass

        xmin_box.on_submit(update_axis_range)
        xmax_box.on_submit(update_axis_range)
        ymin_box.on_submit(update_axis_range)
        ymax_box.on_submit(update_axis_range)
        
        plt.show()
    else:
        pass

button_s1 = ttk.Button(frameS_SC, text="const E", width=7, command=simu_sc_cE)
button_s1.grid(row=8, column=0,sticky="NSEW")

button_s2 = ttk.Button(frameS_SC, width=7, command=simu_sc_cU,textvariable=calc_constU_buttom)
button_s2.grid(row=8, column=1,sticky="NSEW")

button_s3 = ttk.Button(frameS_SC, width=7, command=simu_sc_cV,textvariable=calc_constV_buttom)
button_s3.grid(row=8, column=2,sticky="NSEW")

# 粉末用のフレームを作成
frameS_pow = ttk.Labelframe(frameS, text= "powder")
frameS_pow.grid(row=0,column=1,sticky="NSEW")
#frameS_pow.grid_propagate(True)

frameS_pow.columnconfigure(0, weight=1)
frameS_pow.columnconfigure(1, weight=1)
frameS_pow.columnconfigure(2, weight=1)
frameS_pow.rowconfigure(0, weight=1)
frameS_pow.rowconfigure(1, weight=1)
frameS_pow.rowconfigure(2, weight=1)
frameS_pow.rowconfigure(3, weight=1)
frameS_pow.rowconfigure(4, weight=1)

# a2とhwの範囲を指定
lbl_s1_1 = tk.Label(frameS_pow,text='a2 min',width=6)
lbl_s1_1.grid(row=0, column=0)
txt_s1_1 = ttk.Entry(frameS_pow,width=5)
txt_s1_1.insert(0,'34')
txt_s1_1.grid(row=1, column=0,sticky="NSEW")

lbl_s2_1 = tk.Label(frameS_pow,text='a2 inc',width=6)
lbl_s2_1.grid(row=0, column=1)
txt_s2_1 = ttk.Entry(frameS_pow,width=5)
txt_s2_1.insert(0,'1')
txt_s2_1.grid(row=1, column=1,sticky="NSEW")

lbl_s3_1 = tk.Label(frameS_pow,text='a2 max',width=6)
lbl_s3_1.grid(row=0, column=2)
txt_s3_1 = ttk.Entry(frameS_pow,width=5)
txt_s3_1.insert(0,'35')
txt_s3_1.grid(row=1, column=2,sticky="NSEW")

lbl_s4_1 = tk.Label(frameS_pow,text='ℏω min',width=6)
lbl_s4_1.grid(row=2, column=0)
txt_s4_1 = ttk.Entry(frameS_pow,width=5)
txt_s4_1.insert(0,'0')
txt_s4_1.grid(row=3, column=0,sticky="NSEW")

lbl_s5_1 = tk.Label(frameS_pow,text='ℏω inc',width=6)
lbl_s5_1.grid(row=2, column=1)
txt_s5_1 = ttk.Entry(frameS_pow,width=5)
txt_s5_1.insert(0,'0.1')
txt_s5_1.grid(row=3, column=1,sticky="NSEW")

lbl_s6_1 = tk.Label(frameS_pow,text='ℏω max',width=6)
lbl_s6_1.grid(row=2, column=2)
txt_s6_1 = ttk.Entry(frameS_pow,width=5)
txt_s6_1.insert(0,'7')
txt_s6_1.grid(row=3, column=2,sticky="NSEW")

def simu_pow():
    a2_min = float(txt_s1_1.get())
    a2_inc = float(txt_s2_1.get())
    a2_max = float(txt_s3_1.get())
    hw_min = float(txt_s4_1.get())
    hw_inc = float(txt_s5_1.get())
    hw_max = float(txt_s6_1.get())
    if a2_inc == 0 and hw_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_hw = 1
        hw = np.array([hw_min])
    elif a2_inc == 0:
        n_a2 = 1
        a2 = np.array([a2_min])
        n_hw = round((hw_max-hw_min)/hw_inc+1)
        hw=np.zeros((n_hw))
        for j in range(n_hw):
            hw[j] = hw_min + hw_inc * j
    elif hw_inc == 0:
        n_a2 = round((a2_max-a2_min)/a2_inc+1)
        a2=np.zeros((n_a2))
        for i in range(n_a2):
            a2[i] = a2_min + a2_inc * i
        n_hw = 1
        hw = np.array([hw_min])
    elif a2_inc != 0 and hw_inc != 0:
        # a2とhwのsimulationする数
        n_a2=round((a2_max-a2_min)/a2_inc+1)
        n_hw=round((hw_max-hw_min)/hw_inc+1)
        a2=np.zeros((n_a2))
        hw=np.zeros((n_hw))
        for i in range(n_a2):
            a2[i] = a2_min + a2_inc * i
        for j in range(n_hw):
            hw[j] = hw_min + hw_inc * j

    #検出器の角度
    d_angle=np.linspace(0, 46, 24)
    phi=-22;# offset angle of No.1
    
    Qsimu=np.zeros((n_hw*n_a2*24))
    hw_list=np.zeros((n_hw*n_a2*24))
    for n in range(n_hw):
        for m in range(n_a2):
            for l in range(24):
                #A2の絶対値変換
                A2=d_angle+phi+a2[m];# cover range
                # 粉末だからc2は関係ない
                hw_list[l+24*m+24*n_a2*n] = hw[n]
                Qsimu[l+24*m+24*n_a2*n] = math.sqrt((math.sqrt((3.635+hw[n])/2.072)*math.cos(math.radians(0))-math.sqrt(3.635/2.072)*math.cos(math.radians(A2[l])))**2 + (-math.sqrt((3.635+hw[n])/2.072)*math.sin(math.radians(0))+math.sqrt(3.635/2.072)*math.sin(math.radians(A2[l])))**2 )
    
    # グラフスケールの定義
    xlim_min=np.nanmin(Qsimu)
    xlim_max=np.nanmax(Qsimu)

    ylim_min=np.nanmin(hw_list)
    ylim_max=np.nanmax(hw_list)
        
    # グラフを作成
    fig=plt.figure()
    fig.subplots_adjust(left=0.30, bottom=0.2)
    ax = fig.add_subplot(111)
    if n_a2!=1:
        plt.text(0.1,1.1,'a2 = %.3f ~ %.3f deg (step %.3f deg)' %(a2_min,a2_max,a2_inc), transform=ax.transAxes)
    else:
        plt.text(0.1,1.1,'a2 = %.3f' %a2_min, transform=ax.transAxes)
    
    if n_hw!=1:
        plt.text(0.1,1.05,'ℏω = %.3f ~ %.3f meV (step %.3f meV)' %(hw_min,hw_max,hw_inc), transform=ax.transAxes)
    else:
        plt.text(0.1,1.05,'ℏω = %.3f' %hw_min, transform=ax.transAxes)
    plt.xlabel("Q (Å^-1)")
    plt.ylabel("ℏω (meV)")
    plt.scatter(Qsimu,hw_list, s=10)
    #plt.tick_params(labelsize=20)
    plt.xlim(xlim_min,xlim_max) #x軸の範囲を指定
    plt.ylim(ylim_min,ylim_max) #y軸の範囲を指定
    plt.grid()
    
    # グラフ内に表示範囲を決定するボックス
    # 最小値と最大値の初期値
    default_xmin = round(xlim_min, 2)
    default_xmax = round(xlim_max, 2)

    default_ymin = round(ylim_min, 2)
    default_ymax = round(ylim_max, 2)

    # テキストボックスを作成して最小値と最大値を設定
    xmin_box = TextBox(plt.axes([0.3, 0.02, 0.08, 0.05]), 'xMin:', initial=str(default_xmin))
    xmax_box = TextBox(plt.axes([0.82, 0.02, 0.08, 0.05]), 'xMax:', initial=str(default_xmax))

    ymin_box = TextBox(plt.axes([0.1, 0.2, 0.08, 0.05]), 'yMin:', initial=str(default_ymin))
    ymax_box = TextBox(plt.axes([0.1, 0.83, 0.08, 0.05]), 'yMax:', initial=str(default_ymax))
    
    # 最小値と最大値が変更されたときに呼び出される関数
    def update_axis_range(text):
        try:
            xmin_val = float(xmin_box.text)
            xmax_val = float(xmax_box.text)
            ax.set_xlim(xmin_val, xmax_val)
            ymin_val = float(ymin_box.text)
            ymax_val = float(ymax_box.text)
            ax.set_ylim(ymin_val, ymax_val)
            fig.canvas.draw_idle()
        except ValueError:
            pass

    xmin_box.on_submit(update_axis_range)
    xmax_box.on_submit(update_axis_range)
    ymin_box.on_submit(update_axis_range)
    ymax_box.on_submit(update_axis_range)
    
    plt.show()

button_s2 = ttk.Button(frameS_pow, text="simulation", width=15, command=simu_pow)
button_s2.grid(row=4, column=0,columnspan=3,sticky="NSEW")

# 時間計算用
frameS_T = ttk.Labelframe(frameS, text= "time estimate")
frameS_T.grid(row=1,column=1,sticky="NSEW")
#frameS_T.grid_propagate(True)

frameS_T.columnconfigure(0, weight=1)
frameS_T.columnconfigure(1, weight=1)
frameS_T.columnconfigure(2, weight=1)
frameS_T.columnconfigure(3, weight=1)
frameS_T.columnconfigure(4, weight=1)
frameS_T.rowconfigure(0, weight=1)
frameS_T.rowconfigure(1, weight=1)

# fluxのEi依存性
# hw
FE_x=[-0.485, -0.435, -0.384, -0.334, -0.285, -0.235, -0.185, -0.134, -0.085, -0.035, 0.016, 0.066, 0.115, 0.165, 0.214, 0.265, 0.315, 0.365, 0.415, 0.466, 0.5, 0.515, 0.565, 0.6, 0.7, 0.802, 0.901, 0.999, 1.101, 1.2, 1.301, 1.765, 2.165, 2.565, 2.965, 3.365, 3.765, 4.165, 4.565, 4.965, 5.365, 5.765, 6.165, 6.565, 6.965, 7.365]
# CPS
FE_y=[2561.31011, 2594.64212, 2633.54555, 2647.72387, 2682.38289, 2709.97367, 2741.19031, 2757.06989, 2777.31066, 2762.74889, 2497.15092, 2140.32882, 2171.19592, 2340.66631, 2409.86552, 2435.72529, 2436.12747, 2443.79417, 2434.92133, 2426.5117, 2393.83451, 2407.89903, 2368.85202, 2326.27319, 2273.22685, 2251.71695, 2239.75306, 2227.57927, 2193.46846, 2051.0658, 1846.2501, 1714.28571, 1714.28571, 1578.94737, 1518.98734, 1463.41463, 1276.59574, 1237.1134, 1165.04854, 1165.04854, 991.73554, 882.35294, 863.30935, 827.58621, 779.22078, 722.89157]

# チェック有無変数
CSPT = tk.IntVar()
# value=0のラジオボタンにチェックを入れる
CSPT.set(0)

# ラジオボタン作成
rdo_te1 = tk.Radiobutton(frameS_T, value=0, variable=CSPT, text='single')
rdo_te1.grid(row=0,column=0, columnspan=2,sticky="NSEW")

rdo_te2 = tk.Radiobutton(frameS_T, value=1, variable=CSPT, text='powder')
rdo_te2.grid(row=0,column=2, columnspan=3,sticky="NSEW")

# 時間見積もりの定義
def time_estimate():
    #単結晶の場合
    if CSPT.get()==0:
        a2_min = float(txt_s1.get())
        a2_inc = float(txt_s2.get())
        a2_max = float(txt_s3.get())
        c2_min = float(txt_s4.get())
        c2_inc = float(txt_s5.get())
        c2_max = float(txt_s6.get())
        hw_min = float(txt_s7.get())
        hw_inc = float(txt_s8.get())
        hw_max = float(txt_s9.get())
        
        # incの指定を0にしたら1つだけ計算するようにする
        if a2_inc == 0 and c2_inc == 0:
            n_a2 = 1
            a2 = np.array([a2_min])
            n_c2 = 1
            c2 = np.array([c2_min])
        
        elif a2_inc == 0:
            n_a2 = 1
            a2 = np.array([a2_min])
            n_c2=round((c2_max-c2_min)/c2_inc+1)
            c2=np.zeros((n_c2))
            for i in range(n_c2):
                c2[i] = c2_min + c2_inc * i
            
        elif c2_inc == 0:
            n_c2 = 1
            c2 = np.array([c2_min])
            n_a2=round((a2_max-a2_min)/a2_inc+1)
            a2=np.zeros((n_a2))
            for j in range(n_a2):
                a2[j] = a2_min + a2_inc * j
            
        elif a2_inc != 0 and c2_inc != 0:
            # a2とc2のsimulationする数
            n_a2=round((a2_max-a2_min)/a2_inc+1)
            n_c2=round((c2_max-c2_min)/c2_inc+1)
            a2=np.zeros((n_a2))
            c2=np.zeros((n_c2))
            for j in range(n_a2):
                a2[j] = a2_min + a2_inc * j
            for i in range(n_c2):
                c2[i] = c2_min + c2_inc * i
                
        if hw_inc == 0:
            n_hw = 1
            hw = np.array([hw_min])
            # 線形補間関数を作成
            interp_func = interp1d(FE_x, FE_y, kind='linear', fill_value='extrapolate')
            # ターゲットXに対する補間値を計算
            cps = interp_func(hw)
            
            mcu = float(txt15.get())
            # elatic positionでのcps=2580.47577333
            TE = mcu * 2580.47577333 / cps * n_a2 * n_c2
            
            sum_TE=np.sum(TE)
            
            # 60で割った商と余りを計算
            hour, min = divmod(sum_TE, 60)
            
            # ボックスに出力
            txt_teh.delete(0,tk.END)
            txt_teh.insert(0,int(hour))
            
            # ボックスに出力
            txt_tem.delete(0,tk.END)
            txt_tem.insert(0,int(min))
            
        else:
            n_hw = round((hw_max-hw_min)/hw_inc+1)
            hw=np.zeros((n_hw))
            cps=np.zeros((n_hw))
            TE=np.zeros((n_hw))
            for k in range(n_hw):
                hw[k] = hw_min + hw_inc * k
                # 線形補間関数を作成
                interp_func = interp1d(FE_x, FE_y, kind='linear', fill_value='extrapolate')
                # ターゲットXに対する補間値を計算
                cps[k] = interp_func(hw[k])
                
                mcu = float(txt15.get())
                # elatic positionでのcps=2580.47577333
                TE[k] = mcu * 2580.47577333 / cps[k] * n_a2 * n_c2
                
            sum_TE=np.sum(TE)
            
            # 60で割った商と余りを計算
            hour, min = divmod(sum_TE, 60)
            
            # ボックスに出力
            txt_teh.delete(0,tk.END)
            txt_teh.insert(0,int(hour))
            
            # ボックスに出力
            txt_tem.delete(0,tk.END)
            txt_tem.insert(0,int(min))
        
    #粉末の場合
    if CSPT.get()==1:
        a2_min = float(txt_s1_1.get())
        a2_inc = float(txt_s2_1.get())
        a2_max = float(txt_s3_1.get())
        hw_min = float(txt_s4_1.get())
        hw_inc = float(txt_s5_1.get())
        hw_max = float(txt_s6_1.get())
        if a2_inc == 0 and hw_inc == 0:
            n_a2 = 1
            a2 = np.array([a2_min])
            n_hw = 1
            hw = np.array([hw_min])
        elif a2_inc == 0:
            n_a2 = 1
            a2 = np.array([a2_min])
            n_hw = round((hw_max-hw_min)/hw_inc+1)
            hw=np.zeros((n_hw))
            for j in range(n_hw):
                hw[j] = hw_min + hw_inc * j
        elif hw_inc == 0:
            n_a2 = round((a2_max-a2_min)/a2_inc+1)
            a2=np.zeros((n_a2))
            for i in range(n_a2):
                a2[i] = a2_min + a2_inc * i
            n_hw = 1
            hw = np.array([hw_min])
            
            # 線形補間関数を作成
            interp_func = interp1d(FE_x, FE_y, kind='linear', fill_value='extrapolate')
            # ターゲットXに対する補間値を計算
            cps = interp_func(hw)
            
            mcu = float(txt15.get())
            # elatic positionでのcps=2580.47577333
            TE = mcu * 2580.47577333 / cps * n_a2
            
            sum_TE=np.sum(TE)
            
            # 60で割った商と余りを計算
            hour, min = divmod(sum_TE, 60)
            
            # ボックスに出力
            txt_teh.delete(0,tk.END)
            txt_teh.insert(0,int(hour))
            
            # ボックスに出力
            txt_tem.delete(0,tk.END)
            txt_tem.insert(0,int(min))
            
        elif a2_inc != 0 and hw_inc != 0:
            # a2とhwのsimulationする数
            n_a2=round((a2_max-a2_min)/a2_inc+1)
            n_hw=round((hw_max-hw_min)/hw_inc+1)
            a2=np.zeros((n_a2))
            hw=np.zeros((n_hw))
            cps=np.zeros((n_hw))
            TE=np.zeros((n_hw))
            for i in range(n_a2):
                a2[i] = a2_min + a2_inc * i
            for j in range(n_hw):
                hw[j] = hw_min + hw_inc * j
                # 線形補間関数を作成
                interp_func = interp1d(FE_x, FE_y, kind='linear', fill_value='extrapolate')
                # ターゲットXに対する補間値を計算
                cps[j] = interp_func(hw[j])
                
                mcu = float(txt15.get())
                # elatic positionでのcps=2580.47577333
                TE[j] = mcu * 2580.47577333 / cps[j] * n_a2
                
            sum_TE=np.sum(TE)
            
            # 60で割った商と余りを計算
            hour, min = divmod(sum_TE, 60)
            
            # ボックスに出力
            txt_teh.delete(0,tk.END)
            txt_teh.insert(0,int(hour))
            
            # ボックスに出力
            txt_tem.delete(0,tk.END)
            txt_tem.insert(0,int(min))

# 時間を計算するボタン
button_te = ttk.Button(frameS_T, text="calc", command=time_estimate, width=6)
button_te.grid(row=1, column=0,sticky="NSEW")

# 時間を計算するボックス
txt_teh = ttk.Entry(frameS_T,width=4)
txt_teh.grid(row=1, column=1,sticky="NSEW")
# 単位のラベル
lbl_te = tk.Label(frameS_T,text='h')
lbl_te.grid(row=1, column=2,sticky="NSEW")
lbl_te = tk.Label(frameS_T,text='m')
lbl_te.grid(row=1, column=4,sticky="NSEW")
# 時間を計算するボックス
txt_tem = ttk.Entry(frameS_T,width=4)
txt_tem.grid(row=1, column=3,sticky="NSEW")

# なんか色々計算できる便利なやーつ
# 便利なやーつののフレームを作成
frameS_cal = ttk.Labelframe(tab_03, text= "calculation")
frameS_cal.grid(row=0,column=1,sticky="NSEW")
#frameS_cal.grid_propagate(True)

frameS_cal.columnconfigure(0, weight=1)
frameS_cal.columnconfigure(1, weight=1)
frameS_cal.columnconfigure(2, weight=1)
frameS_cal.columnconfigure(3, weight=1)
frameS_cal.rowconfigure(0, weight=1)
frameS_cal.rowconfigure(1, weight=1)
frameS_cal.rowconfigure(2, weight=1)
frameS_cal.rowconfigure(3, weight=1)
frameS_cal.rowconfigure(4, weight=1)
frameS_cal.rowconfigure(5, weight=1)
frameS_cal.rowconfigure(6, weight=1)
frameS_cal.rowconfigure(7, weight=1)
frameS_cal.rowconfigure(8, weight=1)
frameS_cal.rowconfigure(9, weight=1)

# 指数を指定
lbl_s1_2 = tk.Label(frameS_cal,text='h',width=6)
lbl_s1_2.grid(row=0, column=0)
txt_s1_2 = ttk.Entry(frameS_cal,width=5)
txt_s1_2.insert(0,'0')
txt_s1_2.grid(row=1, column=0,sticky="NSEW")

lbl_s2_2 = tk.Label(frameS_cal,text='k',width=6)
lbl_s2_2.grid(row=0, column=1)
txt_s2_2 = ttk.Entry(frameS_cal,width=5)
txt_s2_2.insert(0,'0')
txt_s2_2.grid(row=1, column=1,sticky="NSEW")

lbl_s3_2 = tk.Label(frameS_cal,text='l',width=6)
lbl_s3_2.grid(row=0, column=2)
txt_s3_2 = ttk.Entry(frameS_cal,width=5)
txt_s3_2.insert(0,'0')
txt_s3_2.grid(row=1, column=2,sticky="NSEW")

lbl_s4_2f = tk.Label(frameS_cal,text='Ef (meV)',width=6)
lbl_s4_2f.grid(row=2, column=1)
txt_s4_2f = ttk.Entry(frameS_cal,width=6)
txt_s4_2f.insert(0,'3.635')
txt_s4_2f.grid(row=3, column=1,sticky="NSEW")

lbl_s4_2hw = tk.Label(frameS_cal,text='ℏω (meV)',width=8)
lbl_s4_2hw.grid(row=2, column=2,columnspan=2)
txt_s4_2hw = ttk.Entry(frameS_cal,width=6)
txt_s4_2hw.insert(0,'0')
txt_s4_2hw.grid(row=3, column=2,columnspan=2,sticky="NSEW")

lbl_s4_3 = tk.Label(frameS_cal,text='λ (Å)',width=6)
lbl_s4_3.grid(row=6, column=1,pady=1)
txt_s4_3 = ttk.Entry(frameS_cal,width=6)
txt_s4_3.insert(0,'4.744')
txt_s4_3.grid(row=7, column=1,sticky="NSEW")

lbl_s4_4 = tk.Label(frameS_cal,text='k (Å^-1)',width=6)
lbl_s4_4.grid(row=8, column=1)
txt_s4_4 = ttk.Entry(frameS_cal,width=6)
txt_s4_4.insert(0,'1.324')
txt_s4_4.grid(row=9, column=1,sticky="NSEW")

lbl_s5_2 = tk.Label(frameS_cal,text='2θ (deg)',width=8)
lbl_s5_2.grid(row=4, column=2,columnspan=2)
txt_s5_2 = ttk.Entry(frameS_cal,width=10)
txt_s5_2.grid(row=5, column=2,columnspan=2,sticky="NSEW")


lbl_s7_2 = tk.Label(frameS_cal,text='d (Å)',width=8)
lbl_s7_2.grid(row=6, column=2,columnspan=2)
txt_s7_2 = ttk.Entry(frameS_cal,width=10)
txt_s7_2.grid(row=7, column=2,columnspan=2,sticky="NSEW")

lbl_s6_2 = tk.Label(frameS_cal,text='Q (Å^-1)',width=8)
lbl_s6_2.grid(row=8, column=2,columnspan=2)
txt_s6_2 = ttk.Entry(frameS_cal,width=10)
txt_s6_2.grid(row=9, column=2,columnspan=2,sticky="NSEW")

def tta_calc():
    #エラーが起きた時にわかりやすいように最初に2thetaの欄をデリートする
    txt_s5_2.delete(0,tk.END)
    txt_s6_2.delete(0,tk.END)
    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    cal_h=float(txt_s1_2.get())
    cal_k=float(txt_s2_2.get())
    cal_l=float(txt_s3_2.get())
    ef=float(txt_s4_2f.get())
    hw=float(txt_s4_2hw.get())
    ei=hw+ef

    # ベクトルu,v,wを定義し、rluを自動で計算する
    U = [la*math.cos(math.radians(0)), 0, 0]
    V = [lb*math.cos(math.radians(lga)), lb*math.sin(math.radians(lga)), 0]
    W = [lc*math.cos(math.radians(lbe)), lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)), math.sqrt(lc**2-(lc*math.cos(math.radians(lbe)))**2-(lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)))**2)]
    astar = 2*3.141592*np.cross(V,W)/np.dot(U,np.cross(V,W))
    bstar = 2*3.141592*np.cross(W,U)/np.dot(V,np.cross(W,U))
    cstar = 2*3.141592*np.cross(U,V)/np.dot(W,np.cross(U,V))

    hkl=cal_h*astar+cal_k*bstar+cal_l*cstar

    #計算されたrlu
    global Nhkl,dhkl #NhklがQ、dhklがdに対応
    Nhkl=np.linalg.norm(hkl)
    dhkl=2*math.pi/Nhkl

    #lamdaとkを計算
    Li=9.045/(ei**(1/2))
    Ki=2*3.1415926535/Li
    Lf=9.045/(ef**(1/2))
    Kf=2*3.1415926535/Lf
    
    tta=math.degrees(math.acos((Ki**2+Kf**2-Nhkl**2)/(2*Ki*Kf)))
    #2theta欄に入力
    txt_s5_2.insert(0,tta)
    #Q欄に入力
    txt_s6_2.insert(0,Nhkl)
    #d欄に入力
    txt_s7_2.insert(0,dhkl)

button_s3 = ttk.Button(frameS_cal, text="calc", width=6, command=tta_calc)
button_s3.grid(row=1, column=3,sticky="NSEW")

# λ/2のエネルギーで計算したい場合
def high_harmo():
    E0f=float(txt_s4_2f.get())
    txt_s4_2f.delete(0,tk.END)
    E1f=E0f*4
    txt_s4_2f.insert(0,E1f)

lbl_s6_2 = tk.Label(frameS_cal,text='harmonics',width=10)
lbl_s6_2.grid(row=4, column=0,columnspan=2)
button_s4 = ttk.Button(frameS_cal, text="2k", width=3, command=high_harmo)
button_s4.grid(row=5, column=0,sticky="NSEW")

# 2*λのエネルギーで計算したい場合
def low_harmo():
    E0f=float(txt_s4_2f.get())
    txt_s4_2f.delete(0,tk.END)
    E1f=E0f/4
    txt_s4_2f.insert(0,E1f)

button_s5 = ttk.Button(frameS_cal, text="k/2", width=3, command=low_harmo)
button_s5.grid(row=5, column=1,sticky="NSEW")

# Eから換算したいとき
def trans_E_to_LK():
    E=float(txt_s4_2f.get())
    L=9.045/(E**(1/2))
    K=2*3.1415926535/L
    txt_s4_3.delete(0,tk.END)
    txt_s4_4.delete(0,tk.END)
    txt_s4_3.insert(0,round(L,3))
    txt_s4_4.insert(0,round(K,3))
    
# Lから換算したいとき
def trans_L_to_EK():
    L=float(txt_s4_3.get())
    K=2*3.1415926535/L
    E=81.81/(L**(2))
    txt_s4_4.delete(0,tk.END)
    txt_s4_2f.delete(0,tk.END)
    txt_s4_4.insert(0,round(K,3))
    txt_s4_2f.insert(0,round(E,3))
    
# Kから換算したいとき
def trans_K_to_LE():
    K=float(txt_s4_4.get())
    L=2*3.1415926535/K
    E=81.81/(L**(2))
    txt_s4_3.delete(0,tk.END)
    txt_s4_2f.delete(0,tk.END)
    txt_s4_3.insert(0,round(L,3))
    txt_s4_2f.insert(0,round(E,3))
    
button_s6 = ttk.Button(frameS_cal, text="calc E", width=6, command=trans_E_to_LK)
button_s6.grid(row=3, column=0,sticky="NSEW")
    
button_s7 = ttk.Button(frameS_cal, text="calc λ", width=6, command=trans_L_to_EK)
button_s7.grid(row=7, column=0,pady=1,sticky="NSEW")

button_s7 = ttk.Button(frameS_cal, text="calc k", width=6, command=trans_K_to_LE)
button_s7.grid(row=9, column=0,pady=1,sticky="NSEW")

###############################################################################
# UB calculationからsample omegaを計算する
# データボックスを作成するボタン周りのフレーム作成。
frame_ub1 = ttk.Labelframe(tab_04, text= "Bragg peak position")
frame_ub1.grid(row = 0, column = 0,sticky="NSEW")
#frame4.grid_propagate(True)

frame_ub1.columnconfigure(0, weight=1)
frame_ub1.columnconfigure(1, weight=1)
frame_ub1.columnconfigure(2, weight=1)
frame_ub1.columnconfigure(3, weight=1)
frame_ub1.rowconfigure(0, weight=1)
frame_ub1.rowconfigure(1, weight=1)

# データボックスを作成するボタン周りのフレーム作成。
frame_ub2 = ttk.Labelframe(tab_04, text= "calculated Q position")
frame_ub2.grid(row = 0, column = 1,sticky="NSEW")

frame_ub2.columnconfigure(0, weight=1)
frame_ub2.columnconfigure(1, weight=1)
frame_ub2.columnconfigure(2, weight=1)
frame_ub2.columnconfigure(3, weight=1)
frame_ub2.rowconfigure(0, weight=1)
frame_ub2.rowconfigure(1, weight=1)

# UB matrixを表示するフレーム作成。
frame_ub4 = ttk.Labelframe(tab_04, text= "UB matrix")
frame_ub4.grid(row = 1, column = 0,sticky="NSEW")

frame_ub4.columnconfigure(0, weight=1)
frame_ub4.columnconfigure(1, weight=1)
frame_ub4.columnconfigure(2, weight=1)
frame_ub4.rowconfigure(0, weight=1)
frame_ub4.rowconfigure(1, weight=1)
frame_ub4.rowconfigure(2, weight=1)

# データボックスを作成するボタン周りのフレーム作成。
frame_ub3 = ttk.Labelframe(tab_04, text= "angle calculation")
frame_ub3.grid(row = 2, column = 0,columnspan=2, sticky="NSEW")

frame_ub3.columnconfigure(0, weight=1)
frame_ub3.columnconfigure(1, weight=1)
frame_ub3.columnconfigure(2, weight=1)
frame_ub3.columnconfigure(3, weight=1)
frame_ub3.columnconfigure(4, weight=1)
frame_ub3.columnconfigure(5, weight=1)
frame_ub3.rowconfigure(0, weight=1)
frame_ub3.rowconfigure(1, weight=1)
frame_ub3.rowconfigure(2, weight=2)

# hardware limitを表示するフレーム作成。
frame_ub5 = ttk.Labelframe(tab_04, text= "hardware limit")
frame_ub5.grid(row = 1, column = 1,sticky="NSEW")

frame_ub5.columnconfigure(0, weight=1)
frame_ub5.columnconfigure(1, weight=1)
frame_ub5.columnconfigure(2, weight=1)
frame_ub5.columnconfigure(3, weight=1)
frame_ub5.rowconfigure(0, weight=1)
frame_ub5.rowconfigure(1, weight=1)
frame_ub5.rowconfigure(2, weight=1)

# 初期値を指定
lbl_ubcb_0 = tk.Label(frame_ub1,text='C2',width=6)
lbl_ubcb_0.grid(row=0, column=0)
txt_ubcb_0 = ttk.Entry(frame_ub1,width=5)
txt_ubcb_0.insert(0,'0')
txt_ubcb_0.grid(row=1, column=0,sticky="NSEW")

lbl_ubcb_1 = tk.Label(frame_ub1,text='h',width=6)
lbl_ubcb_1.grid(row=0, column=1)
txt_ubcb_1 = ttk.Entry(frame_ub1,width=5)
txt_ubcb_1.insert(0,'0')
txt_ubcb_1.grid(row=1, column=1,sticky="NSEW")

lbl_ubcb_2 = tk.Label(frame_ub1,text='k',width=6)
lbl_ubcb_2.grid(row=0, column=2)
txt_ubcb_2 = ttk.Entry(frame_ub1,width=5)
txt_ubcb_2.insert(0,'0')
txt_ubcb_2.grid(row=1, column=2,sticky="NSEW")

lbl_ubcb_3 = tk.Label(frame_ub1,text='l',width=6)
lbl_ubcb_3.grid(row=0, column=3)
txt_ubcb_3 = ttk.Entry(frame_ub1,width=5)
txt_ubcb_3.insert(0,'0')
txt_ubcb_3.grid(row=1, column=3,sticky="NSEW")

# hwの入力
lbl_ubc_0 = tk.Label(frame_ub2,text='ℏω',width=6)
lbl_ubc_0.grid(row=0, column=0)
txt_ubc_0 = ttk.Entry(frame_ub2,width=5)
txt_ubc_0.insert(0,'0')
txt_ubc_0.grid(row=1, column=0,sticky="NSEW")

# 指数を指定
lbl_ubc_1 = tk.Label(frame_ub2,text='h',width=6)
lbl_ubc_1.grid(row=0, column=1)
txt_ubc_1 = ttk.Entry(frame_ub2,width=5)
txt_ubc_1.insert(0,'0')
txt_ubc_1.grid(row=1, column=1,sticky="NSEW")

lbl_ubc_2 = tk.Label(frame_ub2,text='k',width=6)
lbl_ubc_2.grid(row=0, column=2)
txt_ubc_2 = ttk.Entry(frame_ub2,width=5)
txt_ubc_2.insert(0,'0')
txt_ubc_2.grid(row=1, column=2,sticky="NSEW")

lbl_ubc_3 = tk.Label(frame_ub2,text='l',width=6)
lbl_ubc_3.grid(row=0, column=3)
txt_ubc_3 = ttk.Entry(frame_ub2,width=5)
txt_ubc_3.insert(0,'0')
txt_ubc_3.grid(row=1, column=3,sticky="NSEW")

# UBmatrixの表示
txt_ub_11 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_11.insert(0,'0')
txt_ub_11.grid(row=0, column=0,sticky="NSEW")
txt_ub_12 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_12.insert(0,'0')
txt_ub_12.grid(row=0, column=1,sticky="NSEW")
txt_ub_13 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_13.insert(0,'0')
txt_ub_13.grid(row=0, column=2,sticky="NSEW")
txt_ub_21 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_21.insert(0,'0')
txt_ub_21.grid(row=1, column=0,sticky="NSEW")
txt_ub_22 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_22.insert(0,'0')
txt_ub_22.grid(row=1, column=1,sticky="NSEW")
txt_ub_23 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_23.insert(0,'0')
txt_ub_23.grid(row=1, column=2,sticky="NSEW")
txt_ub_31 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_31.insert(0,'0')
txt_ub_31.grid(row=2, column=0,sticky="NSEW")
txt_ub_32 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_32.insert(0,'0')
txt_ub_32.grid(row=2, column=1,sticky="NSEW")
txt_ub_33 = ttk.Entry(frame_ub4,width=5,state="readonly")
txt_ub_33.insert(0,'0')
txt_ub_33.grid(row=2, column=2,sticky="NSEW")

# angle calculationの結果表示
lbl_ubc_r1 = tk.Label(frame_ub3,text='C1',width=6)
lbl_ubc_r1.grid(row=0, column=1)
txt_ubc_r1 = ttk.Entry(frame_ub3,width=5,state="readonly")
txt_ubc_r1.insert(0,'0')
txt_ubc_r1.grid(row=1, column=1,sticky="NSEW")

lbl_ubc_r2 = tk.Label(frame_ub3,text='A1',width=6)
lbl_ubc_r2.grid(row=0, column=2)
txt_ubc_r2 = ttk.Entry(frame_ub3,width=5,state="readonly")
txt_ubc_r2.insert(0,'0')
txt_ubc_r2.grid(row=1, column=2,sticky="NSEW")

lbl_ubc_r3 = tk.Label(frame_ub3,text='C2',width=6)
lbl_ubc_r3.grid(row=0, column=3)
txt_ubc_r3 = ttk.Entry(frame_ub3,width=5,state="readonly")
txt_ubc_r3.insert(0,'0')
txt_ubc_r3.grid(row=1, column=3,sticky="NSEW")

lbl_ubc_r4 = tk.Label(frame_ub3,text='A2',width=6)
lbl_ubc_r4.grid(row=0, column=4)
txt_ubc_r4 = ttk.Entry(frame_ub3,width=5,state="readonly")
txt_ubc_r4.insert(0,'0')
txt_ubc_r4.grid(row=1, column=4,sticky="NSEW")

lbl_ubc_r5 = tk.Label(frame_ub3,text='μ',width=6)
lbl_ubc_r5.grid(row=0, column=5)
txt_ubc_r5 = ttk.Entry(frame_ub3,width=5,state="readonly")
txt_ubc_r5.insert(0,'0')
txt_ubc_r5.grid(row=1, column=5,sticky="NSEW")

#lbl_ubc_r6 = tk.Label(frame_ub3,text='ν',width=6)
#lbl_ubc_r6.grid(row=0, column=6)
#txt_ubc_r6 = ttk.Entry(frame_ub3,width=5,state="readonly")
#txt_ubc_r6.insert(0,'0')
#txt_ubc_r6.grid(row=1, column=6,sticky="NSEW")

lbl_ubc_m1 = tk.Label(frame_ub3,text='warning',width=6)
lbl_ubc_m1.grid(row=2, column=0)

lbl_ubc_m2 = tk.Label(frame_ub3,text='')
lbl_ubc_m2.grid(row=2, column=1,columnspan=6)

# hardware limitの入力
lbl_ubc_hl1 = tk.Label(frame_ub5,text='A1',width=6)
lbl_ubc_hl1.grid(row=0, column=0)
txt_ubc_hl11 = ttk.Entry(frame_ub5,width=5)
txt_ubc_hl11.insert(0,'39.861')
txt_ubc_hl11.grid(row=0, column=1,sticky="NSEW")
lbl_ubc_hl1 = tk.Label(frame_ub5,text='~',width=6)
lbl_ubc_hl1.grid(row=0, column=2)
txt_ubc_hl12 = ttk.Entry(frame_ub5,width=5)
txt_ubc_hl12.insert(0,'116.964')
txt_ubc_hl12.grid(row=0, column=3,sticky="NSEW")

lbl_ubc_hl2 = tk.Label(frame_ub5,text='C2',width=6)
lbl_ubc_hl2.grid(row=1, column=0)
txt_ubc_hl21 = ttk.Entry(frame_ub5,width=5)
txt_ubc_hl21.insert(0,'-135')
txt_ubc_hl21.grid(row=1, column=1,sticky="NSEW")
lbl_ubc_hl2 = tk.Label(frame_ub5,text='~',width=6)
lbl_ubc_hl2.grid(row=1, column=2)
txt_ubc_hl22 = ttk.Entry(frame_ub5,width=5)
txt_ubc_hl22.insert(0,'150')
txt_ubc_hl22.grid(row=1, column=3,sticky="NSEW")

lbl_ubc_hl3 = tk.Label(frame_ub5,text='A2',width=6)
lbl_ubc_hl3.grid(row=2, column=0)
txt_ubc_hl31 = ttk.Entry(frame_ub5,width=5)
txt_ubc_hl31.insert(0,'6')
txt_ubc_hl31.grid(row=2, column=1,sticky="NSEW")
lbl_ubc_hl3 = tk.Label(frame_ub5,text='~',width=6)
lbl_ubc_hl3.grid(row=2, column=2)
txt_ubc_hl32 = ttk.Entry(frame_ub5,width=5)
txt_ubc_hl32.insert(0,'100')
txt_ubc_hl32.grid(row=2, column=3,sticky="NSEW")

# SPICEのファイルからUBパラメータを読みだす。
def calculate_c2():
    # UBmatrixの読み込み
    with open(file_paths[0],"r", encoding="utf-8") as f:
        ub = f.readlines()[21].strip()
        ub1 = ub.split(',')
        ub2 = re.sub(r"[^\d.-]", '',ub1[0])
        UB=[[ub2,ub1[1],ub1[2]],[ub1[3],ub1[4],ub1[5]],[ub1[6],ub1[7],ub1[8]]]
        # 数値に変換する
        UBmatrix = np.array([[float(value) for value in row] for row in UB])
    
    # UB matrixを表示
    txt_ub_11.config(state="normal")  # 一時的に編集可能に
    txt_ub_11.delete(0, tk.END)
    txt_ub_11.insert(0, ub2)
    txt_ub_11.config(state="readonly") # 編集不可に設定
    txt_ub_12.config(state="normal")  # 一時的に編集可能に
    txt_ub_12.delete(0, tk.END)
    txt_ub_12.insert(0, ub1[1])
    txt_ub_12.config(state="readonly") # 編集不可に設定
    txt_ub_13.config(state="normal")  # 一時的に編集可能に
    txt_ub_13.delete(0, tk.END)
    txt_ub_13.insert(0, ub1[2])
    txt_ub_13.config(state="readonly") # 編集不可に設定
    txt_ub_21.config(state="normal")  # 一時的に編集可能に
    txt_ub_21.delete(0, tk.END)
    txt_ub_21.insert(0, ub1[3])
    txt_ub_21.config(state="readonly") # 編集不可に設定
    txt_ub_22.config(state="normal")  # 一時的に編集可能に
    txt_ub_22.delete(0, tk.END)
    txt_ub_22.insert(0, ub1[4])
    txt_ub_22.config(state="readonly") # 編集不可に設定
    txt_ub_23.config(state="normal")  # 一時的に編集可能に
    txt_ub_23.delete(0, tk.END)
    txt_ub_23.insert(0, ub1[5])
    txt_ub_23.config(state="readonly") # 編集不可に設定
    txt_ub_31.config(state="normal")  # 一時的に編集可能に
    txt_ub_31.delete(0, tk.END)
    txt_ub_31.insert(0, ub1[6])
    txt_ub_31.config(state="readonly") # 編集不可に設定
    txt_ub_32.config(state="normal")  # 一時的に編集可能に
    txt_ub_32.delete(0, tk.END)
    txt_ub_32.insert(0, ub1[7])
    txt_ub_32.config(state="readonly") # 編集不可に設定
    txt_ub_33.config(state="normal")  # 一時的に編集可能に
    txt_ub_33.delete(0, tk.END)
    txt_ub_33.insert(0, ub1[8])
    txt_ub_33.config(state="readonly") # 編集不可に設定
    
    # 入力した値を取り込む
    la=float(txt1.get())
    lb=float(txt2.get())
    lc=float(txt3.get())
    lal=float(txt4.get())
    lbe=float(txt5.get())
    lga=float(txt6.get())
    #c2_off=float(txt7.get())
    #Vt=float(txt8.get())
    #N_mcu=float(txt15.get())
    C2_bp=float(txt_ubcb_0.get())
    h_bp=float(txt_ubcb_1.get())
    k_bp=float(txt_ubcb_2.get())
    l_bp=float(txt_ubcb_3.get())
    hw_cal=float(txt_ubc_0.get())
    h_cal=float(txt_ubc_1.get())
    k_cal=float(txt_ubc_2.get())
    l_cal=float(txt_ubc_3.get())
    A1_min=float(txt_ubc_hl11.get())
    A1_max=float(txt_ubc_hl12.get())
    C2_min=float(txt_ubc_hl21.get())
    C2_max=float(txt_ubc_hl22.get())
    A2_min=float(txt_ubc_hl31.get())
    A2_max=float(txt_ubc_hl32.get())

    # ベクトルu,v,wを定義し、rluを自動で計算する
    U = [la*math.cos(math.radians(0)), 0, 0]
    V = [lb*math.cos(math.radians(lga)), lb*math.sin(math.radians(lga)), 0]
    W = [lc*math.cos(math.radians(lbe)), lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)), math.sqrt(lc**2-(lc*math.cos(math.radians(lbe)))**2-(lc*(math.cos(math.radians(lal))-math.cos(math.radians(lbe))*math.cos(math.radians(lga)))/math.sin(math.radians(lga)))**2)]
    astar = 2*3.141592*np.cross(V,W)/np.dot(U,np.cross(V,W))
    bstar = 2*3.141592*np.cross(W,U)/np.dot(V,np.cross(W,U))
    cstar = 2*3.141592*np.cross(U,V)/np.dot(W,np.cross(U,V))

    # bragg peakの位置からoffsetを算出
    hkl_bp=h_bp*astar+k_bp*bstar+l_bp*cstar
    #計算されたrlu
    Nhkl_bp=np.linalg.norm(hkl_bp)
    #A2を計算
    kf=(3.635/2.072)**(1/2)
    ki=(3.635/2.072)**(1/2)
    phi_bp = np.degrees(np.arccos((ki**2 + kf**2 - Nhkl_bp**2) / (2 * ki * kf)))
    # thetaの計算.Qとkiのなす角度
    theta_bp = np.degrees(np.arctan((ki - kf * np.cos(np.radians(phi_bp))) / (kf * np.sin(np.radians(phi_bp)))))
    Theta_bp_mat =  np.array([[np.cos(np.radians(theta_bp)), -np.sin(np.radians(theta_bp)), 0],[np.sin(np.radians(theta_bp)),  np.cos(np.radians(theta_bp)), 0],[0, 0, 1]])
    # QLの計算
    QL_bp = np.array([0, kf, 0]) - np.array([-kf * np.sin(np.radians(phi_bp)), kf * np.cos(np.radians(phi_bp)), 0])
    # Qthetaの計算
    Qtheta_bp = np.linalg.inv(Theta_bp_mat).dot(QL_bp)
    Qtheta_bp = Qtheta_bp.reshape(-1, 1)  # 列ベクトルに変
    # UBmatrixの更新
    UBmatrix = 2 * np.pi * UBmatrix
    # Qv_pbの計算
    Qv_bp=UBmatrix.dot(np.array([h_bp, k_bp, l_bp]))
    Qv_bp = Qv_bp.reshape(-1, 1)  # 列ベクトルに変
    # R_pbの計算。SPICEではtilt方向の情報が既に入っているため、本当は必要ない。
    N_bp=[[1,0,0],[0,1,0],[0,0,1]]
    M_bp=[[1,0,0],[0,1,0],[0,0,1]]
    R_bp = Qv_bp.dot(np.linalg.pinv(Qtheta_bp)).dot(np.linalg.inv(N_bp)).dot(np.linalg.inv(M_bp))
    # omega_cal_pbの計算
    omega_cal_pb = np.degrees(np.arctan2(R_bp[1, 0], R_bp[0, 0]))
    # s_iniの計算
    s_ini = omega_cal_pb + theta_bp
    # offsetの計算
    offset = C2_bp - s_ini
    
    # hklの位置から各angleを算出
    hkl_cal=h_cal*astar+k_cal*bstar+l_cal*cstar
    Nhkl_cal=np.linalg.norm(hkl_cal)
    kf_cal=(3.635/2.072)**(1/2)
    ki_cal=((3.635+hw_cal)/2.072)**(1/2)
    #phi_cal = np.degrees(np.arccos((ki**2 + kf_cal**2 - Nhkl_cal**2) / (2 * ki_cal * kf_cal)))
    
    try:
        # phi_calの計算
        phi_cal = np.degrees(np.arccos((ki_cal**2 + kf_cal**2 - Nhkl_cal**2) / (2 * ki_cal * kf_cal)))

        # 値が計算できるか確認し、NaNなら例外を発生させる
        if np.isnan(phi_cal):
            raise ValueError("Calculation resulted in NaN")
        
        # phi_calが正常に計算された場合のみ、後続の計算を実行
        theta_cal = np.degrees(np.arctan((ki_cal - kf_cal * np.cos(np.radians(phi_cal))) / (kf_cal * np.sin(np.radians(phi_cal)))))
        Theta_cal_mat =  np.array([[np.cos(np.radians(theta_cal)), -np.sin(np.radians(theta_cal)), 0],[np.sin(np.radians(theta_cal)),  np.cos(np.radians(theta_cal)), 0],[0, 0, 1]])
        QL_cal = np.array([0, ki_cal, 0]) - np.array([-kf_cal * np.sin(np.radians(phi_cal)), kf_cal * np.cos(np.radians(phi_cal)), 0])
        Qtheta_cal = np.linalg.inv(Theta_cal_mat).dot(QL_cal)
        Qtheta_cal=Qtheta_cal.reshape(-1, 1)
        Qv_cal = UBmatrix.dot(np.array([h_cal, k_cal, l_cal]))
        Qv_cal=Qv_cal.reshape(-1, 1)
        N_cal = [[1,0,0],[0,1,0],[0,0,1]]
        M_cal = [[1,0,0],[0,1,0],[0,0,1]]
        R_cal = Qv_cal.dot(np.linalg.pinv(Qtheta_cal)).dot(np.linalg.inv(N_cal)).dot(np.linalg.inv(M_cal))
        omega_cal = np.degrees(np.arctan2(R_cal[1, 0], R_cal[0, 0]))
        mu_cal = np.degrees(np.arctan2(-R_cal[2, 0], np.sqrt(R_cal[0, 0]**2 + R_cal[1, 0]**2)))
        #nu_cal = np.degrees(np.arctan2(R_cal[2, 1], R_cal[2, 2]))
        s_cal=omega_cal+theta_cal
        omega_inst=s_cal+offset
        
        d = 3.355  # PGの場合
        Ei = hw_cal+3.635

        # A1とA2の計算
        C1 = np.degrees(np.arcsin((2 * np.pi / d) / (2 * np.sqrt(Ei / 2.072))))
        A1 = 2 * C1
        
        #C1
        txt_ubc_r1.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r1.delete(0, tk.END)
        txt_ubc_r1.insert(0, f"{C1:.3f}")
        # 範囲外の場合に赤字で表示
        if A1 < A1_min or A1 > A1_max:  # 範囲を設定
            txt_ubc_r1.config(foreground="red")
        else:
            txt_ubc_r1.config(foreground="black")  # 範囲内なら黒字で表示
        txt_ubc_r1.config(state="readonly") # 編集不可に設定
        #A1
        txt_ubc_r2.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r2.delete(0, tk.END)
        txt_ubc_r2.insert(0, f"{A1:.3f}")
        # 範囲外の場合に赤字で表示
        if A1 < A1_min or A1 > A1_max:  # 範囲を設定
            txt_ubc_r2.config(foreground="red")
        else:
            txt_ubc_r2.config(foreground="black")  # 範囲内なら黒字で表示
        txt_ubc_r2.config(state="readonly") # 編集不可に設定
        
        #C2
        txt_ubc_r3.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r3.delete(0, tk.END)
        txt_ubc_r3.insert(0, f"{omega_inst:.3f}")
        # 範囲外の場合に赤字で表示
        if omega_inst < C2_min or omega_inst > C2_max:  # 範囲を設定
            txt_ubc_r3.config(foreground="red")
        else:
            txt_ubc_r3.config(foreground="black")  # 範囲内なら黒字で表示
        txt_ubc_r3.config(state="readonly") # 編集不可に設定
        #A2
        txt_ubc_r4.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r4.delete(0, tk.END)
        txt_ubc_r4.insert(0, f"{phi_cal:.3f}")
        # 範囲外の場合に赤字で表示
        if phi_cal < A2_min or phi_cal > A2_max:  # 範囲を設定
            txt_ubc_r4.config(foreground="red")
        else:
            txt_ubc_r4.config(foreground="black")  # 範囲内なら黒字で表示
        txt_ubc_r4.config(state="readonly") # 編集不可に設定
        #mu
        txt_ubc_r5.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r5.delete(0, tk.END)
        txt_ubc_r5.insert(0, f"{mu_cal:.3f}")
        txt_ubc_r5.config(state="readonly") # 編集不可に設定
        #nu,パラメータとして機能しないため削除
        #txt_ubc_r6.config(state="normal")  # 一時的に編集可能に
        #txt_ubc_r6.delete(0, tk.END)
        #txt_ubc_r6.insert(0, nu_cal)
        #txt_ubc_r6.config(state="readonly") # 編集不可に設定
        
        # 関数: mu_calが範囲外の場合に警告メッセージを表示
        if mu_cal < -5 or mu_cal > 5:
            lbl_ubc_m2.config(text="It is outside the scattering plane. (-5 to 5 deg)")
        else:
            lbl_ubc_m2.config(text="")  # 範囲内の場合、警告を消す
        
    except ValueError:
        # 計算ができなかった場合、警告メッセージを表示
        lbl_ubc_m2.config(text="Unable to create scatter triangles.")
        #C1
        txt_ubc_r1.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r1.delete(0, tk.END)
        #txt_ubc_r1.insert(0, f"{C1:.3f}")
        txt_ubc_r1.config(state="readonly") # 編集不可に設定
        #A1
        txt_ubc_r2.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r2.delete(0, tk.END)
        #txt_ubc_r2.insert(0, f"{A1:.3f}")
        txt_ubc_r2.config(state="readonly") # 編集不可に設定
        #C2
        txt_ubc_r3.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r3.delete(0, tk.END)
        #txt_ubc_r3.insert(0, f"{omega_inst:.3f}")
        txt_ubc_r3.config(state="readonly") # 編集不可に設定
        #A2
        txt_ubc_r4.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r4.delete(0, tk.END)
        #txt_ubc_r4.insert(0, f"{phi_cal:.3f}")
        txt_ubc_r4.config(state="readonly") # 編集不可に設定
        #mu
        txt_ubc_r5.config(state="normal")  # 一時的に編集可能に
        txt_ubc_r5.delete(0, tk.END)
        #txt_ubc_r5.insert(0, f"{mu_cal:.3f}")
        txt_ubc_r5.config(state="readonly") # 編集不可に設定
    
#SPICE出力ファイルからUBマトリックスを読み込みC2を自動入力
button_ubc_1 = ttk.Button(frame_ub3,text="calculation",command=calculate_c2)
button_ubc_1.grid(row=1, column=0, sticky="NSEW")

###############################################################################
#サブウィンドウでfittingプログラムを作成する。

###############################################################################

#メニューバーの作成
menubar = tk.Menu(root)
root.configure(menu=menubar)

import csv

#saveメニューの定義群
def save_FGdata():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as foreground data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成,# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
    header = ['Qx(Å^-1)', 'Qy(Å^-1)', 'q (Å^-1)', 'hw (meV)', 'normalizerd I (a.u.)', 'normalizerd Err (a.u.)']
    #データ保存
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header)
        writer.writerows(databox.T)
        
def save_BGdata():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as Background data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成,# 0 Qx, 1 Qy, 2 Q, 3 エネルギートランスファー,　4 規格化強度,  5 規格化エラーバー
    header = ['Qx(Å^-1)', 'Qy(Å^-1)', 'q (Å^-1)', 'hw (meV)', 'normalizerd I (a.u.)', 'normalizerd Err (a.u.)']
    #データ保存
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header)
        writer.writerows(sb_databox.T)

#saveメニューの定義
def save_constEmap():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as U-V 2D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = [f'{Ulabel} (r.l.u.)' ,  f'{u} (r.l.u.) ']
    header2 = [f'{Vlabel} (r.l.u.)' ,  f'{v} (r.l.u.) ']
    header3 = [f'Intensity (a.u.) (x-axis:{Ulabel} (r.l.u.), y-axis:{Vlabel} (r.l.u.) )']
    header4 = [f'Error (a.u.) (x-axis:{Ulabel} (r.l.u.), y-axis:{Vlabel} (r.l.u.) )']
    #データ保存(データの大きさが違うので、行列を連結することができない。なので１行目から順に保存していく形式にした。)
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(Erange_2d_VvsU)
        writer.writerow(header1)
        writer.writerows(Urange_2d_VvsU)
        writer.writerow(header2)
        writer.writerows(Vrange_2d_VvsU)
        writer.writerow(header3)
        writer.writerows(I_ce)
        writer.writerow(header4)
        writer.writerows(Ierr_ce)

#saveメニューの定義
def save_hw_Umap():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as hw-U 2D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = [f'{Ulabel} (r.l.u.)' ,  f'{u} (r.l.u.) ']
    header2 = [f'{Vlabel} (r.l.u.)' ,  f'{v} (r.l.u.) ']
    header3 = [f'Intensity (a.u.) (x-axis:{Ulabel} (r.l.u.), y-axis:hw (meV) )']
    header4 = [f'Error (a.u.) (x-axis:{Ulabel} (r.l.u.), y-axis:hw (meV) )']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(Erange_2d_UvsE)
        writer.writerow(header1)
        writer.writerows(Urange_2d_UvsE)
        writer.writerow(header2)
        writer.writerows(Vrange_2d_UvsE)
        writer.writerow(header3)
        writer.writerows(I_hwU)
        writer.writerow(header4)
        writer.writerows(Ierr_hwU)

#saveメニューの定義
def save_hw_Vmap():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as hw-V 2D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = [f'{Ulabel} (r.l.u.)' ,  f'{u} (r.l.u.) ']
    header2 = [f'{Vlabel} (r.l.u.)' ,  f'{v} (r.l.u.) ']
    header3 = [f'Intensity (a.u.) (x-axis:{Vlabel} (r.l.u.), y-axis:hw (meV) )']
    header4 = [f'Error (a.u.) (x-axis:{Vlabel} (r.l.u.), y-axis:hw (meV) )']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(Erange_2d_VvsE)
        writer.writerow(header1)
        writer.writerows(Urange_2d_VvsE)
        writer.writerow(header2)
        writer.writerows(Vrange_2d_VvsE)
        writer.writerow(header3)
        writer.writerows(I_hwV)
        writer.writerow(header4)
        writer.writerows(Ierr_hwV)

#saveメニューの定義
def save_1Dhw_I():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as I-hw 1D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成f'{txt_vl.get()}
    header0 = ['hw (meV)']
    header1 = [f'{Ulabel} (r.l.u.)' ,  f'{u} (r.l.u.) ']
    header2 = [f'{Vlabel} (r.l.u.)' ,  f'{v} (r.l.u.) ']
    header3 = ['Intensity (a.u.)']
    header4 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(Erange_1d_Ivshw)
        writer.writerow(header1)
        writer.writerows(Urange_1d_Ivshw)
        writer.writerow(header2)
        writer.writerows(Vrange_1d_Ivshw)
        writer.writerow(header3)
        writer.writerow(I_hw1d2)
        writer.writerow(header4)
        writer.writerow(Ierr_hw1d2)

#saveメニューの定義
def save_1DI_U():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as I-U 1D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = [f'{Ulabel} (r.l.u.)' ,  f'{u} (r.l.u.) ']
    header2 = [f'{Vlabel} (r.l.u.)' ,  f'{v} (r.l.u.) ']
    header3 = ['Intensity (a.u.)']
    header4 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(Erange_1d_IvsU)
        writer.writerow(header1)
        writer.writerows(Urange_1d_IvsU)
        writer.writerow(header2)
        writer.writerows(Vrange_1d_IvsU)
        writer.writerow(header3)
        writer.writerow(I_1DU)
        writer.writerow(header4)
        writer.writerow(Ierr_1DU)

#saveメニューの定義
def save_1DI_V():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as I-V 1D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = [f'{Ulabel} (r.l.u.)' ,  f'{u} (r.l.u.) ']
    header2 = [f'{Vlabel} (r.l.u.)' ,  f'{v} (r.l.u.) ']
    header3 = ['Intensity (a.u.)']
    header4 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(Erange_1d_IvsV)
        writer.writerow(header1)
        writer.writerows(Urange_1d_IvsV)
        writer.writerow(header2)
        writer.writerows(Vrange_1d_IvsV)
        writer.writerow(header3)
        writer.writerow(I_1DV)
        writer.writerow(header4)
        writer.writerow(Ierr_1DV)
        
#saveメニューの定義
def save_hw_HKL():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as hw-V 2D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = ['HKL (r.l.u.)']
    header2 = ['hkl (r.l.u.)']
    header3 = ['Intensity (a.u.) (x-axis:HKL (r.l.u.), y-axis:hw (meV) )']
    header4 = ['Error (a.u.) (x-axis:HKL (r.l.u.), y-axis:hw (meV) )']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(energylist)
        writer.writerow(header1)
        writer.writerows(table_2D.T)
        writer.writerow(header2)
        writer.writerows(table_2D_qrange)
        writer.writerow(header3)
        writer.writerows(I_cq)
        writer.writerow(header4)
        writer.writerows(I_cq_err)
        
#saveメニューの定義
def save_hkl_HKL():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as hw-V 2D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = ['HKL (r.l.u.)']
    header2 = ['hkl (r.l.u.)']
    header3 = ['Intensity (a.u.) (x-axis:HKL (r.l.u.), y-axis:hkl (r.l.u.) )']
    header4 = ['Error (a.u.) (x-axis:HKL (r.l.u.), y-axis:hkl (r.l.u.) )']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(E_I_ce)
        writer.writerow(header1)
        writer.writerows(table_2DX.T)
        writer.writerow(header2)
        writer.writerows(table_2DY.T)
        writer.writerow(header3)
        writer.writerows(I_ce_adv)
        writer.writerow(header4)
        writer.writerows(Ierr_ce_adv)
        
#saveメニューの定義
def save_I_HKL():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as advance_1D_I-HKL data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = ['hkl (r.l.u.)']
    header2 = ['HKL (r.l.u.)']
    header3 = ['Intensity (a.u.)']
    header4 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(I_1d_IvsHKL_E)
        writer.writerow(header1)
        writer.writerows(I_1d_IvsHKL_hkl)
        writer.writerow(header2)
        writer.writerows(I_1d_IvsHKL_HKL)
        writer.writerow(header3)
        writer.writerow(I_1d_alongQ)
        writer.writerow(header4)
        writer.writerow(I_1d_alongQ_err)
        
#saveメニューの定義
def save_I_hw():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as advance_1D_I-HKL data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['hw (meV)']
    header1 = ['hkl (r.l.u.)']
    header2 = ['HKL (r.l.u.)']
    header3 = ['Intensity (a.u.)']
    header4 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(I_1d_Ivshw_E)
        writer.writerow(header1)
        writer.writerows(I_1d_Ivshw_hkl)
        writer.writerow(header2)
        writer.writerows(I_1d_Ivshw_HKL)
        writer.writerow(header3)
        writer.writerow(I_1d_alongE)
        writer.writerow(header4)
        writer.writerow(I_1d_alongE_err)
        
#fileメニュー(単結晶)
filemenu = tk.Menu(menubar,tearoff=0)
menubar.add_cascade(label="file(s.c.)",menu=filemenu)
#fileメニューにsaveを追加
filemenu.add_command(label="save foreground data",command=save_FGdata)
#fileメニューにsaveを追加
filemenu.add_command(label="save background data",command=save_BGdata)
#fileメニューにsaveを追加
filemenu.add_command(label=f"save 2D_{entry_u_var.get()}-{entry_v_var.get()}",command=save_constEmap)
save_menu_index1 = filemenu.index(tk.END)
#fileメニューにsaveを追加
filemenu.add_command(label=f"save 2D_ℏω-{entry_v_var.get()}",command=save_hw_Vmap)
save_menu_index2 = filemenu.index(tk.END)
#fileメニューにsaveを追加
filemenu.add_command(label=f"save 2D_ℏω-{entry_u_var.get()}",command=save_hw_Umap)
save_menu_index3 = filemenu.index(tk.END)
#fileメニューにsaveを追加
filemenu.add_command(label="save 1D_I-ℏω",command=save_1Dhw_I)
#fileメニューにsaveを追加
filemenu.add_command(label="save 1D_I-U",command=save_1DI_U)
save_menu_index4 = filemenu.index(tk.END)
#fileメニューにsaveを追加
filemenu.add_command(label="save 1D_I-V",command=save_1DI_V)
save_menu_index5 = filemenu.index(tk.END)
#fileメニューにsaveを追加
filemenu.add_command(label="save advanced_2D_hkl-HKL",command=save_hkl_HKL)
#fileメニューにsaveを追加
filemenu.add_command(label="save advanced_2D_ℏω-HKL",command=save_hw_HKL)
#fileメニューにsaveを追加
filemenu.add_command(label="save advanced_1D_I-ℏω",command=save_I_hw)
#fileメニューにsaveを追加
filemenu.add_command(label="save advanced_1D_I-HKL",command=save_I_HKL)
#fileメニューにexitを追加。ついでにexit funcも実装
filemenu.add_command(label="exit",command=lambda:root.destroy())

#saveメニューの定義
def save_1D_hw_qmap():#plt.pcolormesh(Q, hwlist_p , Ipow, cmap='jet', vmin=z_min, vmax=z_max)
    filename = tk.filedialog.asksaveasfilename(
        title = "save as hw-Q 2D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header1 = ['hw (meV)']
    header2 = ['Q (Å^-1)']
    header3 = ['Intensity (a.u.)']
    header4 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header1)
        writer.writerow(energylist)
        writer.writerow(header2)
        writer.writerow(Q2)
        writer.writerow(header3)
        writer.writerows(Ipow)
        writer.writerow(header4)
        writer.writerows(Ipow_err)


#saveメニューの定義
def save_1D_hwI_pow():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as I-hw 1D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['q (Å^-1)']
    header1 = ['hw (meV)']
    header2 = ['Intensity (a.u.)']
    header3 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(qlist)
        writer.writerow(header1)
        writer.writerow(elist)
        writer.writerow(header2)
        writer.writerow(Ipow_1dei)
        writer.writerow(header3)
        writer.writerow(Ipowerr_1dei)

#saveメニューの定義
def save_1D_qI_pow():
    filename = tk.filedialog.asksaveasfilename(
        title = "save as I-Q 1D data",
        filetypes = [("CSV", ".csv") ], # ファイルフィルタ
        initialdir = "./", # 自分自身のディレクトリ
        defaultextension = "csv"
        )
    #ヘッダーの作成
    header0 = ['q (Å^-1)']
    header1 = ['hw (meV)']
    header2 = ['Intensity (a.u.)']
    header3 = ['Error (a.u.)']
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header0)
        writer.writerow(qlist2)
        writer.writerow(header1)
        writer.writerow(elist2)
        writer.writerow(header2)
        writer.writerow(Ipow_1dqi)
        writer.writerow(header3)
        writer.writerow(Ipowerr_1dqi)

#fileメニュー(粉末)
filemenu_p = tk.Menu(menubar,tearoff=0)
menubar.add_cascade(label="file(p.)",menu=filemenu_p)
#fileメニューにsaveを追加
filemenu_p.add_command(label="save foreground data",command=save_FGdata)
#fileメニューにsaveを追加
filemenu_p.add_command(label="save background data",command=save_BGdata)
#fileメニューにsaveを追加
filemenu_p.add_command(label="save 2D_ℏω-q",command=save_1D_hw_qmap)#plt.pcolormesh(Q, hwlist_p , Ipow, cmap='jet', vmin=z_min, vmax=z_max)
#fileメニューにsaveを追加
filemenu_p.add_command(label="save 1D_I-ℏω",command=save_1D_hwI_pow)#plt.errorbar(energylist, Ipow_1dei, yerr=Ipowerr_1dei, capsize=10)
#fileメニューにsaveを追加
filemenu_p.add_command(label="save 1D_I-q",command=save_1D_qI_pow)#plt.errorbar(Q2, Ipow_1dqi, yerr=Ipowerr_1dqi, capsize=10)
#fileメニューにexitを追加。ついでにexit funcも実装
filemenu_p.add_command(label="exit",command=lambda:root.destroy())


#helpメニュー
helpmenu = tk.Menu(menubar,tearoff=0)
menubar.add_cascade(label="help",menu=helpmenu)

def copy_email_to_clipboard(email):
    pyperclip.copy(email)
    messagebox.showinfo("Copy to Clipboard", f"{email} has been copied to the clipboard.")

def show_contact():
    email = "hodaka.kikuchi@issp.u-tokyo.ac.jp"
    
    # 連絡先情報のメッセージを作成
    contact_message = (
        "e-mail address:\n"
        f"{email}\n\n"
        "This software, if you have any questions, requests, or issues, please contact the email address above.\n"
        "When sending an email, please include 'ASYURA' in the subject to prevent it from being classified as spam.\n\n"
        "Would you like to copy the email address to the clipboard?\n"
    )
    
    # Yes/No ボタンの結果を取得
    result = messagebox.askyesno("Contact Information", contact_message, icon=messagebox.INFO)

    # Yes ボタンがクリックされた場合にのみクリップボードにコピー
    if result:
        copy_email_to_clipboard(email)

#helpメニューにcontactを追加
helpmenu.add_command(label="contact developer",command=show_contact)

# HODACAのURLのリンク
def open_manual():
    # HODACAのURLを指定
    manual_url = "https://sites.google.com/view/hodaca/%E3%83%9B%E3%83%BC%E3%83%A0"

    # 確認ダイアログを表示
    result = messagebox.askyesno("Confirmation", "Do you want to access the HODACA website?")

    # ユーザーがYesを選択した場合、URLをブラウザで開く
    if result:
        webbrowser.open(manual_url)

# "Contact"メニュー項目を作成し、クリック時にopen_manual()関数を呼び出す
helpmenu.add_command(label="HODACA web site", command=open_manual)

##########################################################################
# labelの初回updateコマンド

# 初期表示のためにラベルを更新
update_labels()

# StringVarに変更があった時に呼ばれる関数をバインド
# HKLの名称を変更する場合のtrace、メニューバーの名称を変更しているためここに無いと最初の立ち上げでエラーを吐く。ただしちゃんと反映はされる。
entry_u_var.trace("w", update_UVlabel1)
entry_v_var.trace("w", update_UVlabel1)

# 初期値を設定
entry_u_var.set("H")
entry_v_var.set("K")

#window状態の維持
root.mainloop()

#############
# pyinstaller tips
# 次回から以下のコマンドでexe化する。うまくいったコマンド
# pyinstaller -F --noconsole --icon=asyura.ico ASYURA.py
# 2023/10/07 21:00以降 noconsoleが効かない。onefileにはできからよしとする
# セキュリティソフトの問題らしい。endpoint antivirusを1時オフにしたけどできなかった。正直UIもよくわからんし、勝手にファイルを隔離するしでクソ。
# 以下推奨。コンソールは表示されるけど、この問題が解決するまではこれで行く。
# pyinstaller -F --icon=asyuraicon.ico ASYURA.py
# 2023/10/08 なんかtrendアンチウイルスソフトの検索除外にこのディレクトリを指定したら以下のコマンドでも動くようになった。
# pyinstaller -F --noconsole  --icon=ASYURA_logo.ico ASYURA.py
"""
コマンド
pyinstaller ASYURA.py --noconsole
--onedir or -D
出力を1ディレクトリにまとめる
--onefile or -F
出力を1ファイルにまとめる
--noconsole or -w
コンソールを表示しない
--clean
ビルド前に前回のキャッシュと出力ディレクトリを削除
"""
#############